# C 语言第 2 部分中的运算符

> 原文：<https://www.sitepoint.com/operators-in-c-part-2/>

本文是上一篇文章“C 语言中的操作符”的续篇，在上一篇文章中，我们从后缀操作符开始，讨论了数组下标操作符和函数调用操作符。继续后缀运算符，第三个运算符是**点运算符(。)**和**箭头操作符(- > )** ，用于访问结构和联合成员。

## **3。结构和工会成员**

**结构**是用户定义的数据类型，它是一组有序数据对象的集合。与数组的元素不同，结构中的数据对象具有不同的数据类型。结构/联合中的每个数据对象被称为结构/联合的一个**成员**。

一个**联合**也是一个用户定义的类型，它是具有不同数据类型的数据对象的集合。但是，与结构不同，联合的成员共享相同的存储区域，即使各个成员的类型可能不同。因此，一个并集允许几个不同的数据项在不同的时间存储在计算机内存的同一部分。

例如:

```
struct student{
               int student_id;
               char[] student_name;
               };
```

上面的结构声明创建了一个名为`student`的用户定义数据类型。结构学生有两个成员:`student_id` 和`student_name.`

为了访问一个结构的成员，我们需要首先声明一个用户定义数据类型的变量`student`，然后我们将使用点操作符`(.)`来访问该结构的单个成员。

```
struct student student1;
```

上面的语句创建了一个`student`类型的**结构变量** `student1`。现在，为了访问结构的每个成员，我们将使用点运算符。

### **点运算符**

The **dot operator** is used to access a structure or union member.

> 语法:
> 
> structurevariable.membername

示例:

```
                    student1.student_id=101;
                    student1.student_name="Alice";
```

上面两条语句访问结构的单个成员，并为它们赋值。

使用点运算符也可以以同样的方式访问联合。联合的声明方式如下:

> 工会名称{
> 
> 数据类型 1 成员 1；
> 
> 数据类型 2 成员 2；
> 
> 。
> 
> 。
> 
> 。
> 
> membern 数据类型：
> 
> };

声明联合变量的语法:

> union unionname 变量；

要访问工会成员:

> 变量.成员

### **箭头运算符**

结构/联合变量的起始地址可以存储在指针变量中，然后可以使用指针变量和**箭头操作符- >访问结构/联合的单个成员。**

例如:

```
struct student student1;
```

```
struct student *stud1;
```

声明一个指向结构` student`的指针。为了在指针变量 `*stud1`中存储结构变量`student1`的初始地址，我们将使用操作符 `&`的**地址。**

```
*stud1=&student1;
```

现在，要访问单个成员，我们可以按以下方式使用指针`*stud1`和箭头操作符:

```
stud1->student_id;
```

```
stud1->student_name;
```

在联合的情况下，箭头操作符以类似的方式使用。当我们在后面的文章中讨论结构和联合时，将更详细地讨论点操作符和箭头操作符。

## **4。后缀递增和递减运算符**

**后缀增量和后缀减量操作符只对一个操作数进行操作，该操作数可以是指针变量，也可以是属于真实数据类型的变量:整数类型和浮点类型(`int, float, double`以及各种类型修饰符)。**

 **后缀增量操作(操作数++)将变量值增加 1，后缀减量操作(操作数–)将变量值减少 1。

E++形式的后缀表达式等价于 E=E+1，其中 E 是一个变量。类似地，E–形式的后缀表达式等价于 E=E-1。

因此，

```
int i=10;
i++;
```

```
printf("%d",i); //prints 11
i--;
```

```
printf("%d",i); //prints 10
```

当与赋值运算符(=)结合使用时，后缀递增或递减运算的结果是不同的。在后缀递增/递减操作中，被递增/递减的变量的前一个值首先被分配给包含后缀递增/递减操作结果的变量，然后执行递增/递减操作；也就是说，*分配首先发生，然后是递增/递减*。为了理解这一点，请考虑以下示例:

```
#include<stdio.h>

int main()
{
int a, i=10;
a=i++;
printf("a=%d, i=%d", a,i);
a=i--;
printf("a=%d, i=%d", a,i);
return 0;
}
```

```
 Output:
```

```
a=10, i=11
```

```
a=11,i=10
```

这是因为在后缀递增/递减操作中，I 的值首先被赋给 a，然后被更新。

因此，在第一个语句中，`a=i++; ` `a`首先被赋予`i `的先前值 10，然后`i`被更新为 11。

在第二个语句中，`a=i--;` `a`再次被赋予`i` 的先前值(由于先前的递增操作，现在 i=11)，然后 `i`被递减到 10。

## 5.复合文字

由带括号的数据类型名称后面跟一个用大括号括起来的初始值设定项列表组成的后缀表达式称为复合文字。数据类型可以是**完整类型(char、有符号和无符号整数类型、浮点类型和指针类型)，也可以是大小未知的数组，**但不是可变长度的数组(我们将在后面关于数组的文章中讨论可变长度数组)。

复合文本初始化未命名的对象。如果数据类型名指定了一个未知大小的数组，那么这个数组的大小是由初始化列表中元素的数量决定的。

复合文字的一些示例如下:

### 未知大小的数组

```
     (int []){ 2,4,7,6};
```

上面的复合文字是一个未知大小的整数类型数组。初始化完成后，数组的大小确定为 4。

### 使用复合文字创建结构对象

为了创建一个结构对象，我们通过单独的初始化语句初始化结构的每个成员；诸如

```
     struct student student1;
```

```
     student1.student_id=101;
```

```
     student2.student_name="Alice";
```

通过以下方式使用复合文字，可以以更紧凑的形式实现这一点:

```
(struct student1){.student_id=101,
.student_name="Alice"};
```

请注意，大括号中仍在使用点运算符。

### 指向用作复合文字的结构的指针

为了使用指针初始化结构成员，我们声明一个指向结构对象的指针，然后使用箭头操作符在单独的初始化语句中初始化每个成员；就像:

```
struct student student1, *stud1;
```

```
*stud1=&student1;
```

```
stud1->student_id=101;
```

```
stud1->student_name="Alice";
```

为了使用复合文字执行相同的工作，我们不使用箭头操作符。相反，同样的事情可以通过使用如下所示的**点操作符**和操作符&的**地址以非常简洁的方式完成:**

```
&(struct student1){.student_id=101, .student_name="Alice"};
```

### 创建常量复合文字

只读复合文本；即常量复合文字，可以通过在 **const 关键字:**前加前缀来指定

```
(const int[]){1,2,3,4,5};
```

```
(const char[]){"Temperature"};
```

当使用复合文字时，编码变得更加紧凑。还有一些与复合文字相关的点，比如将它们传递给函数、它们的作用域等等，这些将在我们理解函数之后讨论。

## 一元运算符

一元运算符只对一个操作数进行运算。有四种一元运算符:

1.前缀递增和递减运算符

2.和间接运算符的地址

3.sizeof 和 alignof 运算符

4.一元算术运算符

### 前缀递增和递减运算符

前缀递增和递减操作符只对一个操作数进行操作，这个操作数可以是指针变量，也可以是属于真实数据类型的变量:整数类型和浮点类型(`int, float, double`以及各种类型修饰符)。

前缀递增运算(++操作数)将值增加 1，前缀递减运算(–操作数)将值减少 1。+E 形式的后缀表达式等价于 E=E+1，其中 E 是一个变量。类似地，形式为–E 的后缀表达式相当于 E=E-1。

可以看出，在后缀的情况下，递增/递减赋值首先发生，然后是递增/递减。然而，在**前缀递增或递减操作** *的情况下，先前的值首先递增/递减，然后进行分配。*

为了理解这一点，请考虑下面这段代码。

```
#include<stdio.h>

int main()
{
int i=10,a;
  ++i;
printf("Value of i=%d",i);//prints 11
  --i;
printf("Value of i=%d",i);//prints 10
a=++i;
printf("Value of a=%d",a);//prints 11
printf("Value of i=%d",i);//prints 11
a=--i;
printf("Value of a=%d",a);//prints 10
printf("Value of i=%d",i);//prints 10
return 0;
}
```

在这里，我们可以看到，I 的值首先被更新，然后被分配给 a。因此，a 包含 I 的*更新的*值，而不是之前的值，这与后缀递增/递减的情况不同。

### 和间接运算符的地址

运算符&的地址用于计算其操作数的地址。

间接运算符*用于计算存储在其操作数给定的地址中的值。操作数必须是指针类型；也就是说，它可以是一个数组(自引用指针)，一个指向变量的指针(数据指针)或者一个指向函数的指针(函数指针)。

数据指针的示例:

```
#include<stdio.h>

int main()

{

int val, a=10;

int *p;                       //declares a pointer variable

p=&a;                      //now p stores the address of a

val=*p;                  //now val stores the value of a

printf(" Address of a: %X", p);

printf("Value of a: %d",val);

return 0;

}
```

在上面的程序中，语句 `int *p`声明了一个整数指针(一个存储整数变量地址的指针)。

为了将 a 的地址存储在 p 中，将操作符的地址应用于 a，并将结果存储在 p 中，如指令`p=&a;`所示

现在`p=&a;`

假设 a 的地址是 1004，即`&a=1004`

由于 p 存储 a 的地址，那么`p=&a` p=1004

现在，地址 1004 处的值是存储在 a 中的值 10(a=10)。

为了使用指针变量`p`访问存储在 a 中的值，我们需要在`p`上应用间接操作符`*`。当在 p `(*p)`上应用间接运算符时，它读取存储在`p;` ie 中包含的地址处的值，即存储在地址 1004 处的值；即`a`的值。间接结果存储在整型变量`val`中，如语句`val =*p`所示；。间接操作符也被称为操作符处的**值，因为它给存储在**处的**值**一个特定的地址。

为了读取存储在 p 中的地址，在`printf`语句中使用格式说明符`%X`，因为地址通常是十六进制的。

在讨论数组下标操作符时，已经在一定程度上讨论了指针和数组之间的关系。函数指针是一个高级概念，将在后面关于指针的文章中讨论。

下一篇文章将继续讨论 c 语言中的一元运算符和其他运算符。

## 分享这篇文章****