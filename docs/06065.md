# 唯一指数及其基本原理

> 原文:[https://www.sitepoint.com/unique-index-rationale/](https://www.sitepoint.com/unique-index-rationale/)

这篇文章的灵感来自 Craig 最近的帖子“[如何在 MySQL 和其他数据库中使用唯一索引](https://www.sitepoint.com/use-unique-indexes-mysql-databases/)”。

关于主键(PK)和惟一索引(UI ),还有几个更紧密相关但同样重要的方面没有在那篇文章中讨论。

因此，在本文中，我们将进一步了解这些领域。

### 自动递增为主键

数据库设计者的一个常见做法是使用自动增量作为特定表的 PK。

正如[定义](http://www.w3schools.com/sql/sql_primarykey.asp)告诉我们的:

> 主键约束唯一标识数据库表中的每条记录。

确切地说，PK 是用来告诉数据库该记录是唯一的。

使用自动增量作为 PK 是一种简单但懒惰的方法来实现这一点。带有`id=1`的记录不同于带有`id=2`的记录。就是这样。

要记住的最重要的事情是，在大多数情况下，自动递增的 PK 字段是记录本身的**而不是**部分。那么如何才能依靠自动递增 PK 本身，与记录内容无关来识别一条记录呢？

以保存销售项目的典型记录为例。它可能包括以下字段:

*   id(自动递增)
*   发票号
*   客户端名称(或 id)
*   登录日期
*   项目名称(或 id)
*   量
*   单价
*   小计(计算字段)

一个“自然的”结构将引导我们使用 id 作为自动递增字段，从而作为 PK。我根本不相信这就足够了。

考虑以下两个条目:

```
1 12345 GoodGuy 13-12-12 item1 2 199 398
2 12346 GoodGuy 13-12-12 item1 2 199 398
```

它们是独一无二的还是仅仅是复制的？我宁愿将它们视为重复的条目，因为输入条目的人不小心打错了至少一个条目的发票号。

此外，在这个例子中，我们必须指出，即使是`invoice number`也不是充当 PK 或`unique index`的好人选。

我们将不得不使用复合唯一索引，即由几个字段组成的唯一索引，以确保记录的唯一性。

### 复合唯一指数

让我们先从数据库结构后退一步，看看实际的实体:一个销售商品。根据我们的经验和与销售人员的讨论，我们如何区分两个销售条目？

一般逻辑可能是:

1.  如果购买的项目不同，它们肯定是不同的销售项目；
2.  如果购买的物品是相同的，但是客户、日期、数量不同，它们就不同。
3.  …

视情况而定，可能有更多的方法。

现在更清楚了:如果两个销售条目有相同的项目、客户、日期、数量，那么**很可能**它们是重复的条目。因此，在这个数据库结构中，我们将根据上面列出的字段建立一个复合唯一索引:

```
ALTER TABLE `test`.`salesitem`
ADD UNIQUE INDEX `uniqueentry` (`itemid` ASC, `clientid` ASC, `date` ASC, `quantity` ASC);
```

将这个唯一性约束应用到我们的表中，我们将能够挑选出上面两个重复的条目。

**注意:**记住`uniqueentry`索引检测到的重复是**非常可能**。在实际情况下，它们可能根本不会重复(比如说`GoodGuy`只是在同一天重复下了一个完全相同的订单)。如果是这种情况，数据库设计人员必须与销售人员合作，进一步讨论在表结构和唯一索引组合中应该引入哪些其他字段，以区分两个条目。

**注意:**为了避免发票号码的重复输入，强烈建议根据`invoice number`字段创建另一个唯一索引。

结合上述两个独特的索引约束，我们避免了以下人为错误:

1.  发票号码中的打印错误导致发票号码重复；
2.  发票号中的打印错误导致表格中出现相同项目、客户、日期和数量的重复条目；

我们的设计无法消除所有人为错误。它属于业务流程设计领域，依靠支持硬件(例如，扫描仪扫描发票号码以避免手动输入)来提高准确性。

经验法则:

1.  在任何真实的应用程序中，永远不要依赖自动增量 PK 来确定记录的唯一性；
2.  不要依赖单一的人为字段(在本例中是发票号)来检查唯一性。
3.  复合唯一索引中的字段应该是实际存在的并由业务活动生成的字段。在上面的例子中，日期、项目(间接称为我们的`product`表的外键约束)、数量和客户(间接称为我们的`client`表的外键约束)都具有这些特征。

进一步注意上面的 3，这就是为什么我不喜欢用 UUID 作为 PK 或 UI。除了计算 UUID 的复杂性之外，UUID 本身没有记录的真实对应属性。

记住这些原则，我们的表结构设计将更加健壮。

### 自动递增主键存在的理由

说完这些并设置了两个唯一的索引后，我们可能还会使用一个自动递增的字段作为 PK。为什么？

答案很简单:方便数据定位，让它更简单更快捷。

在我们的例子中，为了定位单个记录，我们可以使用`select * from sales_entry where id=1`或者使用`select * from sales_entry where invoice='...'`或者使用`select * from sales_entry where itemid=... and clientid=... and date='...' and quantity=...`。显然，通过一个整数定位将是最快的执行和最容易写的。

此外，自动增量 PK 将有助于数据库中的其他表具有更简单的外键设置，以增强数据完整性。仍然建议设置一个自动递增字段作为主键，但强烈建议**而不是**依靠主键来确定记录的唯一性。

### 复合(唯一)索引中字段的顺序

数据库及其表的设计是一门艺术，尤其是当我们设计每个表的索引时。

完成上述设置后，我们的表中已经有 3 个索引:

1.  使用自动增量`id`字段的一个 PK。
2.  一个使用`invoice`字段的用户界面。
3.  一个用户界面使用几个领域的组合。

让我们再次看看创建第三个索引的 SQL:

```
ADD UNIQUE INDEX `uniqueentry` (`itemid` ASC, `clientid` ASC, `date` ASC, `quantity` ASC);
```

并考虑以下 SQL 语句及其相应的`EXPLAIN`输出摘录:

`select * from salesitem where clientid=1`

![](../Images/3b039255d8badea2de6f4c92123d9a45.png)

该表在 clientid 上还没有索引，所以上面的 SQL 将不能使用任何索引(`possible_keys = null`)来加速查询，并且必须进行全表扫描来获取记录(`Extra = Using Where`)。

`select * from salesitem where itemid=1 and clientid=1 and date='13-12-14'`

![](../Images/c1bd1a83ee05e2f0d6b75d7e52fb2970.png)

这个 SQL 的`where`语句包含几个过滤器，它们**是按照我们创建`uniqueentry`索引的严格顺序排列的**。它充分利用了我们的用户界面，我们可以期待它的最佳速度。

`select * from salesitem where itemid=1 and clientid=1 and quantity=1`

![](../Images/2e05e65d3e2e5cf79754cdd45628fcfe.png)

这个 SQL 的`where`语句包含几个过滤器，它们**并不按照我们创建`uniqueentry`索引的严格顺序**。MySQL 仍然努力使用用户界面，我们可以期待一个适中的速度。

`select * from salesitem where itemid=1 and date='13-12-14' and quantity=1 and clientid=1`

![](../Images/9ec64236a990198ad147b33fd147c211.png)

这很糟糕。UI 中的 4 个字段在 SQL 中，但是顺序完全颠倒了。它还会调用全表扫描来获取记录，最不幸的是，在我们搜索了全表之后，没有找到任何记录！

`EXPLAIN`是 MySQL 和 MariaDB 中非常有用的命令。要使用它，只需在 MySQL 终端或像 PhpMyAdmin 这样的 MySQL GUI 应用程序中发出`EXPLAIN *your sql statment to run*`。

> 设计复合索引时，要注意索引中字段的顺序。

我们的`uniqueentry`索引是由 4 个字段按照严格的顺序创建的:**项目、客户、日期、数量**。

在我们的 SQL 语句中，如果我们的`where`子句匹配复合索引字段顺序的全部或部分(如第二和第三个 SQL)顺序，MySQL 将足够智能地匹配复合索引中最长的字段链以加快搜索。否则，MySQL 将无法找到匹配的索引，必须进行全表扫描，这在任何数据库开发中都是不鼓励的。

如果我们的程序经常查询客户的购买历史(比如在我们的第一条 SQL 语句中)，我们的用户界面的字段顺序可能没有用。如果是这种情况，我们需要改变`uniqueentry` UI 中字段的顺序，或者创建一个新的(复合)索引，将`clientid`作为该索引中唯一的(或者第一个)字段。

过多的索引会降低数据库性能，因为数据库引擎在每次创建、更新和删除操作时，都必须做一些额外的工作来更新索引。在多用户、高频率写入的环境中，这可能会导致严重的性能问题。

因此，必须有一个平衡:更少的表/记录锁定时间、更快的查询/聚集时间、特定表的合理数量的索引。如何做到这一点没有固定的规则——一切都可以通过实验和非常详细地了解应用程序的用途和用法来完成。

### 结论

在本文中，我们进一步阐述了设计表及其索引的一些基本和关键概念。特别是，我们非常关注如何通过制定有意义的复合惟一索引来确定记录的惟一性。我们还解释了 MySQL 如何使用设计良好的复合索引来加速查询。

在以后的文章中，我们将关注数据库的另一个重要方面:存储过程及其在 PHP 中的使用。

敬请期待！

## 分享这篇文章