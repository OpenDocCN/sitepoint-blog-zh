# Java 中面向对象的概念——第 1 部分

> 原文：<https://www.sitepoint.com/oriented-concepts-java-1/>

扎实的 Java 基础可以让开发人员在更短的时间内做更多的事情，这是他/她现在使用其他任何一种编程语言都做不到的。使用 Java，您可以构建完整的应用程序，从加速的 3D 图形和其他多媒体功能到强大的加密和网络连接。在 Web 上，可以在客户端使用 Java 创建小程序(这些小程序曾经被过度宣传，但仍然有用，可以在 Web 页面内运行，并具有 Java 提供的全部功能)，在服务器端使用 Servlets 和 JavaServer Pages 创建动态 Web 页面，这在本系列的后面会看到更多。

为了充分利用 Java 语言，您需要很好地理解面向对象编程的概念。本文是两部分中的第一部分，它将教你关于 Java 面向对象编程的所有知识。系好安全带，开始疯狂之旅，因为这不仅是 Java 语言中最难理解的概念，也是最激动人心的概念！

本文是一系列文章中的第三篇，旨在向您传授 Java 语言，着眼于在服务器端使用 Java 技术开发动态网站，并且是上一篇文章 [Java 语言基础知识](http://www.webmasterbase.com/article.php/381)的继续。如果您还没有阅读本文之前的两篇文章，我建议您回去从头开始阅读，因为像编译和运行 Java 程序这样的主题以及诸如变量和控制结构这样的语言的基本特性都是假定的知识！

##### 但首先，一些行话

正如我以前说过的，用 Java 编写程序(或网页)就是要构建一个由相互关联的软件组件组成的网络，这些组件协同工作来完成工作。这些组件被称为 Java **对象**。

有许多不同种类的 Java 对象，事实上，用 Java 编程的很大一部分就是创建你自己类型的对象。要创建一种可以在 Java 程序中使用的新对象类型，您必须提供一个蓝图，Java 将使用它来创建这种类型的新对象。这个蓝图被称为 Java **类**。

让我们来看一个概念性的例子来帮助这些想法站稳脚跟。假设您的程序需要跟踪森林中的一组树木；具体来说，假设它需要记录这些树的高度。图 1 显示了一个 Java 程序员在这个程序中可能创建的类和对象的例子。

左边是一个名为 Tree 的类。这个类定义了一种 Java 对象——树——它将作为创建所有树对象的蓝图。类本身不是树；它仅仅是对一棵树是什么的描述，或者所有树的共同点。在这个例子中，我们的树类表明所有的树都有一个名为“height”的属性。

在右边，我们有两个实际的树对象。这些**是**树，它们是基于 Tree 类提供的蓝图创建的。这些对象被称为树类的**实例**，创建它们的过程被称为**实例化**。因此，我们可以说，通过两次实例化 Tree 类，我们已经创建了 Tree 类的两个实例，两个基于 Tree 类的对象，或者只是两棵树。请注意，在创建这些对象时，我们已经为它们的 height 属性赋值。第一棵树高 2 米，第二棵树高 5 米。尽管这些属性的值不同，但这不会改变两个对象都是树的事实。它们只是不同高度的树。

类不仅仅定义对象的属性；它们还定义了那些对象可以执行的**操作**。在 Java 等面向对象语言中，这样的操作被称为**方法**。继续我们的树示例，我们可以在树类中定义一个名为“grow”的方法。这样做的结果是，每个树对象都能够执行类中定义的增长操作。例如，对树执行增长操作可能会使树的高度属性增加一米。

##### 一棵爪哇树

对于我们对面向对象编程的第一次尝试，我建议用 Java 实现上面讨论的 Tree 类，然后编写一个程序，用它来实例化几棵树，并使它们稍微生长。

打开您选择的文本编辑器，创建一个名为`Tree.java`的新文本文件。这个文件将包含树类的定义，重要的是文件的名称要与其中定义的类的名称完全匹配(因此，`tree.java`就不行)。键入以下内容(通常，行号仅为您提供方便，不应作为代码的一部分键入):

```
1  /**  

2   * Tree.java  

3   * A simple Java class.  

4   */  

5  

6  class Tree {
```

我们首先宣布我们打算创建一个名为`Tree`的`class`。再次注意，我遵守了用大写字母拼写类名的惯例。

```
7    public int height = 0;  

8
```

[![Get Your Copy of Kevin Yanks Book NOW!](img/b0efd5d43fb184b59453aa181c0a55de.png)](https://www.sitepoint.com/books/?bookid=kevinyank) 除了这一行开头的单词`public`，这看起来就像一个标准的变量声明。看起来，我们声明了一个名为`height`的整数变量，并给它赋值为零。同样，变量名不大写是惯例。以这种方式在类定义中声明的变量(而不是在方法的定义中，比如 main，正如我们在前面的例子中看到的)成为了该类对象的**属性**。因此，这一行表示`Tree`类的每个对象都有一个名为`height`的属性，该属性包含一个整数值，height 属性的初始值为零。单词`public`表示 Java 程序中的任何代码都可以查看和修改该属性中的值。在本文的第二部分，我们将看到保护存储在对象属性中的数据的技术，但是现在这已经足够了。

这实际上就是创建一个树类来跟踪它的高度的全部内容；然而，为了让这个例子至少有点意思，我们还将实现我在上一节提到的`grow`方法。它从以下内容开始:

```
9     /**  

10     * Grows this tree by 1 meter  

11     */  

12    public void grow() {
```

让我一个字一个字地解释这一行。单词`public`表示`grow`方法(操作)是公开可用的，这意味着它可能被 Java 程序中任何地方的代码触发。方法也可能是`private`或`protected`，稍后我将解释这些选项的含义。单词`void`表示这个方法不会返回值。稍后，我们将看到如何创建产生一些值作为结果的方法，对于这样的方法，我们将用要产生的值的类型替换`void`(例如`int`)。

最后，单词`grow`是将要创建的方法的实际名称。注意，我注意到拼写方法名称的惯例是以小写字母开头。这个单词后面的空括号向 Java 表明这是我们正在声明的一个方法(而不是另一个属性，比如上面的`height`)。稍后我们会看到括号不为空的情况。最后，左括号表示每次触发树对象的`grow`方法时将执行的代码块的开始。

```
13      height = height + 1;
```

这个操作恰好是一个简单的操作。它获取`height`属性的值并加 1，将结果存储回`height`属性。注意，我们不需要在这个方法中将`height`声明为变量，因为它已经在上面的第 7 行被声明为对象的属性。如果我们在这个方法中将`height`声明为一个变量，Java 会将它视为一个单独的变量，每次运行该方法时都会重新创建一个变量，我们的类将不再像预期的那样运行(如果您好奇，请稍后尝试)。

```
14   }  

15 }
```

第 14 行的右括号标志着`grow`方法的结束，而第 15 行的右括号标志着`Tree`类的结束。输入所有这些内容后，保存文件，然后像编译 Java 程序一样编译它:

```
C:JavaTree> **javac Tree.java**
```

如您所料，在同一个目录中创建了一个名为`Tree.class`的文件。这是 Tree 类的编译定义。任何试图在其中创建树的 Java 程序都会寻找这个文件来包含要创建的对象的蓝图。事实上，那是我们的下一步。

##### 使用树类

好了，现在你有了一棵树的蓝图。有什么大不了的，对吧？当您在 Java 程序中使用该蓝图创建和操作树对象时，事情就变得有趣了。在文本编辑器中创建一个名为`PlantTrees.java`的新文件，并按照我的指导编写这样一个程序。

```
1  /**   

2   * PlantTrees.java   

3   * A simple Java program to try out the Tree class.   

4   */   

5   

6  class PlantTrees {
```

是的，没错——我们的程序本身就是一个 Java 类。当你运行一个 Java 程序时，你实际上只是给 Java 提供了一个类的名字，这个类包含一个叫做`main`的特殊方法，这个方法将被自动执行来启动你的程序。在本系列的后面，我们将看到一些利用 Java 程序实际上是类这一事实的方法，但是现在，让这作为一个提醒，Java 程序的每个部分都属于类和对象的网络，甚至是程序本身。

```
7    public static void main(String[] args) {
```

这是那个特殊的`main`方法的开始，它被自动执行来启动你的 Java 程序。如果仔细观察，您会发现这一行和 Tree 类中的`grow`方法的声明有些相似之处。这两个方法都是不返回任何内容的公共方法，方法名前出现的单词`public`和`void`就是证明。至于`static`的含义和括号内出现的代码，你还得再等一会儿才能找到这些谜团的答案。

```
8      System.out.println("Let's plant some trees!");
```

程序开始时打印出一条解释程序将做什么的信息。这对你来说应该不陌生。

```
9      // Create a new tree   

10     Tree tree1 = new Tree();
```

正如第 9 行的注释所示，第 10 行实现了凭空创建一个新树的壮举。这是一条非常重要的线。所以我来深入解释一下。该行以声明要创建的对象的类(类型)开始(在本例中为`Tree`)。然后我们给我们的新树起一个名字(在这个例子中，`tree1`)。这实际上等同于通过指定变量名称(如`int roomTemp`)后的数据类型来声明一个新变量。

这条线的其余部分才是真正神奇的地方。单词`new`是一个特殊的 Java 关键字，它触发新对象的**实例化**。在`new`之后是要实例化的类名，后面是一对括号(同样，在我们后面将看到的更复杂的情况下，这些括号可能不是空的)。
简而言之，这一行写道，“创建一个名为`tree1`的`Tree`类型的新变量，并给它赋值一个`new Tree`所以实际上这一行不仅仅是创建了一棵树，它还创建了一个新的变量来存储它。如果在这一点上这种区别对你来说有点模糊，不要担心；后面的例子将有助于明确这些概念。

现在我们已经创建了一棵树，让我们对它做些什么:

```
11     // Print out the tree's height   

12     System.out.println("I've created a tree with a height of " +   

13                        tree1.height + " meter(s).");
```

同样，这对你来说不应该太陌生。这一行只是像其他行一样打印出一行文本，除了这一行文本的一部分从`tree1`变量(`tree1.height`)的高度取值。如果你只是简单地输入了`height`而不是`tree1.height`，Java 会认为你指的要么是在这个方法中声明的一个名为`height`的变量，要么是`PlantTrees`类(程序本身)的一个属性。如果找不到这两者中的任何一个，当你试图编译程序时，Java 会打印出一条错误信息。为了告诉 Java 你在`tree1`中引用了树的`height`属性，你需要在`tree1`后面加上**点操作符** ( `.`)。

当你反向阅读表达式时，点运算符可能被认为有点像 Java 中“属于”的说法。因此，`tree1.height`应读作属于`tree1`的`height`因为树是以零高度创建的，所以第 12 行和第 13 行应该打印出“我已经创建了一棵高度为 0 米的树。”

调用(或触发)属于一个对象的方法是以类似的方式完成的:

```
14     tree1.grow();
```

这一行调用属于`tree1`中的树的 grow 方法，使其增长一米。同样，这组括号表示我们引用的是一个方法，而不是一个属性。所以在这条线之后，如果我们再次打印出`tree1`的高度…

```
15     System.out.println("After a bit of growth, it is now up to " +   

16                        tree1.height + " meter(s) tall.");
```

这一行将打印出“经过一点增长，现在高达 1 米。”

为了显示每棵树都有独立于其他树的高度值，我们将通过创建更多的树并让它们以不同的量增长来完善这个示例:

```
17     Tree tree2 = new Tree();   

18     Tree tree3 = new Tree();   

19     tree2.grow();   

20     tree3.grow();   

21     tree2.grow();   

22     tree3.grow();   

23     tree2.grow();   

24     System.out.println("Here are the final heights:");   

25     System.out.println(" tree1: " + tree1.height + "m");   

26     System.out.println(" tree2: " + tree2.height + "m");   

27     System.out.println(" tree3: " + tree3.height + "m");   

28   }   

29 }
```

保存并编译该程序:

```
C:JavaTree> **javac PlantTrees.java**
```

确保`PlantTrees.class`和`Tree.class`在同一个目录下，然后运行你的`PlantTrees`程序:

```
C:JavaTree> java PlantTrees   

Let's plant some trees!   

I've created a tree with a height of 0 meter(s).   

After a bit of growth, it is now up to 1 meter(s) tall.   

Here are the final heights:   

 tree1: 1m   

 tree2: 3m   

 tree3: 2m
```

##### 遗产

面向对象编程的优势之一是**继承**。这个特性允许你创建一个基于旧类的新类。假设您的程序还需要跟踪椰子树，那么您将需要一个名为`CoconutTree`的新类来跟踪每棵树上椰子的数量。您可以从头开始编写`CoconutTree`类，从负责跟踪树的高度并允许树增长的`Tree`类复制所有代码，但是对于更复杂的类，可能会涉及大量重复的代码。如果你后来决定让你的树有非整数的高度(比如 1.5 米)，会发生什么？您必须调整这两个类中的代码！

继承允许你定义你的`CoconutTree`类为`Tree`类的**子类**，这样它**继承**该类的属性和方法以及它自己的属性和方法。为了理解我的意思，下面是`CoconutTree`的代码:

```
1  /**    

2   * CoconutTree.java    

3   * A more complex kind of tree.    

4   */    

5    

6  class CoconutTree **extends Tree** {    

7    public int numNuts = 0; // Number of coconuts    

8    

9    public void growNut() {    

10     numNuts = numNuts + 1;    

11   }    

12    

13   public void pickNut() {    

14     numNuts = numNuts â€“ 1;    

15   }    

16 }
```

第 6 行的单词`extends Tree`赋予了`CoconutTree`类一个`height`属性和一个`grow`方法，以及为该类显式声明的`numNuts`属性和`growNut`和`pickNut`方法。

通过构建具有多层次继承的类的层次结构，您可以创建复杂对象的强大模型，而只需很少或不需要重复代码(这有助于减少输入和易于维护)。在本系列的后面，我们将看到更多关于继承力量的例子。

##### 复制对象

Java 处理整数和布尔值等基本数据的方式与 Java 处理对象的方式是有区别的。考虑以下代码片段:

```
1  int a = 5;     

2  int b = a;     

3  b = b + 1;     

4  System.out.println("a=" + a + " b=" + b);     

5       

6  Tree t1 = new Tree();     

7  t1.height = 5;     

8  Tree t2 = t1;     

9  t2.height = t2.height + 1;     

10 System.out.println("t1.height=" + t1.height +     

11                    " t2.height=" + t2.height);
```

现在，在这两种情况下，我们都创建了两个变量，将第一个变量的值赋给第二个变量，然后更改第二个变量的值；但是，上述代码的输出如下:

```
a=5 b=6

t1.height=6 t2.height=6
```

对于整数，更改第二个变量的值不会影响存储在第一个变量中的值。然而，在树的情况下，改变存储在`t2`中的树的高度似乎也改变了存储在`t1`中的树的高度！取决于你如何思考，这些结果中的一个或另一个可能看起来有意义，但无论哪种方式，在这两种情况下似乎都有非常不同的事情发生。

在第一种情况下，乍一看对大多数人来说是有意义的，当第 2 行的`b`中存储了`a`的值时，Java 实际上创建了一个整数值 5 的副本来存储在`b`中。所以实际上我们正在处理数字 5 的两个不同的副本:一个存储在`a`，另一个存储在`b`。

在物体的情况下，故事是非常不同的。在第 8 行，当`t1`的值存储在`t2`中时，我们**而不是**实际上创建了树对象的副本来存储在`t2`中！相反，`t2`被用来引用内存中树类的同一个实例。换句话说，`t2`和`t1`指向完全相同的树！这就是为什么改变`t2`的高度也会改变`t1`的高度——因为`t2`和`t1`不会像`a`和`b`那样分开。

那么，如果你想创建一个对象的实际副本，该怎么做呢？嗯，有几个选择。第一种方法是实际创建两棵树，然后将其中一棵树的高度复制到另一棵树的高度:

```
1  Tree t1 = new Tree();     

2  t1.height = 5;     

3  Tree t2 = new Tree();     

4  t2.height = t1.height;     

5  t2.height = t2.height + 1;     

6  System.out.println("t1.height=" + t1.height +     

7                    " t2.height=" + t2.height);
```

这将产生期望的输出“t1.height=5 t2.height=6”，因为树的高度实际上是基本数据值(整数)，而不是对象，所以将`t2`的高度值设置为等于`t1`的高度会创建一个单独的整数值副本供`t2`使用。

另一个选择是在类中实现一个特殊的方法来创建副本。此方法应该提供对象的直接副本以供单独使用。下面是添加了`copy`方法的树类的样子:

```
1  class Tree {     

2    public int height = 0;     

3    public void grow() {     

4      height = height + 1;     

5    }     

6    public Tree copy() {     

7      Tree copy = new Tree();     

8      copy.height = height;     

9      return copy;     

10   }     

11 }
```

这是你如何使用这种新方法:

```
1  Tree t1 = new Tree();     

2  t1.height = 5;     

3  Tree t2 = t1.copy(); // Create a copy of t1     

4  t2.height = t2.height + 1;     

5  System.out.println("t1.height=" + t1.height +     

6                    " t2.height=" + t2.height);
```

同样，这将产生预期的结果。

##### 比较对象

在本系列上一篇文章的结尾，我承诺这篇文章将有助于揭开字符串在 Java 中如何工作的神秘面纱。具体来说，我答应解释如何在 Java 程序中比较两个字符串是否相等。好吧，对于那些已经在你的电子邮件收件箱前等待了两周的人，我想说，“好好生活吧。”

严肃地说，比较相等性的方法是 Java 中基本数据值和对象之间的另一个重要区别。考虑下面的代码片段:

```
1  int a = 5;      

2  int b = 5;      

3  if (a == b) System.out.println("a and b are equal!");      

4        

5  Tree t1 = new Tree();      

6  t1.height = 5;      

7  Tree t2 = new Tree();      

8  t2.height = 5;      

9  if (t1 == t2) System.out.println("t1 and t2 are equal!");
```

同样，这段代码公开了基本数据值和对象的不同行为。虽然第 3 行的比较会发现`a`和`b`确实相等，但是第 9 行的两棵树`t1`和`t2`的高度相等的事实并不足以使`t1`和`t2`本身相等。事实上，对于包含对象的两个变量，使用上面的`==`操作符发现它们相等，这两个变量必须都指向完全相同的对象！例如，下面的代码会发现`t1`和`t2`相等:

```
1  Tree t1 = new Tree();      

2  t1.height = 5;      

3  Tree t2 = t1; // Both t1 and t2 refer to the same Tree      

4  if (t1 == t2) System.out.println("t1 and t2 are equal!");
```

这种形式的平等比较并不特别有用，不是吗？

由于 Java 使用一个名为`String`的内置类来表示文本字符串，所以当您试图比较两个字符串是否相等时，也会出现同样的问题。例如，您可能希望检查用户输入的值是否是正确的密码，以便访问程序的某些功能。以下是你可能想做的事情:

```
1  if (enteredPassword == "secret") {      

2    // Allow access      

3  } else {      

4    System.out.println("Access denied.");      

5  }
```

然而，问题是，即使变量`enteredPassword`包含字符串“secret ”,它也不会是与它比较的值相同的字符串类的**实例**,所以比较结果总是假的，访问总是被拒绝。

[![Get Your Copy of Kevin Yanks Book NOW!](img/b0efd5d43fb184b59453aa181c0a55de.png)](https://www.sitepoint.com/books/?bookid=kevinyank) 解决方法是使用 String 类提供的`equals`方法代替`==`运算符。此方法允许您将一个字符串与另一个字符串进行比较，以检查它们是否包含相同的文本。下面是如何在上面的例子中使用`equals`方法:

```
1  if ( enteredPassword.equals("secret") ) {      

2    // Allow access      

3  } else {      

4    System.out.println("Access denied.");      

5  }
```

`equals`方法与我们目前所见的其他方法不同，它接受一个参数。不是在方法名(`equals`)后面加上一对空括号，而是在括号之间键入参数(在`equals`的情况下，是用来比较是否相等的字符串)。equals 方法还会根据字符串是否相等产生一个布尔值(true 或 false)。不要太担心这些特殊功能的细节；在本文的第二部分，我们将会看到更多接受参数和返回值的方法的例子。

所有 Java 的内置类都支持检查相等性的`equals`方法，每个类的文档都解释了在什么情况下类的两个对象被认为是相等的。为了对您自己的类的对象的相等性进行比较，您应该在那些类中实现您自己的`equals`方法。在本文的第二部分，我将向您展示如何为`Tree`和`CoconutTree`类编写一个`equals`方法。

要查看字符串对象支持的所有方法的列表，请查看这个类的 [Java API 文档。在这个阶段，并不是所有的事情对你来说都是完全有意义的，但是很多事情会的。例如，查找`equalsIgnoreCase`方法，该方法在忽略大小写的情况下比较两个字符串是否相等。](http://java.sun.com/j2se/1.3/docs/api/java/lang/String.html)

##### 进一步阅读的摘要和资源

在本文中，我带您快速浏览了 Java 编程语言中突出的面向对象编程的主要概念。这些概念是这种语言区别于其他语言的要素，使得 Java 与其他语言相比，既是对掌握的挑战，也是在功能和便利性方面的一个令人耳目一新的进步。

在本文的第二部分，我们将探索类、对象、属性和方法的一些更高级的特性，甚至讨论一些好的类设计的原则。

同时，您可能想花一点时间探索 Java 提供的一些内置类。在线的 [Java 2 平台 API 规范](http://java.sun.com/j2se/1.3/docs/api/index.html)给出了完整的列表，以及每个类的所有属性和方法的描述。不要被众多的课程吓倒；连我都记不全了！

## 分享这篇文章