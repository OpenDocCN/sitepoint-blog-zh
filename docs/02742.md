# 单元介绍:Rails 的更好视图层

> 原文:[https://www . site point . com/introduction-to-cells-a-better-view-layer-for-rails/](https://www.sitepoint.com/introduction-to-cells-a-better-view-layer-for-rails/)

![](../Images/d2f843a2aa9f9b71d7218034b23a9bf7.png)

*“不！我又做到了！不要杀我！求你了。不要！”*普通的一天，在一家随机铁轨商店。一名开发人员 Scott 只想运行一个简单的数据库迁移。他不仅更新了数据库模式，还向该应用程序的现有用户发送了 50 万封“欢迎”电子邮件。

Scott 忘记了他的模型中由他的代码触发的`after_save`回调。斯科特羞愧地低下了头，抓起一杯水吞下了他的愤怒。

斯科特，这不仅仅是你的错。

越来越多的 Ruby on Rails 开发人员正努力按照 vanilla Rails 的方式实现复杂的 web 应用程序。他们正在寻找替代模式、技术或方法来控制不断增长的复杂性。

替代模式的一个例子是[开拓者项目](http://trailblazer.to)，这是一个位于现有 web 框架(如 Rails、Grape 或 Hanami)之上的层集合。

在这一系列的文章中，我想向您介绍这些可供选择的模式，它们在实际应用程序中的集成，以及帮助您处理每天在 Rails 中遇到的复杂架构问题的高级技术。

说到问题 Rails 和使用它的应用程序中有很多问题。

最大的一个问题显然是缺乏抽象层，这表现在反复出现的问题“我把这些代码放在哪里？”全世界像 Scott 这样的 Rails 开发者都在自问，一脸绝望，额头冷汗。

让我们把重点放在如何改进这个框架上。为什么不从视图层开始呢？

## Rails 的视图层:表现恐龙

Rails 声称非常简单，这允许简单地解释视图层。

控制器动作聚集数据用于呈现。数据通常被分配给实例变量，然后这些变量被推送到所谓的“模板”。

模板是用 Haml 或 ERB 等语言编写的文件。它们包含占位符，这些占位符被控制器的数据替换，从而将整个事情变成静态 HTML。

从控制器呈现模板被称为*视图*。为了提供一种方便的方法来重用视图中的某些片段，Rails 为您提供了*片段*，它们与视图完全一样，但只实现了页面的一小部分。然后可以在视图中渲染局部。

Rails 还允许将 Ruby 代码封装到名为“helpers”的方法中，这些方法可以在视图中使用，以减少视图中的逻辑。

这是因为你不应该在你的视图中有逻辑——这在 Rails 中处处被强调。“在你的视图中不要有复杂的代码！”将是男高音。有趣的是，在大多数 Rails 视图中，你会发现大量的代码块，让你难以理解一个视图实际上做了什么。

这是为什么呢？

## Rails Views == PHP 4

Rails 中的视图层深受 PHP 的启发。根据这位有魅力的发明家的说法，这是有意的，它带来了 PHP 所有的优点，同时去掉了不好的部分。

这是非常正确的。将 Rails 视图与 10 年前构建的 PHP 4 应用程序进行比较时，情况确实如此。

这就是 Rails 视图:零封装的 PHP 脚本，访问全局状态和全局函数，称为帮助器。那些曾经在过时的 PHP 4 应用程序中工作过的人将会看到这两个概念的相似性。

保持事情简单没有错。It *是*一个新开发人员立即理解的概念，并使他们能够实现动态网页。然而，当一个抽象开始泄漏，开发人员努力维护干净的、可预测的视图代码时，这难道不是引入更高层次概念的迹象吗？

## 查看救援模型！

除了 Rails 之外的每一个 web 框架，如 Django、Symfony 或 Phoenix，都带有某种形式的*视图模型*:一种抽象，其中一个单独的对象代表页面的一个片段——而不是依赖于全局的“PHP 脚本”。

为什么我们在 Rails 中没有这个？因为我们不需要！

但我刚才不是说了相反的话吗？

是的，我做到了。尽管如此，Rails core 还是让 Scott 这样的人觉得它的视图层绝对够用。Rails 5 中引入了一个全局`ApplicationController::render`方法，而不是集成一个更高的抽象，这是复兴 Rails 的侏罗纪视图层的孤注一掷的尝试。

很快，我们将有数百个不同的“装饰者”或“展示者”对象的实现在我们漂亮的 MVC 堆栈中浮动，或者更简单，直接从模型呈现视图！这是一个可怕的想法，完全违背了公约驱动的框架的目的。

在遥远的地平线上，风暴正在聚集，乌云开始遮住天空，你可以听到垂死的 ActionView T-Rex 的最后一声咆哮。

雨停后，一缕阳光照射在潮湿的地面上。Rails 的另一个视图层叫做[单元](https://github.com/apotonick/cells)。随着 Rails 1.2.3 的推出，它已经成熟了很多年。

Cells gem 即将为许多快乐的用户带来 100 万次下载。它实现了视图模型模式的一个有用变体，允许您将 HTML 片段映射到对象。

## 细胞的解剖学

那么什么是细胞呢？单元格是呈现视图片段的对象。*仅此而已*。

然而，刚接触细胞的人往往很难理解细胞的工作是什么。它应该呈现整个页面，还是只呈现视图中的某些组件，或者单元格是怎么回事？

答案就像 gem 的概念一样简单:细胞可以渲染你想要的任何东西。它们可以用来包含侧边栏、登录表单或整个页面。或者，以上所有，通过嵌套你的细胞！

许多开发团队使用单元格来呈现页面，在这些页面中，更多的单元格实现更小的组件。在与众多团队合作后，我经常听到人们说“啊，这有点像 Ruby 中的 React 组件！”。尽管 Cells 没有给你带来交互性，但这是一个很好的比较。

另一个好处是你可以在任何地方渲染单元格。大多数情况下，这将发生在控制器动作、视图或邮件中。细胞本身对外部世界一无所知，所有的依赖都必须交给细胞。其结果是一个非常健壮和可重用的组件，绝对不能与 Rails 5 的新全局渲染功能相提并论。

举个简单的例子，下面是如何使用单元格在 Rails 控制器视图中呈现一组注释:

*app/views/comments/index . html . haml*

```
%h1 All comments

%ul
- @comments.each do |c|
  %li
    = cell(:comment, c) 
```

具有讽刺意味的是，一个单元格可以使用一个助手来渲染，这个助手就是`cell`助手。通过循环注释集合并调用每个模型的单元格，我们编译了一个 HTML 注释列表。

因此，从视图中调用单元格可以归结为以下代码:

```
comment = Comment.new(body: "Fantastic!")

cell(:comment, comment) #=> "<div>... HTML" 
```

在内部，这个助手调用实际上只做一件事。

```
CommentCell.new(comment).call 
```

有意思。它将单元格类名固定为`CommentCell`，实例化一个对象，传入`comment`模型，并通过`call`方法调用单元格的渲染。单元格将返回一个 HTML 片段，我们就完成了。

## 细胞是物体

为了充分理解视图模型，我们需要尝试一下实现单元的类。这堂课是你，亲爱的 Scott，写细胞时要花一半时间的地方。

按照惯例，单元格被组织在一个新的`app/cells`目录中。

*app/cells/comment _ cell . Rb*

```
class CommentCell < Cell::ViewModel
  def show
    "Hello! I feel #{model.body}"
  end
end 
```

当通过`cell`助手调用单元格时，它的`call`方法将被调用，反过来，现在不要失去我，自动调用`show`方法。

按照惯例，`show`方法返回单元格的内容，或者单元格表示的片段。在上面的类片段中，这个方法所做的只是返回一个字符串。在字符串中，使用了一种神秘的`model`方法。这只是你之前在`cell`电话中传递的评论。

让我们把这两端连在一起。这是最上面的调用，同样，还有结果:

```
comment = Comment.new(body: "Fantastic!")

cell(:comment, comment)
#=> "Hello! I feel Fantastic!" 
```

这有意义吗？`cell`助手将实例化`CommentCell`，传入`comment`对象，并调用单元格的`show`方法。在单元格中，您传递的任何内容都可以通过`model`方法获得。`show`的返回值就是单元格的“样子”。

您可能会认为，对于一个简单的 Rails helper 函数所能完成的工作来说，这是一大堆代码，但是让我讨论一下与 partials 相比，cell 视图有多方便，以此来激起您的兴趣。

## 视图

除了返回普通字符串，您还可以使用带有占位符的视图模板，就像 Rails 所做的那样:

*app/cells/comment _ cell . Rb*

```
class CommentCell < Cell::ViewModel
  def show
    render # renders app/cells/comment/show.haml
  end
end 
```

使用`render`，将调用单元格渲染堆栈。请注意，这是一个完全独立的实现，不与 ActionView 共享任何逻辑。Cells 的渲染堆栈实际上大约有 50 行代码。与 ActionView 的 7000 行相比，这稍微解释了为什么细胞比传统的霸王龙快 10 倍。

你可能已经猜到了。当调用`render`时，单元格自己的视图`app/cells/comment/show.haml`被渲染。

假设我们使用 Haml 作为模板选择，下面是`show.haml`视图的样子。

```
# app/cells/comment/show.haml

%h1 Comment
= model.body
.author
  = link_to model.author.name, model.author 
```

这是一个普通的 Haml 模板，你已经写了很多次了。然而，虽然 Rails 视图驻留在一个全局目录中，但是这个单元视图位于其私有的`app/cell/comment`目录中。此外，单元格视图会删除多余的`.html`名称部分。cell 类总是专门呈现一种格式，因此没有必要在文件名中对其进行编码——这是许多 Cells 用户所欣赏的便利。

另一方面，Cells 支持哈默尔、斯利姆和 ERB。确保快速阅读[安装说明](https://github.com/apotonick/cells#installation)，如果你像我一样使用 Haml，永远不要忘记在你的 gem 文件中包含`cells-haml` gem。

回到视图文件。毫无疑问，您已经注意到，您可以使用像`link_to`这样的 Rails 助手。此外，您还可以访问单元格的`model`。然而，这个视图中没有实例变量。斯科特。你想念他们吗？你不需要！单元格提供了访问表示数据的实例方法。让我们多了解一些。

## 无逻辑视图

细胞的真正力量来自于“助手”的工作方式。上述视图可以简化如下:

*app/cells/comment/show . haml*

```
%h1 Comment
= body
.author
  = author_link 
```

这就是我们所说的干净的、无逻辑的视图。在谈论剩下的实现之前，让它沉淀几秒钟，欣赏简单、无逻辑的视图的美、美学甚至优雅。

几分钟过去了，斯科特仍然盯着视图模板。没有逻辑。没有笨拙的助手会认为视图膨胀。只是普通的模板。一想到 ActionView T-Rex 及其恐怖的外观，斯科特就被拉回了现实。

## 助手是实例方法

当我们调用`author_link`时，视图中会发生什么？在 Rails 中，这将调用一个——希望已经存在的——全局助手。具体在哪里，没人真正了解。让我们暂时忘记 Rails、helpers 和发臭的 T-Rexes。

在单元格视图中调用`author_link`时，该方法将直接在单元格实例上调用。看一看实现，就会明白了。

*app/cells/comment _ cell . Rb*

```
class CommentCell < Cell::ViewModel
  def show
    render # renders app/cells/comment/show.haml
  end

private
  def author_link
    link_to(model.author.name, model.author)
  end
end 
```

没错，Cells 中的“助手”是一个实例方法，绑定到一个特定的类，而不是一个全局的、跺脚的怪物。在该方法中，您可以使用任何想要的 Ruby，甚至是 Rails 助手。

但是这一次，你不会有名字冲突，你不会有可能连你自己都不想看到的全局变量的访问权，你也不用人为地封装你的“助手”！Ruby 和它的对象模型会帮你做到。更酷的是，你可以自由地使用 OOP 特性，比如继承，共享公共助手的模块，或者在单元格内的 [Draper gem](https://github.com/drapergem/draper) 中看到的装饰器。

说到装饰:Cells 还提供了一种快速生成对`model`对象的读者的方法。这是缩短代码的一种便捷方式。

*app/cells/comment _ cell . Rb*

```
class CommentCell < Cell::ViewModel
  property :body
  property :author
  # ..

private
  def author_link
    link_to(author.name, author)
  end 
```

使用`property`类方法只是生成一个`model`的快捷方式，允许你直接调用`body`，或者`author`。而且，因为它是同一个上下文，所以您可以在单元实例和视图中使用这些快捷方式。

## 包裹

你现在明白为什么恐龙必须死亡了。通过引入一个新的抽象层——单元，以及一个稍微扩展的文件结构，就有可能拥有完全独立的视图组件，这些组件可以毫无困难地被重用。

偶然重写助手函数或挖掘嵌套的部分调用的日子已经一去不复返了。Cells 用非常功能化的语义实现了相同的行为。状态和依赖关系必须从外部传递到视图模型中。

在同样的意义上，它使用面向对象的技术。视图中的调用方法或“助手”将被委托给 cell 实例，您必须提供一个实例方法来实现这个助手。

虽然您可能还在阅读并希望获得一些更高级的示例，但是 Scott 已经专注于他的代码库，用视图模型替换了 helpers 和 partials。

在下一集，我们将跳转到测试单元，嵌套和渲染集合。另一个开胃菜:我将讨论视图继承如何工作以及如何帮助节省代码。

不要等到那时，像 Scott 那样做，现在就去使用细胞，在你的视图层感受封装的力量！

## 分享这篇文章