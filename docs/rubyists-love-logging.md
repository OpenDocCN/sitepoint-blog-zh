# 所有的 ruby 爱好者都喜欢伐木

> 原文：<https://www.sitepoint.com/rubyists-love-logging/>

![3d illustration of a wood log](img/73c9856ba6a39d564474b9ebe1d16db2.png)

如果您是 Rails 老手，您可能会认为日志是理所当然的。然而，如果你是用 Ruby 编写应用程序的独角兽之一，而*不使用【Rails，那么你可能很少或根本没有记录日志。不使用后端数据库的应用程序或没有数据存储的本地命令行风格的应用程序实际上可能根本没有日志记录。这是个问题吗？你应该担心吗？*伐木到底是什么？**

## 什么是日志记录？

日志记录通常指的是应用程序将发生在应用程序中的各种活动写入文件(或数据库，或控制台)。所以，现在，我们有一个相当模糊的定义。

*   你到底应该记录什么？错误？交易？地位？
*   你的日志会被用来做什么？审计线索？错误跟踪？调试？
*   谁会查看这些日志？开发商？管理者？支持？

如果我现在还没有说清楚的话，日志是一个非常重业务流程的构造。虽然我不能告诉你*记录什么*，但是我可以向你展示一个简单的方法来添加日志到你的应用程序中，无论是脚本，命令行应用程序，Sinatra web 应用程序，还是其他什么！

## 类别:记录器

作为 Ruby 开发人员，我们很幸运有了 **Ruby 标准库**，它再次覆盖了我们。[日志类](//www.ruby-doc.org/stdlib-2.1.2/libdoc/logger/rdoc/Logger.html)拥有我们大部分日志记录所需的一切。您可以为每种类型的日志创建一个 logger 对象，或者为每个类创建一个 logger 对象，或者您可以想象的任何其他组合。对于初学者来说，对于大多数简单到中等的需求，我发现*一条规则*效果很好。

## 一根木头来统治他们

如何将此添加到您的应用程序中？

```
require 'logger'

class MyLog
  def self.log
    if @logger.nil?
      @logger = Logger.new STDOUT
      @logger.level = Logger::DEBUG
      @logger.datetime_format = '%Y-%m-%d %H:%M:%S '
    end
    @logger
  end
end
```

就是这样。您的整个应用程序现在可以用这样一行代码写入日志:

```
MyLog.log.info "Look, ma! I'm loggin'!"
```

由于它正在向`STDOUT`写入，您会在终端中看到:

```
I, [2014-08-13 15:18:50-0600 #65630]  INFO -- : Look, ma! I'm loggin'!
```

## 它是如何工作的

让我们来分解一下我们的代码实际在做什么。首先，有些事情我们没有做。

我们*没有*将一个 logger 对象直接实例化到我们的应用程序中并传递该对象，所有这些都是面向对象的方式。相反，我们用一个名为`log`的类方法创建了一个名为`MyLog`的小类。这个方法检查 logger 对象是否存在，如果不存在就创建它，并返回它。Ruby 开发人员一般不会写很多类方法，但这是一种创建全局可访问对象的聪明方法。

你可以创建一个全局变量:

```
$log = Logger.new STDOUT
$log.level = Logger::DEBUG
$log.datetime_format = '%Y-%m-%d %H:%M:%S%z '
```

但是，因为全局变量是可变的，所以它不如具有类方法的类稳定。

在仿初始化块中，我们实例化 Logger 对象，设置输出的位置，设置日志级别，并设置日期时间格式。

```
if @logger.nil?
  @logger = Logger.new STDOUT
  @logger.level = Logger::DEBUG
  @logger.datetime_format = '%Y-%m-%d %H:%M:%S%z '
end
```

日志条目被设置为转到`STDOUT`，但是您也可以像下面这样轻松地将它们定向到一个文件中:

```
@logger = Logger.new 'path/to/log/files/log.txt'
```

日志的级别一开始有点难以理解，但是它基本上控制了将哪些信息写入日志。当告诉记录器写时，可以指定消息的“级别”。这很有用，因为您可以将生产级别设置为`Logger::WARN`，这意味着将编写`WARN`、`FATAL`、`ERROR`和`UNKNOWN`。这样，代码中的调试行就不会弄乱生产日志。当你在开发中编写新功能或修复错误时，将级别调高到`Logger::Debug`，所有的调试和信息日志也开始显示。可用级别(按“最严重”到“最不严重”的顺序):

*   **未知**——我甚至不会。总是写入日志。
*   致命的错误和其他严重的不愉快。
*   **错误**–出现错误。应该有人来解决这个问题。
*   **警告**–可能发生了错误。也许应该有人来解决这个问题。
*   **信息**–如果你想知道…
*   **调试**——`puts`风格调试的更复杂版本。

每个级别都有相应的方法。例如，`@logger.fatal("App is dying!!")`将在`FATAL`级别写入消息。`Logger`类也有每个级别的查询方法(例如`fatal?`，允许您询问`@logger`当前是否支持该级别的日志记录。

这将由你来决定每个日志条目应该是什么级别，但一旦你开始向你的应用程序添加日志，致命错误、一般信息和调试数据之间的区别就非常明显了。

将在日志中显示的日期时间被设置为 ISO 8601 标准，我看不出有任何理由以任何其他方式这样做。这些日期时间是普遍可读、可搜索和可解析的。如果你必须改变它，但是要小心谨慎，并且要有充分的理由。

## 前进并记录

自从我开始玩日志程序以来，我用得最多的是`DEBUG`和`INFO`。

对于检查变量的内容，查看某个方法是否被调用过，观察循环的进程，或者你想在应用程序中关注的任何事情来说,`DEBUG`是非常棒的。与`puts`风格的调试不同，您可以只保留这些日志调用，降低日志记录器的级别，并且在日志或控制台中不再看到这些数据。想检查一个数组是否是你期望的大小？给你的日志记录器打个电话，在你的日志中看到这个:

```
D [2014-08-13 15:23:42-0600 #65631]  DEBUG -- : Array length: 42
```

我生命中的 42 个项目，宇宙，和一切的阵列…这似乎是正确的！

`INFO`非常适合简单的事务日志记录。数据库通常免费为您提供这种东西，但是脚本、命令行应用程序或没有数据存储的 web 应用程序可以从保留一般审计线索中受益。例如，您可以记录某项任务的完成情况:

```
I, [2014-08-13 15:25:21-0600 #65632]  INFO -- : David published an article.
```

后来，如果你想知道大卫什么时候发表了一篇文章，砰！在你的日志里。

## MyLog.log.info "正在总结"

你使用 Ruby Logger 吗？也许你有一个最喜欢的宝石来处理你所有的伐木需要？如果你已经经历过几次伐木区，有哪些实践和设计对你有效？在评论中记录你的信息！

## 分享这篇文章