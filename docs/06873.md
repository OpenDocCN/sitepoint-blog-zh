# MySQL 视图

> 原文:[https://www.sitepoint.com/mysql-views/](https://www.sitepoint.com/mysql-views/)

您刚刚为您的 awesome 应用程序编写了一个新特性，它在数据库中搜索以找到“x ”,您运行了一些测试来检查返回的结果是否正确。

不幸的是，您的测试失败了，因为它返回的结果比预期的多。起初这并不明显，因为你已经有一段时间没有使用这个应用程序了，但是最终你会意识到每个搜索都应该被一个布尔字段自动过滤掉。

您可能遇到过类似的情况，您或某人忘记根据字段 x 中的值进行筛选，现在可能会显示不正确的数据，从而损害业务。幸运的是，有一些测试可以捕捉到这一点。

让我们看一个例子。您有一个用户表，并且有充分的理由利用一个布尔字段来表示用户的状态，也许是为了确定它是否被禁用。您可以将“活动表”中的数据复制到“禁用表”中，但是您觉得实现这一点的复杂性和开销太高，因为还有其他用户相关的表。

考虑到上面的场景，我认为 *MySQL Views* 可以改进这个解决方案。观点是很简单的事情。它们根据定义的选择查询显示一个表。我们可以创建一个视图，只返回系统中已启用的用户，并防止将来的功能包括禁用的用户。

我将解释如何创建这个视图以及如何在您的应用程序中使用它。需要注意的是 MySQL 视图只在版本 5 中可用。

以下是视图将基于的基本用户表:

```
CREATE  TABLE `users` (

`user_id` INT UNSIGNED NOT NULL AUTO_INCREMENT ,

`first_name` VARCHAR(100) NULL ,

`last_name` VARCHAR(100) NULL ,

`username` VARCHAR(100) NULL ,

`dob` DATETIME NULL ,

`disabled` BIT NULL DEFAULT 0 ,

PRIMARY KEY (`user_id`) );
```

下面是将*为上面的用户表创建 MySQL 视图*的查询。

```
CREATE OR REPLACE ALGORITHM = MERGE VIEW `v_users_enabled`

(`firstName`, `lastName`, `username`, `dob`)

AS

SELECT `first_name`, `last_name`, `username`, `dob`

FROM `users`

WHERE `disabled` = 1;
```

## 它是如何工作的？

下面是用于创建视图的关键字的分类。

### 创建或替换

这将创建一个新视图，并且是必需的。如果您想确定视图已经创建，可以选择添加或替换，但是如果您知道视图已经存在，可以使用 ALTER 对现有视图进行更改。

### 算法=合并

这是一个可选语句，通过不定义或显式声明 ALGORITHM = UNDEFINED，MySQL 将在最适合 SELECT 语句的两个选项之间进行选择，即 MERGE 或 TEMPTABLE。MySQL 会尽可能选择 MERGE 而不是 TEMPTABLE，因为这样效率更高。我会在讨论完这些核心点后，再详细讨论算法。

### 视角

是必需的语句，用于给视图命名。关键是视图**不能与表**同名，因为它们共享相同的名称空间。

列列表部分是可选的，默认情况下使用 SELECT 语句中的列名。如果您选择定义列名，它们以逗号分隔，必须是唯一的，并且与 SELECT 中的列数相匹配。

### 如同

以及定义选择查询的位置。

查询视图与查询表是一样的。这里有一个简单的例子:

```
SELECT * FROM v_users_enabled
```

## 关于算法的更多信息

定义算法时，有三个选项可供选择:合并、可模板或未定义。

我们现在知道 UNDEFINED 让 MySQL 选择合适的选项，但是另外两个选项是什么意思呢？

**合并**是两个选项中最快的。视图列列表替换了 SELECT 语句中的内容，本质上比 **TEMPTABLE** 合并得更快，因为它生成了一个新的临时表，该表被查询并且没有**索引**。如果你试图在应该使用 TEMPTABLE 的时候使用 MERGE，MySQL 会警告你，并把它改为 TEMPTABLE。

什么时候会使用 **TEMPTABLE** 选项？如果使用任何聚合函数，DISTINCT、LIMIT、GROUP BY、HAVING、sub query 或文字值(即没有表)。

## 次要性能权衡

不幸的是，MySQL 视图会阻碍性能而不是提高性能。考虑您的观点并尽可能使用合并来最小化性能降低是很重要的。

如果您的性能预算能够更好地管理复杂性并创建有用的分离，在我看来，这是一个值得的权衡，因为您正在进行的查询带有某些可能需要应用于其他查询的 where 子句。这很好地包含在视图和数据库级别的用户可以查询这个返回给他们正确的结果，而不需要他们记住他们需要这些额外的 where 子句。

这种包容的缺点是有可能在现在隐藏的视图中编写复杂的查询。在这个视图上使用更多 where 子句的查询将使整个查询变得庞大，并且可能效率低下。需要判断视图选择查询在不影响性能的情况下有多复杂。

为了在使用视图时更好地优化性能，请使用合并算法，并在创建索引时首先在视图中的 WHERE 子句中添加字段。像往常一样，在为预期的查询创建索引时，将它们按正确的顺序放置是很重要的。您可以使用 EXPLAIN 来检查您的查询，并确保它的行为符合您的预期。

## 好处和坏处

使用视图的**好处**:

*   通过包含记住数据库中所有 SELECT 语句的查询需要筛选的特定字段的需要，提供了与应用程序的有用数据分离。
*   表会随着时间的推移而变化，您需要添加一些新的字段，以便在大多数选择查询中进行筛选。所有需要改变的是在修改表后带有新字段的 SELECT 语句。那么更新应用程序将会更容易，因为您可能只需要记住在几个地方进行更改。
*   它们可以使您的选择查询更具可读性。

使用视图的**缺点**:

*   当使用 TEMPTABLE 算法时，不使用索引。
*   他们可以隐藏一个复杂的查询，通过查询视图可以把它变成一个缓慢的查询。
*   使用 MERGE 算法会将 view SELECT 语句限制为只能进行基本查询。
*   你可以选择合并算法，但如果 MySQL 认为它应该使用 TEMPTABLE，那么它会改变它。
*   如果您的视图与表没有一对一的关系，那么它是不可更新的。
*   当您添加或更改表时，仍然需要更新应用程序中的 CUD 语句。
*   您**不能**将触发器与视图相关联。

## 值得注意的怪癖

如果您希望在视图 SELECT 语句中使用 ORDER BY，值得注意的是，当您使用不同的顺序查询视图时，这不能被覆盖。

如果您决定在视图中设置一个限制，然后在查询视图时使用另一个限制，则未定义应用哪个限制。

如果你对使视图可更新感兴趣，请访问 MySQL 网站。

## 结论

MySQL 视图是一个有用的工具，在特定的场景中提供了一个很好的解决方案。很明显，观点有其局限性，意识到这一点很重要。以正确的方式使用，您的下一个应用程序可以受益于对数据访问方式的灵活控制和控制。

## 分享这篇文章