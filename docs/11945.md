# YUI 3:更轻，更快，更容易使用

> 原文：<https://www.sitepoint.com/yui-3-whats-new/>

2008 年 8 月，[雅虎用户界面团队发布了 YUI 3 的第一个预览版，](http://yuiblog.com/blog/2008/08/13/yui3pr1/)完全重写了 YUI(其第一个测试版将于下周发布！).

你可能会问，他们为什么要重写一个已经有用且成熟的库呢？随着 YUI 2 号的成熟，它的建造方式也发生了变化。

因此，从一开始就出现的 YUI 部分的编码方式与后来添加的部分完全不同。结果是库包含了不一致——在内部机制和 API 中都是如此。因此，该团队决定将图书馆带回基础，从头开始重建。他们的计划是应用过去三年在 YUI 工作中获得的经验，建立一个更轻、更快、更容易使用的库。最后，为了使这个库尽可能的灵活，YUI 3 引入了一个全新的插件架构，允许你添加自己的功能到节点和部件中。稍后我们将看到一个这样的插件在运行。首先，让我们看看 YUI 3 有什么新功能。

##### 再见`YAHOO`，你好`YUI`

查看 YUI 3 代码示例时，您会注意到的第一点是它使用的新的全局对象名称。旧的`YAHOO`全局对象已被新的`YUI`全局对象替换。它被重新命名有几个原因:用户反馈表明一些公司不喜欢在他们的代码中使用雅虎的名字；但更重要的是，它允许旧版本的 YUI 与 YUI 3 共存，因为它们有不同的变量名。

除了被重命名的全局对象，它的使用基于与 2.x 完全不同的原则。首先，它不再是一个静态对象，而是一个函数，当执行时，它返回自身的一个实例。现在，`YUI`的每次执行都返回一个自包含的环境，在这个环境中，库的版本及其所有加载组件的版本可以运行，而不会干扰页面上 YUI 的任何其他实例。通过扩展，这也意味着通过实例化不同版本的`YUI`对象，多个版本的库可以共存于同一页面上。下面的例子说明了这一原则:

```
 YUI().use('dd-drop', 'anim', function(Y) { 

    // Y.DD is available 

    // Y.Anim is available 

}
```

这里，`YUI()`被执行，它返回库的一个实例，从这个实例中执行`use`方法。最少需要两个参数:库组件，然后是加载完成后要运行的回调。在上面的例子中，传递给`use`的前两个参数是将要加载的库组件的名称。最后一个参数是我们的回调函数，它接收一个对象(在本例中名为`Y`)——这是包含所有加载组件的库的一个实例。所以，就像上面例子中的注释一样，拖放组件可以在`Y.DD`找到，动画组件可以在`Y.Anim`找到。

##### 更干净、更简洁的编码风格

该团队关注的主要问题之一是确保所有 YUI 组件的内部机制和 API 的一致性。所以 YUI 3 现在有了一个新的等级体系来实现这一点。例如， [`Attribute`类](http://developer.yahoo.com/yui/3/api/Attribute.html)为继承它的类提供了`get`和`set`方法、初始配置支持和属性变更事件。还有一个继承自`Attribute`的 [`Base`类](http://developer.yahoo.com/yui/3/api/Base.html)，它提供了一些现成的面向对象的功能，比如所有继承它的类的初始化器和析构器方法。最后，他们构建了一个 [`Widget`类](http://developer.yahoo.com/yui/3/api/Widget.html)，它继承了`Base`并提供了小部件通常使用的通用功能，例如 render 方法——一种用于管理小部件渲染的通用模型-视图-控制器结构——以及对通用小部件属性的支持。它还提供插件注册和激活支持。

YUI 3 克服的另一个问题是，当你的脚本只需要为其中包含的一两个函数加载大量的库时。例如，在 YUI 2 中，你必须包括整个连接实用程序(重 38KB，缩小后为 12KB)来完成一些`XMLHttpRequest`调用。YUI 3 通过将功能分解成更小的子模块解决了这个问题。这样，就没有必要仅仅为了打`XMLHttpRequest`电话而关闭整个实用程序。在 YUI 3 中，你只需拉下 IO 实用程序的`io-base`模块，就可以打一个`XMLHttpRequest`电话，这个模块只有 19KB 重(缩小后为 4KB)。事实上，整个 IO 实用程序重 29KB(最小 7KB ),比它的前身功能更加丰富。例如，现在可以用`io-xdr`子模块进行跨域或 XDomainRequest 调用。

##### 选择和链接

YUI 2 引入了一个选择器引擎，但是在图书馆的生命中它做得有点晚。因此，整个库都是围绕老式的元素获取技术构建的。换句话说，每当需要引用时，要么传递元素的`id`要么传递元素本身，仅此而已。然而，在 YUI 3 中，选择器引擎被内置在库的核心。它渗透到它的每一部分，所以你可以在任何需要元素引用的地方传递 CSS 选择器字符串。除了构造函数，还包括设置事件处理程序和使用实用程序。下面是一个例子，它使第一个带有类`author`的元素可拖动:

`var dd = new Y.DD.Drag({
   node: '.author'
});`

每当 YUI 3 没有逻辑值返回时，它就试图使方法可链接。下面是一个实际例子:

```
Y.get('.author').setStyle('cursor', 'move');
```

这里，我们引用了类名为`author`的第一个元素，并在其上设置了一个光标样式。

##### 节点和事件外观

YUI 3 通过节点工具为 DOM 引入了一个新的抽象层。YUI 3 没有返回对 DOM 元素的引用，而是返回了`Node` s 和`NodeList` s，这大大简化了 DOM 交互。这是因为`Node`包含了你与他们互动所需的所有功能，而不是必须使用单独的功能。此外，由`Node`公开的方法会在需要的时候负责浏览器的规范化，因此使用它们的体验会尽可能的轻松。在 YUI 2 中，为了给元素添加一个类名，你必须写以下内容:

```
YAHOO.util.Dom.addClass("navProducts", "selected");
```

在 YUI 3 中，这变成了:

```
Y.get("#navProducts").addClass("selected");
```

事实上，如果节点已经存在，比如说在一个名为`navProducts`的变量中，那么您可以简单地这样做:

```
navProducts.addClass("selected");
```

YUI 3 简化了与 DOM 的交互，并且使用事件外观的思想规范了事件管理。每个事件侦听器都会收到一个负责所有浏览器规范化的事件外观。例如，在《新 YUI 协议》中，你需要以下代码来“防止违约”:

```
YAHOO.util.Event.on("navProducts", "click", YUI2callback(e) { 

  e = e || event; 

  YAHOO.util.Event.preventDefault(e); 

});
```

现在你需要做的就是:

```
navProducts.on("click", YUI3callback(e) { 

  e.preventDefault(); 

});
```

更重要的是，这种行为也扩展到了纯粹的自定义事件，因此即使这些事件也接收事件外观，允许它们阻止默认事件并停止传播。

接下来:让我们将这些新方法付诸实践。

##### 给我看看钱！

我已经创建了一个简单的示例页面来展示 YUI 3 是多么的简单和强大。为了节省本文的篇幅，我将避免向您展示所有的标记和代码，但是您可以在示例页面上查看完整的源代码。

我做的第一个任务是用动画工具、滑块小部件、菜单节点插件和拖放工具加载 YUI 的实例。YUI 从雅虎服务器上获取必要的文件和它们的依赖关系。然后，它向回调函数返回一个带有加载组件的 YUI 实例，回调函数在名为`Y`的变量中接收它:

```
YUI().use('anim', 'slider', 'node-menunav', 'dd-drag', function (Y) { ...
```

接下来，我创建了一个简单的动画来将页面内容反弹到视图中。为此，我实例化了一个新的动画对象。我向它传递一个对 id 为`main`的元素的引用，并告诉它将顶部值从它当前所在的位置(现在它在`-1000px`，如示例页面的标记中所指定的)动态显示到`0`。我还指定动画应该持续三秒钟，并且应该使用`elasticOut`缓动方法。一旦对象被实例化，就只需要用`run`方法运行它了:

```
 /*  

 * Bounce-in Anim  

 */  

var anim = new Y.Anim({  

  node: '#main',  

  to: {  

      top: 0  

  },  

  duration: 3,  

  easing: Y.Easing.elasticOut  

  });  

anim.run(); 
```

接下来，我设置了一个`Slider`对象，以便让用户调整页面的基本字体大小。YUI 的字体 CSS(包含在示例页面中)将页面的基本字体大小设置为 13 像素。这是通过在`body`元素上设置`font-size`值来实现的，所有其他字体大小都是从这个元素中计算出来的。为了改变整个页面的字体大小，这就是我们将要操作的。

我为`body`元素获取了一个节点引用，稍后将与 slider 一起使用。然后我创建了一个滑块部件。我将最小值设置为 13，最大值设置为 28，因为我希望字体大小保持在这些值之内。然后，我确保滑块的轨道大小为 100 像素宽。最后，我设置了滑块的缩略图(直接从雅虎托管的服务器上加载):

```
/*  

 * Font Size Slider  

 */  

  var body = Y.get('body');  

  var slider = new Y.Slider({  

    min: 13,  

    max: 28,  

    railSize: '100px',  

    thumbImage:  

    'http://yui.yahooapis.com/3.0.0pr2/build/  

    slider/assets/skins/sam/thumb-classic-x.png'  

    });
```

一旦滑块被实例化，渲染它就变得很简单了。我通过用我想要呈现的元素的类名调用 slider 的`render`方法来做到这一点。slider 小部件将在 DOM 中匹配该类名的第一个元素中呈现:

```
slider.render('.horiz_slider');
```

现在剩下要做的唯一任务是连接滑块，这样它就可以调整页面的字体大小。我通过挂钩到它的`after`事件来做到这一点。YUI 3 有标准的`on`和`after`事件，你可以把它们挂钩，使得这样的事件处理比以前的版本容易得多。现在，每当触发`valueChange`事件时，我们的`body`元素的`fontStyle`值就会改变:

```
slider.after('valueChange', function (e) {  

  body.setStyle('fontSize', e.newVal + 'px');  

});
```

我还设置了一个导航菜单。一旦页面的内容准备好了，我将 MenuNav 节点插件插入到`nav`节点中。然后，它会根据找到的标记自动设置一个导航菜单——就这么简单！代码如下:

```
/*  

 * MenuNav  

 */  

Y.on('contentready', function () {  

  this.plug(  

    Y.plugin.NodeMenuNav,  

      {mouseOutHideDelay: 1});  

}, '#nav');
```

最后，我通过简单地实例化一个新的拖放对象并向它传递一个对我的图片的类名的引用，使您的图片真正可拖动。一旦创建了对象，就可以拖动图像。作为一个额外的接触，当鼠标光标悬停在图像上时，我会改变鼠标光标，这样很明显图像是可拖动的:

```
/*  

 * Drag and Drop  

 */  

  var dd = new Y.DD.Drag({  

    node: '.author'  

  });  

  Y.get('.author').setStyle('cursor', 'move');  

});
```

##### 摘要

所以，如你所见，YUI 3 号和它的前代完全不同。随着新语法的出现，您将获得一个更快、更轻、更容易、更灵活的库——准备好承担您最雄心勃勃的 web 项目。

看到这是一个引子，我们几乎没有触及 YUI 3 可能的表面。更多阅读，请查看 [YUI 3.x 预览版第 2 页](http://developer.yahoo.com/yui/3/)、[萨特延·德赛关于 YUI 3](http://developer.yahoo.com/yui/theater/desai-yui3.html) 的介绍，以及 [YUI 3 论坛](http://yuilibrary.com/forum/viewforum.php?f=15)。

## 分享这篇文章