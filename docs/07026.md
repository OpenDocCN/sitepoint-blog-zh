# 是什么让 Ruby 滴答作响

> 原文:[https://www.sitepoint.com/what-makes-ruby-tick/](https://www.sitepoint.com/what-makes-ruby-tick/)

当我刚开始用电脑工作时，有一件事真的让我很惊讶。你可以打印出类似于 [Morris 蠕虫](http://en.wikipedia.org/wiki/Morris_worm)(一段恶意代码，造成了各种各样的破坏)的代码，它是完全无害的。

但是，当以“适当的方式”输入计算机时，它突然变成了完全不同的东西。

这如何与 ruby 一起工作？你的代码如何从“仅仅是文本”变成可以连接到 HTTP 服务器或启动一些 SQL 查询的东西？

## 我们在说什么红宝石？

令人震惊的是:实际上不止有一颗红宝石。

事实上，我们不知道有多少红宝石，真的。我们都知道只有一个，你知道，你可以从 apt-get 或 rvm 或其他什么地方获得。但是，实际上，它只是 Ruby 编程语言的实现之一。Ruby(这种语言)是一种规范，编译器/解释器就是为了实现这种规范而构建的。

Perl 社区为此提出了一个很好的约定。“perl”(大写的“P”)表示语言本身，其中“Perl”表示语言的实现。因此，说传递-f 标志给 perl 是可以的，但是说用“Perl”是没有任何意义的。

事实上，有 Ruby 编程语言的 Rubinius 实现，与标准实现相比，它提供了一些非常好的方面。

不管怎样，我们不知道到底有多少红宝石。也许有人正在某处的车库或花园棚子里制作新的红宝石。从今以后，每当我们谈论与 Ruby 的具体实现相关的东西时，我们总是必须指明我们在谈论的是什么实现。

## 虚拟机

主线 ruby 解释器的一个重要部分是虚拟机。

长话短说:虚拟机只是一种遵循一些预设命令的虚拟计算机。普通计算机有一种叫做“汇编语言”的东西，它们知道如何执行短命令(这些命令直接翻译成二进制代码，计算机可以愉快地处理)。

虚拟机是一种运行在计算机上的软件，它可以模拟这类事情，除了这样一个事实，即无论是谁编写了这个软件，都可以决定这台机器可以理解什么样的“简短命令”。这些简短的命令称为指令。

这些指令通常是不能从其他事物中派生出来的基本事物(有点像数学/几何中的公理)。例如，Java 虚拟机有单独的指令用于加法、内存存储和类型转换。一堆这些指令放在一起成为某种内聚性的东西(即虚拟机可以运行的东西)被称为**字节码**。

现在，这个虚拟机是如何与 Ruby 一起发挥作用的呢？当我们输入“ruby hello.rb”时，hello.rb 并没有立即运行，而是被转换成字节码。然后，这个字节码被解释，程序运行。

## 为什么这么间接？

我们为什么需要中间的整个虚拟机呢？为什么不能直接运行代码呢？

首先，用一个小的指令集比用整个 Ruby 更容易“推理”。因此，当字节码实际运行时，其中一些可以被优化。

其次，编写一个直接解释器会导致将 Ruby 代码“转换”成可以立即运行的东西的各种疯狂行为。

最后，字节码完全独立于操作系统和底层硬件。因此，只要你能够实现虚拟机，Ruby 就能够运行。

事实上，Java 虚拟机一直是编程语言发展的温床。JRuby、JPython、Clojure、Scala 和其他各种令人兴奋的语言都利用了 Java 虚拟机的可移植性，并构建了可以转化为 JVM 字节码的语言。

## Ruby 虚拟机

在考虑虚拟机时，Ruby 提供了一个非常有趣的案例，因为它最近发生了重大变化。

Matz 的 Ruby(或 MRI)现在使用一种叫做 YARV(另一种 Ruby VM)的东西作为它的底层虚拟机。

迁移到 YARV 发生在 1.9 版本中，因为旧的虚拟机有一些优化问题。通过交换底层虚拟机，Ruby 很快就失去了“太慢而不适合任何实际应用”的形象。

值得称赞的是，Ruby core 团队能够在一个发布周期内分离出虚拟机。这不仅说明了团队在这个问题上的工作，也说明了他们保持事物分离的能力。我仍然会回想起在 perl 代码库中度过的时光。

到目前为止，我们已经了解了这样一个事实，即 MRI 获取您的 ruby 代码，将其转换为 YARV 的字节码，然后 YARV 执行该字节码。

但是，这种到字节码的转换实际上是如何发生的呢？嗯，有两个部分。

## 标记器

编译器/解释器构造是计算机科学中非常有趣，但有时非常理论化的部分。我将努力保持理论(因此，严谨)的最低限度，以提供正在发生的事情的一个很好的概述。

MRI 会查看您的 Ruby 代码，并将其分类成块。这些组块被称为标记，完成这一任务的部分被称为“词法分析器”。在这个例子中考虑 Ruby 代码太复杂了，所以让我们试着把它和类似“计算器语言”的东西联系起来。这种语言中的一行可能如下所示(不带引号):

`(4 + 5)/2`

lexer 会把它变成:

`OPENPAREN NUMBER OPERATOR NUMBER CLOSEPAREN OPERATOR NUMBER`

对我们来说，这看起来没什么变化，但我们只是完全转移了问题领域。我们已经将输入(只是一串字符和符号)转化为某种东西，这使我们了解我们正在处理什么类型的输入。对于 lexer 来说，496 和 46 构成了一个数，给出了字符串的一般结构。

现在，我们该如何处理这些新获得的信息呢？

## 从语法上分析

解析器基本上接受从词法分析器获得的标记，并将它们转换成字节码。

让我们继续我们的计算器语言的例子。

解析器将认识到“数字运算符数字”是一种导致某些特定字节码(即加法或除法)的模式，并且它可以获取这些令牌并将它们翻译成在底层虚拟机上运行的字节码。

MRI 做了一些非常类似的事情(尽管复杂得多),它在标记中寻找特定的模式，然后将它们转换成字节码。

现在，Ruby 是一种大型语言，所以不可能这么简单。不幸的是，事实并非如此。在词法分析和语法分析的巨大穹顶之下和之间还有几个结构(例如 AST 树)。然而，总的想法相当简单——词法分析器找出标记，解析器查看这些标记中的模式以生成字节码。

## 结论

希望你已经享受了 Ruby 在神奇地输出结果之前是如何看待你的代码的快速、全面的观察。

编译器构造是一个令人敬畏的主题，是一个理论与实践相结合的主题(这是我觉得非常有趣的事情)——本指南应该给你一个非常粗略的东西是如何构建的概述。

感谢阅读！

## 分享这篇文章