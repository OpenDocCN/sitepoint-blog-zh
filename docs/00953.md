# 对密码学的深入研究

> 原文:[https://www.sitepoint.com/cryptography-deep-dive/](https://www.sitepoint.com/cryptography-deep-dive/)

*这篇对密码学的深入研究最初发表在 [Bruno 的 Bitfalls 网站](https://bitfalls.com/2017/11/16/cryptography-mortals-lets-explain-public-private-keys/)，经允许在此转载。*

**媒体充斥着关于[加密货币](https://bitfalls.com/2017/08/20/cryptocurrency/)的内容，每个人都在谈论[公钥](https://bitfalls.com/glossary/#public-key)和[私钥](https://bitfalls.com/glossary/#private-key)的重要性。您听说过加密，但是您知道它实际上是什么以及它是如何工作的吗？**

这篇文章将带你回到基础知识，解释[加密](https://bitfalls.com/2017/10/13/crypto-cryptocurrency-matter/)，描述不同的类型，并演示算法示例，所有这些都以新手友好的方式进行。如果你曾经想理解这一点，但它似乎太复杂了，你会喜欢这篇文章。

## 密码系统

简而言之，密码术就是将信息转换成这样一种格式，它只对接收者有意义，而对任何可能在中间得到它的人没有意义。

我们要解决的问题是什么？

假设有两个人想要交换加密的消息，不管他们使用的是什么通信渠道——信件、短信、电子邮件……他们首先必须就加密或解密消息时要应用的一组规则达成一致。这些规则是一个或多个*函数*的集合，这些函数必须有一个*计数器函数*。也就是说，如果一个给定的函数被用来加密一条消息，那么必须存在一个反函数来解密它。用数学术语来说，这样的函数是**双射的**。

消息的发送者将一个函数应用于一组信息，并获得该信息的加密版本，然后可以将其发送给接收者。接收者应用计数器函数从消息的加密版本中提取真实信息。如果中间的某个人截获了这个信息，但是他们没有解密这个信息的反函数，他们将无法阅读它。

### 爱丽丝和鲍勃

让我们借助一个微不足道的例子来说明这一点。假设鲍勃想给爱丽丝发送一条包含“我爱你”的短信，但不能冒险让别人看到。(拿起爱丽丝手机的人会看到这条信息。)为了成功地交换加密的消息，Alice 和 Bob 需要就加密/解密消息的方式达成一致。让我们假设这是协议:

> 消息中的每个字母将被替换为后者在英语字母表中的两位数索引号。“A”将是“01”，“B”将是“02”，以此类推。“00”表示空格字符。这是他们的加密/解密功能，它是双射的。

| 代码:符号 | 代码:符号 | 代码:符号 |
| --- | --- | --- |
| 00:空间 | 09:我 | 18: R |
| 01: A | 10: J | 19: S |
| 02: B | 11 点 | 20: T |
| 03: C | 12:1 | 21: U |
| :D | 13 点 | 22:五 |
| 05: E | 14: N | 23: W |
| 06:女 | 15: O | 24: X |
| 07: G | 16: P | 25: Y |
| 08: H | 17:问 | 26: Z |

因此，Bob 将发送消息:

```
09001215220500251521 
```

如果有人截获这条消息，对他们来说没有多大意义。他们的爱将是一个秘密。而爱丽丝就能轻松解密，脸红。

## 对称加密(使用私钥)

上面概述的方法被称为**对称私钥加密**。“对称”表示可以使用相同的密钥(秘密)对消息进行加密和解密。关键(秘密)实际上是我们描述的字母到数字到字母的替换函数。它看起来有点像这样:

![Symmetric encryption](../Images/f6542d956df0fe3940cb39000fda39aa.png)

乍一看，这样的系统似乎很完美。当然，需要更复杂的双射函数来使这种通信真正安全。只要 Alice 和 Bob 能够事先会面并安排一种加密/解密方法，这样的系统是完全安全的。但是，如果像今天的大多数情况一样，交流的人实际上并不在很近的地方，或者甚至不认识对方，那会怎么样呢？他们如何安全地交换密钥，而不冒密钥落入他人之手的风险呢？

这是这种共享密钥加密的最大缺点:必须有一个预先建立的安全通道来交换密钥。

### 一个可能的解决方案

很明显，除非安全通道已经存在，否则几乎不可能安全地交换私钥。如果通道已经存在，那么就没有必要再创建一个。

解决方案不是找到一种安全的交换密钥的方法，而是完全消除这种交换的需要。这可以通过在组合中添加另一个键来实现。其中一个仅用于加密，另一个用于解密。

每个人都可以获得加密密钥。事实上，它*必须*对每个人都可用，因为没有它就不可能加密信息并把它们发送给接收者。这个密钥被称为*公钥*。

另一个密钥仅用于解密，不应发送给任何人。只有加密信息的接收者拥有它，我们称之为*私钥*。

## 不对称加密(使用公钥)

![Asymmetric encryption](../Images/d52e2dcda20085b9567f98e04a75c2d6.png)

看上面的图片，我们可以看到不需要安全通道来交换密钥。不对称是因为不可能用同一个密钥加密和解密消息。每个动作都需要一个单独的。

如果鲍勃想给爱丽丝发送加密信息，他必须有她的公钥。这个公钥可以由 Alice 直接给他，或者她可以在她的网站上发布，任何想给她发送加密消息的人都可以找到它。当 Alice 收到用她的公钥加密的消息时，她使用私钥解密它，这使得消息再次可读。

如果 Alice 想要发送回复，她现在需要 Bob 的公钥。程序是一样的:她加密信息，发送出去，只有 Bob 可以用他的私钥解密。

值得注意的是，要使这种通信可行，密钥需要通过足够复杂的过程来生成，以抵消任何计算机在不合理的时间内猜测它们的能力。

### 它是如何工作的？

如果您不完全理解以下部分中的术语，不要担心。粗略地阅读它们；随后将通过一个例子对它们进行解释。

为了使仅用公钥解密消息或从公钥导出私钥变得不可能，使用了单向数学函数。一个单向函数是这样的:对于任何一个`x`都可以计算出`f(x)`，但反之则不行。例如，如果我们知道*和*是 950，我们就不能猜测我们对哪些数字求和得到它，因为可能的组合数量是无限的。

有很多算法可以计算这样的函数。我们将在下面演示一个这样的算法:它被称为 RSA 算法，基于 1977 年它的创造者(罗恩·里维斯特，阿迪·萨莫尔，伦纳德·阿德曼)名字的首字母。

1.  选择 2 个[主](https://en.wikipedia.org/wiki/Prime_number)数——只能被 1 或它们自己整除的数。例如:

    *   *p = 61*
    *   *q = 53*
2.  将它们相乘`n = p x q` :
    `n = 61 x 53 = 3233`

3.  计算最低公倍数`λ(n) (p-1) i (q-1)` :
    `nzv (p-1,q-1) = nzv (60,52) = 780`。这可以用这里给出的[算法来完成。](https://en.wikipedia.org/wiki/Least_common_multiple)

4.  在 1 和之前计算的倍数之间选择任意一个数，使得这个数与最初的两个数互为质数[或互质](https://en.wikipedia.org/wiki/Coprime_integers)。如果将两个数相除的唯一正数是 1，那么这两个数就是互质的。在这种情况下，那就是`e = 17`。

5.  计算`e(mod nzv)`的[模乘逆](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)。我们这样寻找`d`:

    *   `(d x e) mod nzv = 1`
    *   `(d x 17) mod 780 = 1`
    *   `d = 413`
6.  这些计算产生公钥和私钥集的所有必要组成部分。公钥是对`(n, e)`，私钥是`(n, d)`。因此，公钥是`(n = 3233, e = 17)`。公钥用于通过以下公式加密消息:

    *c(m)=m <sup>17</sup> mod 3233*

    私钥是`(n=3233, d=413)`。它被用来解密信息:

    *m(c)=c <sup>413</sup> mod 3233*

现在我们有了加密和解密函数，我们可以回到 Alice 和 Bob 的场景。由于这些函数只能处理数字，我们需要先把字母变成数字。ASCII 表——计算机在计算机系统上处理字母时使用的标准——可以派上用场。这里只关注大写字母。

| 代码:符号 | 代码:符号 | 代码:符号 |
| --- | --- | --- |
| 32:太空 | 73:我 | 82: R |
| 65: A | 74: J | 83: S |
| 66: B | 75: K | 84: T |
| 67: C | 76:1 | 85: U |
| 68: D | 77 分钟 | 86:五 |
| 69 岁:女 | 78: N | 87: W |
| 70 楼 | 79: O | 88: X |
| 71: G | 80: P | 89: Y |
| 72 小时 | 81:问 | 90: Z |

对于 Bob 消息中的每个 ASCII 码，我们需要计算`c(m)`。由于消息是“我爱你”，第一个字母的 ASCII 码是 73。`c(73)`是:

*c(m)= m<sup>17</sup>mod 3233*
T5】c(73)= 73<sup>17</sup>mod 3233
*c(73)= 4747758522670009868607496922953 mod 3233*
*c(73)= 1486【T14*

剩下的我们也算算。

空格:*c(32)= 32<sup>17</sup>mod 3233 = 1992*
L:*c(76)= 76<sup>17</sup>mod 3233 = 2726*T9】O:*c(79)= 79<sup>17</sup>mod 3233 = 1307*
V:*c(86)=。*

加密函数计算`mod 3233`(除以 3233 时的除法余数)，因此一个字母的加密结果不能超过 3232，这反过来意味着每个字母的加密版本的最大位数是 4。因此，我们*在*的左边用零填充每个数字:1486，1992，2726，1307，1906，0028，1992，0099，1307，2310。

完整的可发送消息是:

```
1486199227261307190600281992009913072310 
```

Alice 有她的私钥，可以用它来解密。她将使用之前定义的反函数 *m(c)=c <sup>413</sup> mod 3233* ，其中`c`是加密的消息。反函数显示`mod 3233`正在计算，每个字母最多可以是 3232，有四位数。因此，Alice 知道消息需要分成四组，每组的前导零没有意义:

```
1486 1992 2726 1307 1906 (00)28 1992 (00)99 1307 2310 
```

我们来解密 1486:

*m(c)= c<sup>413</sup>mod 3233*
T5】m(1486)= 1486<sup>413</sup>mod 3233
*m(1486)= 1，1060335282256977039647849058382 e+1310 mod 3233*

 *我们得到了数字 73，根据 ASCII 表，它与字母“I”匹配。通过遵循相同的过程，我们可以解密消息的其余部分:

*m(1992)= 1992<sup>【413】</sup>【mod 3233 = 32】*，ascii 32 = Raz mak
*【m(2726)= 2726<sup>【413】</sup>*【mod 3233 = 76】，ASCII 76 = L
ascii 86 = v
*【m(28)= 28<sup>【413】</sup>【mod 3233 = 69】*；ascii 69 = e
*【m(1992)= 1992*【mod 3233 = 32】；ascii 32 = Raz

我们来重新迭代一下为什么非对称加密比对称加密好。对于对称加密，只有一个密钥既用于解密又用于加密消息。如果参与者想要安全地通信，他们首先需要安全地交换密钥。如果他们离得很远，这就成了一个大问题。有了非对称加密，我们可以自由地给出一个公钥，人们可以用它来加密发给我们的信息。我们的私钥是保密的，仅用于解密我们收到的消息。不需要通过安全通道来交换密钥，这使得非对称加密比对称加密安全得多。

但是有可能从公钥计算出私钥吗？

![Image of a key](../Images/bb2325149d80c2efc152e94e534fe051.png)

### 猜测 RSA 私钥

让我们再看一次函数:

*   加密: *F(x)=x <sup>e</sup> mod (p x q)*
*   解密:*F<sup>-1</sup>(c)= c<sup>d</sup>mod(p x q)*

加密函数——即`(p x q, e)`对——代表一个公钥。如果我们知道这一对，并且我们想要计算私钥，我们需要找到数字`p`和`q`。这意味着我们需要因式分解`p` x `q`的乘积。如果我们假设数字`p`和`q`是 1024 位的数字，那么它们的乘积是 2048 位的数字——如果用十进制数表示，则是 617 位的数字。要分解如此大的数字，即使是当今最强大的超级计算机也需要大量的时间，这使得这个过程在数学上是不可能的。

从技术上来说，对数字进行因式分解并不是不可能的。有专门为此开发的特殊算法，目前最有效的是 [GNFS(通用数域筛)](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.2389&rep=rep1&type=pdf)。这对于超过 110 位数的数字的因式分解特别方便。下表列出了以 MIPS ( *百万条指令每秒*)表示的大数因式分解所需的时间。因此，一个 MIPS-year 是一个具有 1 MIPS 能力的计算机在一年中可执行的计算机操作的数量。这个数字是 3.1536 x 10 <sup>13</sup> 。

| 密钥长度 | MIPS-分解它需要的年数 |
| --- | --- |
| 512-bitni | Thirty |
| 768-bitni | 200.000.000 |
| 1024-bitni | 300.000.000.000 |
| 2048-bitni | 300.000.000.000.000.000.000 |

如果我们假设应用的算法乘以 1024 位数字，产生 2048 位的乘积，并且今天最强大的个人计算机 CPU 大约有 300，000 MIPS(T1)，这个数字会非常高。即使今天最强大的量子计算机拥有 1 亿兆次运算能力(这是一种罕见的情况，如果它们存在的话)，也需要 30 亿年才能分解一个 2048 位数。

### 梅森素数

鉴于大素数是 RSA 算法背后的主要思想，寻找大素数变得越来越重要。有一种叫做梅森素数的素数子类，它们看起来像这样:2 <sup>n</sup> -1。它们是以一位法国修道士的名字命名的，这位修道士首次(错误地)确认了其中的 11 种。最近，围绕寻找最大可能的梅森素数有一场大运动。(具体可以去 Mersenne.org 的[了解。)最后一个(第 49 个)也是迄今为止最大的梅森数发现于 2016 年 1 月 7 日。它是 2 <sup>74.207.281</sup> -1，有 22，338，618 位数。在 2013 年 1 月 1 日发现它之前的那个数字是 2 <sup>57.885.161</sup> -1，比第 49 个数字少了近 500 万位。](http://www.mersenne.org/)

关于质数还有一个有趣的事实:电子前沿基金会对大质数有奖励。他们的[网站](https://www.eff.org/awards/coop/rules/)列出了这些奖金，并显示发现 100 万位数素数的 5 万美元奖金和发现 1000 万位数素数的 10 万美元奖金已经发放，1 亿和 10 亿位数的 15 万美元和 25 万美元奖金仍未发放。有好的算法思路吗？也许你能找到那个号码！

## 不对称加密和比特币

那么，除了共享“加密”名称之外，所有这些与加密货币有什么关系呢？

虽然下文适用于几乎所有的加密货币，但让我们以最著名的一种——比特币——为例。比特币也使用公钥/私钥对。公钥——或者至少是它的一种形式——是你可以向其发送一些比特币的[地址](https://bitfalls.com/2017/08/31/what-cryptocurrency-wallet/)。就像加密信息需要公钥，这样别人才能给我们发送信息一样，比特币也需要公钥，这样别人才能给我们寄钱。另一方面，私钥让我们可以确认、批准和执行交易，通过交易，我们可以将一些比特币从我们的地址(帐户)发送到其他人的公钥(地址)。

想法是相似的，但比特币在计算私钥和公钥时有不同的方法。比特币的私钥是一个 256 位数。我们通常处理从一组 2 个 <sup>256 个</sup>数字中随机选取的一个大数字。这是 10 <sup>77</sup> 多一点的可能选择。这可能看起来不多，但是考虑到[估计](https://www.thoughtco.com/number-of-atoms-in-the-universe-603795)整个宇宙中有 10 <sup>80</sup> 个原子，这个数字的大小仍然可以让我们停下来思考。仅仅以每秒 10 亿的速度计算所有这些数字，就需要比宇宙年龄还长的时间。

所以我们有一个只有我们自己知道的私钥，在合理的时间内，它不能被任何人或任何计算机猜到。在比特币协议中，私钥用于使用 ECC 算法*椭圆曲线加密*计算公钥。该算法基于一条曲线，该曲线的函数在数学上可以表示为*y<sup>2</sup>= x<sup>3</sup>+ax+b*。结果是公钥。如果你感兴趣，这个 URL[和](https://www.cryptocompare.com/wallets/guides/what-is-elliptic-curve-cryptography/)[这个 URL](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) 详细解释了这个算法。

对于比特币，公钥不是汇款地址，但可以使用以下公式轻松计算出来:

```
address = RIPEMD160 (SHA256 (public key)) 
```

如果您感兴趣，此 URL 包含有关该过程的详细信息。

## 结论

记住编码和加密之间的区别很重要。编码是使发送的消息尽可能与原始消息相同以减少错误的过程。加密就是让除了预定收件人之外的任何人都无法阅读邮件。

有几种不同的加密方式，主要的有不对称加密和对称加密。我们在本文中讨论了前者，并解释了与对称加密相比，非对称加密引入了一个公钥和一个私钥，而不仅仅是在双方之间共享一个私钥，这使得安全地通过不安全的通道进行通信成为可能。

在加密货币中，非对称加密的优势变得显而易见，公钥用于接收资金、检查余额和交易，而私钥是实际签署消息和发送令牌的唯一方式。

## 分享这篇文章*