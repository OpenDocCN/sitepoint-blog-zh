# 用 Symfony 组件构建自己的 PHP 框架

> 原文:[https://www . site point . com/build-PHP-framework-symfony-components/](https://www.sitepoint.com/build-php-framework-symfony-components/)

你可能在你的 PHP 生涯中见过 Symfony 或者至少听说过它。您可能不知道的是，Symfony 的核心是由称为*组件*的独立库组成的，这些组件可以在任何 PHP 应用程序中重用。

例如，流行的 PHP 框架 [Laravel](http://laravel.com/) 是使用几个 Symfony 组件开发的，我们也将在本教程中使用。流行的 CMS Drupal 的下一个版本也是建立在一些主要的 Symfony 组件之上的。

我们将看到如何使用这些组件构建一个最小的 PHP 框架，以及它们如何交互来创建任何 web 应用程序的基本结构。

![](../Images/c1844c71d48ed8097ed417b511490e6b.png)

**注意:**本教程不会涵盖*每一个* Symfony 组件和*每一个的每一个*特性。我们将只看到构建最小功能框架所需的主要内容。如果你想更深入地了解 Symfony 组件，我鼓励你阅读他们优秀的[文档](http://symfony.com/doc/current/components/index.html)。

## 创建项目

我们将从项目目录根目录下的一个简单的`index.php`文件开始，并使用 [Composer](https://getcomposer.org/doc/00-intro.md) 来安装依赖项。

目前，我们的文件将只包含这段简单的代码:

```
switch($_SERVER['PATH_INFO']) {
        case '/':
            echo 'This is the home page';
            break;
        case '/about':
            echo 'This is the about page';
            break;   
        default:
            echo 'Not found!';
    }
```

这段代码只是将请求的 URL(包含在`$_SERVER['PATH_INFO']`中)映射到右边的`echo`指令。这是一个非常非常原始的路由器。

## HttpFoundation 组件

[HttpFoundation](http://symfony.com/doc/current/components/http_foundation/introduction.html) 作为处理 HTTP 流的顶层。它最重要的入口点是两个类`Request`和`Response`。

`Request`允许我们处理 HTTP 请求信息，如请求的 URI 或客户端头，抽象默认的 PHP 全局变量(`$_GET`、`$_POST`等)。).`Response`用于将响应 HTTP 头和数据发送回客户端，而不是像在“经典”PHP 中那样使用`header`或`echo`。

使用 composer 安装它:

```
php composer.phar require symfony/http-foundation 2.5.*
```

这将把库放到`vendor`目录中。现在将以下内容放入 index.php 文件:

```
// Initializes the autoloader generated by composer
    $loader = require 'vendor/autoload.php';
    $loader->register();

    use Symfony\Component\HttpFoundation\Request;

    $request = Request::createFromGlobals();

    switch($request->getPathInfo()) {
        case '/':
            echo 'This is the home page';
            break;
        case '/about':
            echo 'This is the about page';
            break;   
        default:
            echo 'Not found!';
    }
```

我们在这里做的很简单:

*   使用`createFromGlobals`静态方法创建一个`Request`实例。该方法使用当前请求信息填充一个`Request`对象，而不是创建一个空对象。
*   测试由`getPathInfo`方法返回的值。

我们还可以替换不同的`echo`命令，使用一个`Response`实例来保存我们的内容，并将其`send`到客户端(客户端主要输出响应头和内容)。

```
$loader = require 'vendor/autoload.php';
    $loader->register();

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();
    $response = new Response();

    switch ($request->getPathInfo()) {
    case '/':
    	$response->setContent('This is the website home');
    	break;

    	case '/about':
    		$response->setContent('This is the about page');
    		break;

    	default:
    		$response->setContent('Not found !');
    	$response->setStatusCode(Response::HTTP_NOT_FOUND);
    }

    $response->send();
```

## 使用 HttpKernel 包装框架核心

```
php composer.phar require symfony/http-kernel 2.5.*
```

现在，尽管很简单，框架逻辑仍然位于我们的前端控制器中，即*index.php*文件。如果我们想添加更多的代码，最好将其包装到另一个类中，这将成为我们框架的“核心”。

[HttpKernel](http://symfony.com/doc/current/components/http_kernel/index.html) 组件就是为了这个目标而设计的。它旨在与 HttpFoundation 一起将请求实例转换为响应实例，并为我们实现这一点提供了几个类。目前，我们将使用的唯一一个接口是`HttpKernelInterface`接口。这个接口只定义了一个方法:`handle`。

这个方法将一个`Request`实例作为参数，并且应该返回一个`Response`。因此，实现这个接口的每个类都能够处理一个`Request`并返回适当的`Response`对象。

让我们创建实现`HttpKernelInterface`的框架的类`Core`。现在在`lib/Framework`目录下创建`Core.php`文件:

```
<?php

    namespace Framework;

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\HttpKernelInterface;

    class Core implements HttpKernelInterface
    {
    	public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    	{
    		switch ($request->getPathInfo()) {
    			case '/':
    				$response = new Response('This is the website home');
    				break;

    			case '/about':
    				$response = new Response('This is the about page');
    				break;

    			default:
    				$response = new Response('Not found !', Response::HTTP_NOT_FOUND);
    		}

    		return $response;
    	}
    }
```

**注意:**`handle`方法还有两个可选参数:请求类型和一个布尔值，该值指示内核是否应该在出错时抛出异常。在本教程中我们不会用到它们，但是我们需要实现与`HttpKernelInterface`定义的方法完全相同的方法，否则 PHP 会抛出一个错误。

我们在这里做的唯一一件事是将现有的代码移到`handle`方法中。现在我们可以去掉`index.php`中的这段代码，使用我们新创建的类来代替:

```
require 'lib/Framework/Core.php';

    $request = Request::createFromGlobals();

    // Our framework is now handling itself the request
    $app = new Framework\Core();

    $response = $app->handle($request);
    $response->send();
```

## 更好的路由系统

我们的类仍然有一个问题:它保存了我们的应用程序的路由逻辑。如果我们想要添加更多的 URL 来匹配，我们将不得不修改框架内部的代码——这显然不是一个好主意。此外，这将意味着为每条新路线添加一个`case`块。不，我们绝对不想走那条肮脏的路。

解决方案是在我们的框架中添加一个路由系统。我们可以通过创建一个`map`方法来实现这一点，该方法将一个 URI 绑定到一个 PHP 回调函数，如果匹配了正确的 URI，该函数将被执行:

```
class Core implements HttpKernelInterface
	{
		protected $routes = array();

		public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
		{
			$path = $request->getPathInfo();

			// Does this URL match a route?
			if (array_key_exists($path, $this->routes)) {
			    // execute the callback
				$controller = $routes[$path];
				$response = $controller();
			} else {
			    // no route matched, this is a not found.
				$response = new Response('Not found!', Response::HTTP_NOT_FOUND);
			}

			return $response;
		}

		// Associates an URL with a callback function
		public function map($path, $controller) {
			$this->routes[$path] = $controller;
		}
	}
```

现在可以在前端控制器中直接设置应用程序路由:

```
$app->map('/', function () {
		return new Response('This is the home page');
	});

	$app->map('/about', function () {
		return new Response('This is the about page');
	});

	$response = $app->handle($request);
```

这个微小的路由系统运行良好，但它有重大缺陷:如果我们想匹配包含参数的动态 URL 呢？我们可以想象一个类似于`posts/:id`的 URL，其中`:id`是一个可变参数，可以映射到数据库中的帖子 ID。

我们需要一个更加灵活和强大的系统:这就是为什么我们将使用 Symfony [Routing](http://symfony.com/doc/current/book/routing.html) 组件。

```
php composer.phar require symfony/routing 2.5.*
```

使用路由组件允许我们将`Route`对象加载到`UrlMatcher`中，后者将把请求的 URI 映射到匹配的路由。这个`Route`对象可以包含任何可以帮助我们执行应用程序正确部分的属性。在我们的例子中，如果路由匹配，这样的对象将包含要执行的 PHP 回调。此外，URL 中包含的任何动态参数都将出现在路径属性中。

为了实现这一点，我们需要进行以下更改:

*   用一个`RouteCollection`实例替换`routes`数组来保存我们的路线。
*   更改`map`方法，让它在这个集合中注册一个`Route`实例。
*   创建一个`UrlMatcher`实例，通过使用一个`RequestContext`实例向它提供一个上下文，告诉它如何根据请求的 URI 匹配它的路由。

```
use Symfony\Component\Routing\Matcher\UrlMatcher;
		use Symfony\Component\Routing\RequestContext;
		use Symfony\Component\Routing\RouteCollection;
		use Symfony\Component\Routing\Route;
		use
		Symfony\Component\Routing\Exception\ResourceNotFoundException;

		class Core implements HttpKernelInterface
		{
			/** @var RouteCollection */
			protected $routes;

			public function __construct()
			{
				$this->routes = new RouteCollection();
			}

			public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
			{
			    // create a context using the current request
				$context = new RequestContext();
				$context->fromRequest($request);

				$matcher = new UrlMatcher($this->routes, $context);

				try {
					$attributes = $matcher->match($request->getPathInfo());
					$controller = $attributes['controller'];
					$response = $controller();
				} catch (ResourceNotFoundException $e) {
					$response = new Response('Not found!', Response::HTTP_NOT_FOUND);
				}

				return $response;
			}

			public function map($path, $controller) {
				$this->routes->add($path, new Route(
					$path,
					array('controller' => $controller)
				));
			}
		}
```

`match`方法尝试将 URL 与已知的路由模式进行匹配，如果成功，则返回相应的路由属性。否则它抛出一个我们可以捕捉的`ResourceNotFoundException`来显示一个 404 页面。

我们现在可以利用路由组件来检索任何 URL 参数。去掉`controller`属性后，我们可以通过传递其他参数作为实参来调用回调函数(使用`call_user_func_array`函数):

```
try {
			$attributes = $matcher->match($request->getPathInfo());
			$controller = $attributes['controller'];
			unset($attributes['controller']);
			$response = call_user_func_array($controller, $attributes);
		} catch (ResourceNotFoundException $e) {
			$response = new Response('Not found!', Response::HTTP_NOT_FOUND);
		}

		return $response;
	}
```

我们现在可以像这样轻松地处理动态 URL:

```
$app->map('/hello/{name}', function ($name) {
		return new Response('Hello '.$name);
	});
```

注意，这与 Symfony 全栈框架正在做的事情非常相似:我们将 URL 参数注入到正确的控制器中。

## 钩住框架

Symfony 框架还提供了各种方法来挂钩到请求生命周期中，并对其进行更改。一个很好的例子是安全层拦截试图在防火墙之间加载 URL 的请求。

所有这些都要感谢 [EventDispatcher](http://symfony.com/doc/current/components/event_dispatcher/introduction.html) 组件，它允许应用程序的不同组件实现[观察者](http://en.wikipedia.org/wiki/Observer_pattern)模式进行通信。

```
php composer.phar require symfony/event-dispatcher 2.5
```

它的核心是 EventDispatcher 类，该类注册特定事件的侦听器。当调度程序被通知一个事件时，这个事件的所有已知侦听器都会被调用。侦听器可以是任何有效的 PHP 可调用函数或方法。

我们可以在我们的框架中实现这一点，方法是添加一个包含一个`EventDispatcher`实例的属性`dispatcher`，以及一个`on`方法，将一个事件绑定到一个 PHP 回调。我们将使用 dispatcher 来注册回调，并在稍后的框架中触发事件。

```
use Symfony\Component\Routing\Matcher\UrlMatcher;
		use Symfony\Component\Routing\RequestContext;
		use Symfony\Component\Routing\RouteCollection;
		use Symfony\Component\Routing\Route;
		use Symfony\Component\Routing\Exception\ResourceNotFoundException;
		use Symfony\Component\EventDispatcher\EventDispatcher

		class Core implements HttpKernelInterface
		{
			/** @var RouteCollection */
			protected $routes;

			public function __construct()
			{
				$this->routes = new RouteCollection();
				$this->dispatcher = new EventDispatcher();
			}

			// ... 

			public function on($event, $callback)
			{
				$this->dispatcher->addListener($event, $callback);
			}
		}
```

我们现在能够注册监听器，这只是简单的 PHP 回调。现在让我们编写一个`fire`方法，它将告诉我们的调度程序在某个事件发生时通知他所知道的所有监听器。

```
public function fire($event)
    {
	    return $this->dispatcher->dispatch($event);
	}
```

多亏了 EventDispatcher 组件，在不到十行代码中，我们就向框架添加了一个很好的事件监听器系统。

`dispatch`方法还接受第二个参数，这是调度的事件对象。每个事件都继承自通用的`Event`类，并用于保存与其相关的任何信息。

让我们写一个`RequestEvent`类，当一个请求被框架处理时，它将被立即触发。当然，这个事件必须能够访问当前请求，使用一个属性保存一个`Request`实例。

```
namespace Framework\Event;

	use Symfony\Component\HttpFoundation\Request;
	use Symfony\Component\EventDispatcher\Event;

	class RequestEvent extends Event
	{
		protected $request;

		public function setRequest(Request $request)
		{
			$this->request = $request;
		}

		public function getRequest()
		{
			return $this->request;
		}
	}
```

我们现在可以更新`handle`方法中的代码，以便在每次收到请求时向调度程序触发一个`RequestEvent`事件。

```
public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
			{
				$event = new RequestEvent();
				$event->setRequest($request);

				$this->dispatcher->dispatch('request', $event);
				// ...
			}
```

这样，所有被调用的监听器都将能够访问`RequestEvent`对象以及当前的`Request`。目前，我们没有编写这样的侦听器，但是我们可以很容易地想象出一个在其他事情发生之前检查所请求的 URL 是否限制访问的侦听器。

```
$app->on('request', function (RequestEvent $event) {
		// let's assume a proper check here
		if ('admin' == $event->getRequest()->getPathInfo()) {
			echo 'Access Denied!';
			exit;
		}
	});
```

这是一个非常基本的安全系统，但你可以想象实现你想要的任何东西，因为我们现在有能力在任何时候挂钩到框架中，这使它更具可扩展性。

## 结论

通过阅读本教程，您已经看到 Symfony 组件是很好的独立库。此外，它们可以相互作用来构建一个符合您需求的框架。还有很多非常有趣的组件，比如 [DependencyInjection](http://symfony.com/doc/current/components/dependency_injection/introduction.html) 组件或者 [Security](http://symfony.com/doc/current/components/security/introduction.html) 组件。

当然，Symfony 本身或 Laravel 等全栈框架已经将这些组件推向了极限，从而创建了我们今天所知的强大工具。

## 分享这篇文章