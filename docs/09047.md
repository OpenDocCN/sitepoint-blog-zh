# 制作红宝石:切割宝石的最佳实践

> 原文:[https://www . site point . com/crafting-rubies-best-practices-while-cutting-gems/](https://www.sitepoint.com/crafting-rubies-best-practices-while-cutting-gems/)

对一些人来说，切割宝石被认为是矿物爱好者的艺术。然而，在红宝石领域，宝石切割是一件生死攸关的事情。创建 RubyGems 可能很容易，但对新手来说也是一个陷阱。通过遵循一些通用的社区最佳实践，您可以创造出能够在 Ruby 生态系统中和谐共存的宝石，并且在未来的几年中能够被消费者和贡献者所享用。

## 利用 gem 创作工具

除了有经验的裁剪者，或者那些想要或需要完全控制每一行代码的人，有一些 gem 创作工具可以在第一次发布 gem 时自动完成所需的大部分手工工作，并避免业余错误。

目前最大的 gem 创作工具是 Jeweler ( [RubyGems](http://rubygems.org/gems/jeweler) ， [GitHub](https://github.com/technicalpickles/jeweler) )，它旨在提供一套基于向导的 gem 自动化工具。它有任务来管理发布，版本，依赖，可执行文件和 Rake 任务都是现成的；从长远来看，它可以为频繁或初学者的宝石出版商节省时间。

## 负责任地使用加载路径和`require`

在 Ruby 中很容易破坏加载路径或可怕地使用`require`,而没有意识到这样做的危害。[Josh Peek 在 Ruby on Rails 博客上的一篇精彩文章详细介绍了加载路径的来龙去脉以及需求](http://weblog.rubyonrails.org/2009/9/1/gem-packaging-best-practices)，非常值得一读。他的文章中一些比较重要的观点是:

*   RubyGems(和大多数其他包管理器)将您的 gem 的`lib/`目录添加到加载路径中；在某些情况下，这是预先考虑到加载路径。如果你的`lib/`目录包含任何与核心 Ruby 文件同名的文件(例如`string.rb`，你的 gems 文件将优先。因此，遵循惯例，将你的所有文件保存在一个与你的宝石同名的目录下，在你的`lib/`文件夹中，例如`lib/gem_name/something.rb`。
*   大多数包管理器和测试框架会自动将你的`lib/`和测试文件夹(`spec/`和`features/`就是两个例子)添加到加载路径中。如果提供一个可执行文件，或者一个`Rakefile`，可以将`lib/`目录添加到那里的路径中(`$:.unshift(path_to_lib)`)。因此，在 any requires 中使用类似于`File.dirname(__FILE__)`的东西来删除代码，因为您可以放心地假设您总是可以相对于您的`lib/`目录使用 require。
*   不要依赖你的项目的`lib/`文件夹之外的任何东西(其他 gem 除外)；一些包管理器只复制你的`lib/`目录。

```
├── test_gem.gemspec
├── Gemfile
├── Rakefile
├── README
├── bin
│   └── test_gem
├── lib
│   ├── test_gem
│   │   └── some_module_or_class.rb
│   └── test_gem.rb
└── spec/features/test
    └── *
```

## 不需要在你的宝石里放宝石

当你在你的 gem 中包含`require 'rubygems'`时，你就剥夺了用户使用 RubyGems 以外的包管理器的选择。RubyGems 有许多功能强大、功能全面的替代品，包括 Rip ( [RubyGems](http://rubygems.org/gems/rip) 、 [GitHub](https://github.com/defunkt/rip) )和 Dpkg(主要由需要使用 Debian 软件包管理 Gems 的系统管理员使用)。

[Ryan Tomayko 在他的博客上有一篇精彩的文章，名为“为什么‘需要‘ruby gems’”是错误的”](http://tomayko.com/writings/require-rubygems-antipattern)，详细介绍了省略它背后的技术推理和最佳实践。

## 使用有意义的版本控制模式

对宝石进行版本控制可能是一种痛苦的经历，但这是一座被非常聪明的人征服过的山(好几次)。语义版本化系统旨在使版本化更可预测，因此更安全，并且它可以以最小的努力应用于 gems。semver.org 网站包括详细的规范，以及软件版本控制的最佳实践。

该规范的一些重要要点如下:

*   版本的格式应该是 X.Y.Z(主要。未成年人.补丁)。
*   推出测试发布版本时，您可以使用特殊的版本号，例如 1.0.0beta1、1.0.0alpha3、1.0.0rc1。
*   您可以在主要版本中进行功能更改和错误修复。
*   您可以在次要版本中对*进行向后兼容的*功能更改和错误修复。
*   你只能在补丁版本中进行*向后兼容*的 bug 修复。
*   从 1.0.0 开始，API 应该被认为是公开的和稳定的。

## 利用捆绑器的力量进行测试

Bundler 的一个鲜为人知的秘密是，它可以自动使用您的`.gemspec`文件中的依赖项，无论是手动提供的还是由 gem 工具生成的，来创建一个`Gemfile`。

```
source :rubygems

gemspec
```

有了上面最简单的`Gemfile`，你可以发布一个容易维护的`Gemfile.lock`，并使用`bundle exec`来包装你的测试运行并防止 gem 版本冲突。

## 有一个公开追踪问题的好方法

创造一个没有任何问题的宝石是一个神话。然而，请记住，您创建的任何 gems 的大多数用户也将是技术娴熟的，这是一个理所当然的事情，您将有人准备好并愿意提供修复所需的细节。

提供一种跟踪问题的好方法似乎是显而易见的，但是您会惊讶地发现，找到一个地方向一些 gem 维护者提交 bug、特性请求或其他问题是多么困难。

如果你在 GitHub 上托管你的 gem，你会免费得到一个奇妙的问题跟踪器。有些人更喜欢主持像[灯塔](http://lighthouseapp.com/)这样的东西；无论你选择什么，只要确保它以一种明显的方式链接到自述文件中。

## 让贡献变得简单

与最后一点无关的是，为 gem 做贡献应该很容易。确保你有一个明确的许可证，解释人们可以贡献什么以及如何贡献。另外，通过提供清晰的说明和限制，让他们对原始代码的贡献物有所值。

在 GitHub 上托管您的代码是培养这种实践的一种奇妙方式，因为 Git 使以 fork-alter-merge 模式工作变得非常简单，GitHub 将这种方式包装在 Pull Request good 中。

GitHub 有一个很棒的关于 Pull 请求的帮助部分，这对 Git/GitHub 新手来说是非常宝贵的。

## 一旦公开，它就保持公开

一旦你发布了一个宝石，即使你犯了一个灾难性的错误，这也应该是你最后的选择。更重要的是，如果你发现自己不得不删除一个版本，在任何情况下都不应该重用你删除的副本的版本号。

就此而言，系统管理员和开发人员非常依赖于不可变的、永远可用的 gem 编号。即使您已经添加了密码或其他需要删除的重要安全信息，您可能最好只是更改密码(无论如何您都需要这样做)，并发布后续版本。

RubyGems 上的[帮助部分有一套非常详细的关于拉宝石的说明](http://help.rubygems.org/kb/gemcutter/removing-a-published-rubygem),如果你，不管什么原因，仍然觉得你需要行使这个权利。

## 命名和大小写

命名可能是你会发现自己做的第一件事，也可能是你需要做好的最重要的步骤之一。

在决定一个特定的名字之前，一定要检查一下[RubyGems.org](http://rubygems.org/)和 [GitHub](https://github.com/search) ，确保你的名字没有被盗用。

有一些关于大小写的普遍遵守的规则，除非你真的有一个好的理由，否则你不应该违反。以下规则适用于 gem 的名称以及 gem 中的任何文件名:

*   没有大写字母。这将不可避免地给 Windows 或 OS X 的用户带来问题，这两种操作系统都默认使用不区分大小写的文件系统。
*   空格使用下划线。举个例子，“测试类”应该变成“test_class”。
*   尽量为每个文件保留一个模块或类，并以该模块或类命名文件。举个例子，如果一个文件包含一个名为“EventGenerator”的模块，那么这个文件就应该叫做“event_generator”。

如果你遵循这些非常简单的规则，突然之间，人们对如何`gem install`、`require`和对你的代码做出贡献做出假设变得容易多了；一点点努力就能走很长的路。

## 包扎

所以你想创造你自己的宝石？通过遵循上面的最佳实践，你可能会避免冒犯你的前辈。许多非常聪明，非常聪明的人负责使宝石切割像今天这样容易，在这个过程中，他们提供了宝贵的工具和技术，需要一定程度的掌握。学习这些工具，遵循上面的最佳实践，你就能帮助创建一个更安全、更干净、更高效的 Ruby 代码社区。

## 分享这篇文章