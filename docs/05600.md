# 仔细看看 Go 接口

> 原文：<https://www.sitepoint.com/closer-look-go-interfaces/>

听说过“最好的界面就是没有界面”吗？虽然对于产品设计来说这可能是真的，但对于编程围棋来说肯定不是。相反，遵循“宁可接口太多”的原则可能更好。为什么？在本文中，我们将了解什么是接口，它们是如何在 Go 中实现的，以及它们为什么如此有用。让我们开始吧！

### 什么是接口？

一般来说，一个接口定义了一个对象的行为，从而定义了这个对象如何被系统的其他部分使用。接口描述了对象可以做什么，但没有描述对象实际上是如何执行指令的。因此，可以交换对象的实现，而不会破坏使用者的功能。

在 PHP 或 Java 这样的语言中，接口指定了一个类必须实现哪些方法，而每个类又声明它实现了哪些接口。许多类可以实现同一个接口，然后系统可以在接口而不是实现上操作。

### Go 界面

在 Go 中，接口有相同的目的，但是与传统语言有一些不同，这使得接口更加有用和通用。那么，Go 中有哪些接口呢？首先，Go 中的一个接口简单定义为**一组方法**。例如，标准库中的[阅读器](http://golang.org/pkg/io/#Reader)接口如下所示:

【golang】
类型阅读器接口{
Read(p []byte) (n int，err error)
}
[/golang]

它指定了一个方法`Read`，它有一个类型为`[]byte`的参数，并返回两个命名参数(类型为`int`和`error`)。一开始，只包含一个方法的接口可能看起来不寻常，但在 Go 中实际上并不少见。围棋充满了美丽的、小巧的、可组合的棋子——我们稍后将回到这一点。现在，让我们再看一下代码。我们注意到接口的名字只是方法名`Read`加上一个`-er`，这是 Go 中的一个约定。例如，我们还有一个`Writer`和一个`Printer`接口，正如您所期望的，它们分别由一个`Write`和一个`Print`方法组成。

关于 Go 中的接口，需要知道的第二个要点是，它们**引入了一种新类型**。在上面的例子中，我们声明了新的类型`Reader`，它属于`interface`类型。接口类型的值可以是满足接口的任何值。

那么类型是如何实现接口的呢？传统上，类型会声明它们实现接口的意图，例如在 PHP 或 Java 中使用关键字`implements`。在 Go 中，**接口被隐式满足**。如果一个类型实现了集合中的所有方法，它就实现了一个接口。所以，任何东西都是有一个`Read(p []byte) (n int, err error)`方法的`Reader`。例如，标准库中的[缓冲区](http://golang.org/pkg/bytes/#Buffer)类型可以用作`Reader`，因为它实现了`Read`方法。

还和我在一起吗？很好！让我们看看这一切是如何让 Go 中的接口变得如此强大的，以及它们可以用来做什么。

### 空界面

我提到接口是方法的**集合**。还记得很久以前你的数学课吗？你可能已经知道最小的集合是空集。所以，在 Go 中，最小的接口是**空接口**，记为`interface{}`。这个接口是 Go 中每个类型都实现的，因为每个类型至少没有方法(而且接口是隐式满足的！).虽然这可能合乎逻辑，但是没有方法的接口有什么用呢？因为一个接口也引入了一个新的类型，我们现在有了一个类型，可以用在我们处理未知类型的值的地方。这有点类似于动态语言中的“鸭子打字”。在 Go 中尽可能避免空界面可能是一个好主意，但在需要时可以使用它是一件很棒的事情。例如，`fmt`包的`Print`函数接受任意数量的`interface{}`类型的值:

[golang]
func Print(a…interface { })(n int，err error){
…
}
[/golang]

这非常有意义，因为你可能想要打印一个`string`或者一个`int`，但是你不希望每种类型都有不同的`Print`函数。在内部，`Print`使用类型断言将每个参数转换成正确的类型，然后相应地打印出来。

### 复合界面

想听更多的集合论吗？请记住，一个集合也可以包含其他集合。外部集合由内部集合的所有元素组成。果然，这在围棋中也是可能的。在标准库中甚至有一个突出的例子: [ReadWriter](http://golang.org/pkg/io/#ReadWriter) 接口。`ReadWriter`是`Reader`接口(我们之前看到的)和`Writer`接口的集合。它是这样声明的:

【golang】
type read Writer 接口{
Reader
Writer
}
[/golang]

这意味着任何同时实现`Reader`和`Writer`的东西也会实现`ReadWriter`(自动实现！).还记得我说的是围棋的小美棋子吗？这是其中之一。

### 什么可以实现接口？

到目前为止，我们知道任何实现接口的方法集的东西都会满足接口。现在，与 PHP 或 Java 相比，Go 中几乎任何东西都可以附加方法。这反过来意味着几乎任何东西都可以满足一个接口。例如:

[golang]
type Counter int
func(Counter * Counter)Read(p[]byte)(n int，err error){
…
}
[/golang]

我们正在定义一个新的类型`Counter`，它属于类型`int`。然后，我们附加一个`Read`方法，这就是我们在任何使用`Reader`的地方使用`Counter`类型所需要的全部(尽管我不知道计数器读取的是什么……)

### 利用标准库

假设您现在想要打印计数器。当然，你可以写一个方法来帮你做这件事，但是更方便的是查看`fmt`包，看看与打印相关的函数需要什么类型，例如 [Print](http://golang.org/pkg/fmt/#Print) 。事实证明，它可以打印`Stringer`接口类型的值。按照惯例，`Stringer`指定了一个名为`String`的方法，它只返回一个字符串。所以，如果你给你的类型添加一个方法`String`，它将满足`Stringer`接口。然后你可以将它传递给`fmt.Print`，它将打印出你在`String`方法中返回的任何内容。

实际上，您可以将`Counter`原样传递给`fmt.Print`,因为它知道如何打印`int`,但是使用`String`方法的另一个好处是它允许您在打印时添加更多的文本，例如:

[golang]
func(Counter * Counter)String()String {
返回“我的计数器值:+ strconv。Itoa(计数器)
}
[/golang]

通过实现正确的接口，有许多方法可以利用标准库——通常只需要一种方法。

### 结论

我们已经看到 Go 接口是一个非常强大的概念。与此同时，他们感觉比用其他语言要轻便得多，主要是因为他们含蓄地满足了。因此，在 Go 中设计系统时，接口是核心部分之一。犯了太多的错误！

## 分享这篇文章