# 语义版本化:为什么应该使用它

> 原文:[https://www . site point . com/semantic-versioning-why-you-should-using/](https://www.sitepoint.com/semantic-versioning-why-you-should-using/)

语义版本化(简称为 [SemVer](http://semver.org/) )是一个在过去几年中不断发展的版本化系统。随着每天都有新的插件、附件、扩展和库被构建，拥有一种通用的软件开发项目版本化方法是一件好事，可以帮助我们跟踪正在发生的事情。

## 什么是 SemVer？

SemVer 是一个三组件系统，格式为`x.y.z`，其中:

*   `x`代表主要版本
*   `y`代表次要版本
*   `z`代表补丁

所以你有:`Major.Minor.Patch`。

## SemVer 是如何工作的？

SemVer 依赖于在正确的时间组装正确的组件。因此，确定您应该发布哪种类型的版本是很简单的。

如果你主要是**修复 bug**，那么这将被归类为补丁，在这种情况下，你应该撞 **`z`** 。

如果你正在以一种**向后兼容**的方式实现新特性，那么你将会遇到 **`y`** ，因为这是所谓的*小版本*。

另一方面，如果你实现的新东西很可能**打破现有的 API** ，你需要撞 **`x`** ，因为它是*主*版本。

## 为什么是塞弗？

因为有道理。如果说我学到了什么，那就是没有指导方针的版本控制基本上毫无意义。转移到 4.2？好吧，好吧。为什么？为什么不是 5？为什么不是 4.1.1？为什么不是 4.11？为什么不是 4.1.oh-snap-new-version？

遵循严格的准则有助于赋予版本号意义。

例如，如果您看到版本 1.3.37，那么您会知道这是第一个主要版本，但已经有 3 个次要版本带来了新功能。然而，你也会注意到这是这个小版本的第 37 个补丁，这意味着有很多 bug(或大或小)。

它对管理依赖关系也很有帮助。假设您正在构建一个名为`Unicorn`的库。不管出于什么原因，你有了`Rainbow`作为依赖。当你第一次从盒子里拿出你的库时，`Rainbow`的版本是 6.6.6(看起来很漂亮，是吧？).

这意味着您可以将`Rainbow`指定为大于或等于 6.6.0 但小于 7.0.0 的`Unicorn`依赖项。还记得第一个数字是一个大补丁吗？如果有一天`Rainbow`升级到 7.0.0，没有什么告诉你它不会坏`Unicorn`，所以最好保持在 6 版本。

## 要记住的事情

现在你已经知道什么是 SemVer 了，让我们来看看当人们第一次开始使用它时可能会犯的一些错误。

### 它从 0.1.0 开始

使用 SemVer 时需要注意的一点是，它从 0.1.0 开始，而不是像人们想象的那样从 0.0.1 开始。你想通了，就有道理了。您不是从一个补丁开始，而是从一组特性开始，作为您项目的第一稿，因此是版本 0.1.0。

### 1.0.0 之前只是发展阶段

每当你在构建一个新的软件时，总有一个阶段你会不断地问自己:我应该什么时候发布第一个正式的主要版本？

这里有一些提示可以帮助你回答这个问题:如果你的软件已经在生产中使用或者有用户依赖它，那么你应该已经是 1.0.0 了。此外，如果您非常担心破坏当前的 API，这同样可能意味着您应该已经在运行 1.0.0 了。

否则，请记住，低于 1.0.0 的版本基本上是开发高峰，您专注于完成工作。在 1.0.0 之前，你不应该害怕打破东西，你会做任何需要做的事情，以便当 1.0.0 到来时，它是稳定的。

## 关于预发行版

在部署一个主要版本之前，您通常会经历大量需要反复测试的工作，以确保一切正常。这通常是你想要预发布的时候。

使用 SemVer，可以通过向版本添加连字符和标识符来定义预发布。例如，版本 1.0.0 的预发行版可能是 1 . 0 . 0-α1。如果需要另一个版本，它将变成 1 . 0 . 0-α2，依此类推。

## 最后的想法

如果你没有在使用 SemVer，那么就没有正当的理由不在你的下一个项目(或当前项目)中使用它？).它不仅有助于保持事物的整洁和有意义，而且也有助于其他可能将您的项目作为依赖项的人。

## 分享这篇文章