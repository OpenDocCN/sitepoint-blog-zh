# 更好地理解 PHP 的垃圾收集

> 原文：<https://www.sitepoint.com/better-understanding-phps-garbage-collection/>

有趣的是，仅仅几年时间就能让事物的名称发生变化。如果今天出现这种情况，它可能会被称为 PHP 回收选项，因为我们不是把东西捡起来扔进再也看不到的垃圾填埋场，而是真正地谈论抓住那些已经不再使用的东西，并把它们重新设置为有用的。但是，当这个想法被开发出来的时候，回收还不是社会的一部分，所以这个任务被给了一个粗俗的名字“垃圾收集”。除了遵循历史和惯例给我们的东西，我们还能做什么？

## 程序产生的垃圾

程序使用资源；有时很小，有时大得多。数据字段就是一个例子。程序可以定义一个在程序中使用的数据字段，比如序列号。一旦定义，这个数据字段将占用内存空间，可能只有几个字节，但仍然是空间。因为每台机器或编程环境都有有限(尽管很大)的可用空间，所以剩余的空间将减少该字段所占用的空间。

当程序结束时，自然地，程序和它占用的任何空间都将消失，可用的总空间将扩展回它的最大大小。但是如果程序永远不结束会发生什么呢？

我曾经写过一些这样的程序。它们是美丽的作品，当店里的其他人注意到我创作了一件时，我总是很高兴。没有什么比独自一人将一大块 IBM 熨斗带到一个静止不动的地方更能表明你的能力了，而周围的小隔间里一个接一个的人大声说，“嘿，系统有什么问题吗？”诀窍是插话第二或第三次，以转移对自己的注意力。

但是有些程序甚至意味着永远运行，像守护程序和其他类似的东西。随着它们的运行，它们产生的碎片数量可能会继续增加。如果被锁定的资源是大量的，那么它会对您的系统产生真正的负面影响。

因此，每种语言都必须有一种方法来清除孤立的资源，使它们可供其他用户使用，并确保总的可用系统空间保持不变。幸运的是，PHP 有一个三层的垃圾清除方法。

## 第一级–范围结束

首先，像大多数语言一样，每当一个动作范围结束时，该动作范围内的所有内容都被销毁，所有分配的资源都被释放。动作的范围可以覆盖函数、脚本、会话等。当这个范围结束时，它所坚持的一切也就结束了。当然，您可以通过使用`unset()`函数随时释放资源。

这是函数和方法如此重要的一个原因，因为它们建立了一个动作范围，特定的内存使用何时开始，何时应该结束，并限制了事物存在的时间。应该尽可能使用它们来代替全局实体。

## 第二级–引用计数

第二，像大多数脚本语言一样，PHP 使用一种称为引用计数的技术来跟踪有多少实体正在使用一个给定的变量。

当在 PHP 脚本中创建一个变量时，PHP 会创建一个名为 zval 的小“容器”,它由赋给该变量的值和另外两条信息组成:is_ref 和 refcount。zval 容器保存在一个表中，每个动作范围(脚本、函数、方法等等)都有一个表。

is_ref 是一个简单的 true/false 值，指示变量是否是引用集的一部分，从而帮助 PHP 判断这是一个简单变量还是一个引用。

refcount 更有趣，因为它保存了一个数值，指示有多少不同的变量在使用这个值。也就是说，如果定义变量`$dave = 6`，refcount 将被设置为 1。如果我说`$programmer = $dave`，refcount 将增加到 2。PHP 知道的足够多，不会为值 6 创建第二个 zval 它只是更新已经存在的值容器上的计数器。当程序结束时，或者当我们离开函数的作用域时，或者当使用了`unset()`时，那么这个 refcount 就会递减。当 refcount 达到零时，zval 被销毁，它所拥有的任何内存现在都是空闲的。

当然，这是一个简单变量的简单例子。当你谈论数组或对象时，为数组中的一个元素的多个值创建多个 zrefs 要复杂得多，但是基本的处理是相同的。

但是，如果我们在另一个数组中使用一个数组，就会出现问题，这在更复杂的 PHP 脚本中经常发生。在这种情况下，当设置原始数组值时，数组值的 refcount 设置为 1，当该数组与另一个数组相关联时，ref count 增加到 2。如果第二个数组的使用范围结束，则 refcount 减 1。我们现在的情况是，值本身不再与任何东西相关联，但是表示它的容器(zval)仍然有一个大于零的 refcount。

最终结果是，原始阵列所代表的存储空间将不会被释放，并且该内存量现在不可用于任何用途。通常，我们认为丢失的存储量很小，但事实往往并非如此。如今，数组可能是非常大的东西，如果发生这种情况的脚本是守护进程或其他几乎连续运行的函数，那么这就特别成问题。在这种情况下，由此产生的“内存泄漏”会对性能甚至服务器的运行能力产生灾难性的后果。

## 第三级——正式的垃圾收集

显然，面向引用计数的清除有其局限性，但幸运的是，PHP 5.3 提供了另一种选择来帮助解决这种情况。

我们希望垃圾循环处理的特定情况是 zval 已经递减，但它仍然是非零值的情况。基本上，这个循环会查看哪些值可以进一步减少，然后释放那些变为零的值。

实际发生的是 PHP 跟踪所有的根容器(zvals)。无论垃圾收集是否打开，都要这样做(因为这样做比询问垃圾收集是否打开更快，等等，等等)。这个根缓冲区可以容纳 10，000 个根(固定大小，但可以改变)。当它填满时，垃圾收集机制将启动，并开始分析这个缓冲区。

GC 例程做的第一件事是遍历根缓冲区，并将所有 zval 计数减 1。这样做的时候，它用一个有点像复选标记的符号来标记每一个，这样它只减少一个根一次。

然后，它再次遍历并标记(这次用一条小曲线)所有减少的计数为零的 zvals。不为零的值递增，以便它们恢复到初始值。

最后，它将在那里再滚动一次，从缓冲区中清除非零 zvalss，并为 refcount 为零的 zval 释放存储空间。

在 PHP 中垃圾收集总是打开的，但是您可以在`php.ini`文件中用指令`zend.enable_gc`关闭它。或者，您可以在脚本中通过调用`gc_enable()`和`gc_disable()`函数来实现。

如上所述，如果启用了垃圾收集，它会在根目录已满时运行，但是您可以忽略这一点，使用`gc_collect_cycles()`函数在您喜欢的时候运行垃圾收集。而且，您可以用 PHP 源代码中的`zend/zend_gc.c`值中的`gc_root_buffer_max_entries`值修改根缓冲区的大小。

总而言之，这允许您控制 GC 是否运行以及何时何地运行，这是一件好事，因为它有点资源密集型，所以可能不是那种为了好玩而运行的东西。

## 你应该什么时候使用它

因为垃圾收集会影响性能，所以有必要花点时间来确定何时应该使用垃圾收集。

首先，请记住，除非您公开运行它(使用`gc_collect_cycles()`函数)，否则正式的垃圾收集将不会发生，直到根表(10，000 个条目)满了为止，并且由于这个表是在作用域级别，所以对于小函数来说，这不会发生。

你应该在小脚本上使用它吗？这取决于你。很难说运行像垃圾收集这样的东西是一件坏事，但是如果你有一些小的、快速运行的脚本，它们开始运行，然后结束，然后消失，那么可能不会有太多的回报。但是，如果您的服务器正在运行大量持久的小脚本，那么这种努力可能是值得的。唯一真正了解的方法是对您的应用程序进行基准测试。当然，如果您有长时间运行的脚本，或者特别是没有结束的脚本，那么如果您想防止我们上面谈到的那种内存泄漏，垃圾收集是必不可少的。

也许最重要的是，我们应该始终遵循良好的编程准则，以便我们最小化或消除全局变量，并将我们的变量绑定到作用域，这样，即使我们有一个长时间运行的脚本，我们也可以在函数而不是脚本结束时释放内存。还要注意什么时候使用数组中的数组，或者引用对象的对象，因为这种情况会导致内存泄漏，并且是正式垃圾收集过程的真正目标。

<small>图片 via[Fotolia](http://us.fotolia.com/?utm_source=sitepoint&utm_medium=website_link&utm=campaign=sitepoint "Royalty Free Stock Photos at Fotolia.com")</small>

## 分享这篇文章