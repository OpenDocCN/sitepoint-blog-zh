# PHP 流和输出缓冲解释

> 原文：<https://www.sitepoint.com/php-streaming-output-buffering-explained/>

最近，Rails 推出了一个名为**流媒体**的功能。尽管流式传输不是一个新概念，但是将它构建到框架中，让开发人员能够轻松地构建快速响应的应用程序，这无疑是一个巨大的进步。作为一名 PHP 开发人员，我想知道在我们最喜欢的语言中是否可以有类似的东西？答案是肯定的——我们可以毫不费力地在 PHP 应用程序中实现流式传输，但是为了做到这一点，我们必须熟悉一些基本概念。

在这篇文章中，我们将看到什么是流，什么是 **output_buffering** ，以及如何在不同的 web server(Apache，Nginx)和 PHP 配置(CGI，mod_php，FastCGI)下获得我们想要的结果。

## 流和输出缓冲

![](img/e7a16bc529ddf0bdec1615a33320e542.png)

### 流动

web 中的流指的是分块发送响应而不是一次发送的机制。在传统的 HTTP 请求/响应周期中，响应在完全准备好之前不会传送到浏览器，这使得用户需要等待。这种限制是过去薄弱的软件和硬件的残余，但从那时起一切都发生了很大的变化。网络系统和浏览器现在足够强大，能够以快速有效的方式处理内容的传输。想象一下，试图观看一个视频，但在它完全下载到播放器的缓冲区之前无法观看。在流媒体的帮助下，我们可以非常高效地观看视频或听我们最喜欢的音乐，因为内容是即时加载的，而其余的数据是在后台下载的。

流媒体似乎非常适合给用户一种网络应用加载速度很快的感觉。然而，HTTP 响应的流式传输与媒体内容的流式传输完全不同。HTTP 响应的流式传输仅仅意味着将一个固定或可变大小的响应发送给浏览器，而 web 服务器准备其余的响应。例如，您希望在单个页面上显示好莱坞电影列表。如果您首先准备完整的响应，然后将其发送到浏览器，最终用户肯定会感觉到延迟。但是，如果你一次发送 100 部电影，并在浏览器中显示它们，同时为接下来的 100 部电影准备 HTML，内容会感觉加载得相当快。

![](img/a981bc148130415654183bc0a1462570.png)

HTTP 响应不仅仅包括可呈现的项目——还有很多其他的东西，比如响应状态代码、HTTP 头、cookies 等等。这些是响应的重要组成部分，但最终用户不会注意到，因为它们从未被呈现出来。没有他们，我们的内容就没有任何意义。较大的网站不会让用户等待，而是将不可呈现的信息发送给浏览器，一旦浏览器开始接收到这些信息，它就会开始旋转加载指示器，你几乎肯定会在较慢的连接上看到这个指示器。样式表和 JavaScript 文件大部分时间保持不变，因此许多站点也将它们与不可呈现的内容块一起发送，以便浏览器在准备其余响应时开始获取和执行它们。这是一种创造速度错觉的非常强大的技术。当`body`标签的内容生成时，它被发送到浏览器，并且该内容可以再次以块的形式发送，进一步宣传速度的假象。

### 输出缓冲

输出缓冲是一种机制，在这种机制中，我们不是立即向浏览器发送响应，而是将它缓冲到某个地方，以便当整个内容准备好时，我们可以立即发送它。这是 PHP 向浏览器发送响应的默认方式。我们都知道，为了向浏览器发送响应，我们必须使用类似于`echo`或`print`的语句。每次我们使用`echo`时，我们基本上都是告诉 PHP 向浏览器发送一个响应。但是由于 PHP 默认启用了输出缓冲，所以内容会被缓冲，而不会发送到客户端。输出缓冲通过`php.ini`中的`output_buffering`进行配置，运行`phpinfo()`可以看到其当前的配置值。PHP 的文档中有以下关于输出缓冲的信息:

> 通过将该指令设置为“On ”,可以为所有文件启用输出缓冲。如果您希望将缓冲区的大小限制在某个特定的大小，您可以使用最大字节数而不是“On”作为该指令的值(例如，output_buffering=4096)。从 PHP 4.3.5 开始，这个指令在 PHP-CLI 中总是关闭的。

根据上面的信息，我们可以很容易地看到，PHP 缓冲区在大多数配置下的默认大小是 4096 字节(4KB ),这意味着 PHP 缓冲区可以容纳高达 4KB 的数据。一旦超过这个限制或者 PHP 代码执行完成，缓冲的内容会自动发送到正在使用的任何后端 PHP(CGI、mod_php、FastCGI)。PHP-CLI 中输出缓冲是`always Off`。我们很快就会明白这意味着什么。

值得注意的是，即使是 web 服务器也可能启用了缓冲，这意味着从 PHP 后端获取的数据可以被 web 服务器缓冲，并可能覆盖 PHP 的设置。现在我们已经对流和输出缓冲有了很好的理解，让我们看一个简单的例子。

### 简单的例子

在您的网络服务器的根目录下创建一个文件`output.php`，以便可以从浏览器访问，例如`http://localhost/output.php`。将下面的代码放到`output.php`中。

```
<?php
		echo "Hello ";
		sleep(5);
		echo "World!";
	?>
```

继续在您的浏览器中访问该文件。你将不会看到任何内容，直到五秒钟后，整个“你好世界！”短语出现。这是因为输出缓冲。执行第一个`echo`时，不是将响应发送给浏览器，而是缓冲其内容。因为如果缓冲区变满或代码执行结束，缓冲的内容将被发送到浏览器，并且因为`Hello World!`不足以占用超过 4KB 的缓冲区大小，所以当代码执行结束时，内容将被发送。

现在运行相同的示例，但这次是从控制台(命令行)运行，使用以下语句:

```
php /path/to/directory/output.php
```

你一按 enter 键，就会看到单词`Hello`出现，五秒钟后单词`World!`也会出现。这就是“在 PHP-CLI 中总是关闭”的意思。因为输出缓冲是关闭的，所以每个`echo`一执行，响应就被发送。

现在让我们更详细地看看输出缓冲。

## 例子

在上一个例子中，我们已经看到，由于 PHP 中的输出缓冲，我们直到 PHP 的执行完成后才得到响应。这是不可取的，因为我们希望在准备其他响应的同时向浏览器发送一些内容。正如我们所知，PHP 中输出缓冲区的默认大小是 4KB，所以如果我们想向客户端发送响应，我们必须分块生成响应，每个块的大小必须是 4KB。让我们看一个例子:

### 8KB 区块示例

```
<?php

		$multiplier = 1;
		$size = 1024 * $multiplier;
		for($i = 1; $i <= $size; $i++) {
			echo ".";
		}
		sleep(5);
		echo "Hello World";
	?>
```

将上述代码保存在 web 服务器根目录下的一个文件中。如果你运行这个例子，你会发现你的浏览器的加载指示器直到五秒钟后才显示数据正在被接收。现在，让我们将`$multiplier`从`1`改为`8`并刷新。如果没有配置特定的设置，您会注意到浏览器告诉我们它几乎立即开始接收一些数据。不必等待五秒钟就能意识到页面已经开始加载，这对用户体验非常好。

你可能想知道为什么我们把`$multiplier`从`1`设置为`8`。这背后的原因与 web 服务器的缓冲区有关。就像我们上面说的，第一层是 PHP 缓冲，我们可以通过`output_buffering` PHP 设置来检查。然后，可能有 PHP 后端(CGI，mod_php，FastCGI)缓冲，最后可能有 web 服务器缓冲。通常情况下，Nginx 和 Apache 缓冲区的内容都高达`4KB`或`8KB`，这取决于所使用的操作系统。通常，在 64 位操作系统上，这个限制是`8KB`，在 32 位操作系统上是`4KB`。

上面的代码流程如下，假设 PHP 中的`output_buffering`设置为`4KB`:在循环中，当`4KB`之前的数据由于`echo`语句已经存储在 PHP 缓冲区中，PHP 自动将这些数据发送到它的后端(CGI，mod_php，FastCGI)。`mod_php`不缓冲数据，直接发送给 Apache。默认情况下`CGI`和`FastCGI`通常会将数据缓冲到`4KB`(取决于配置)，因此当它们收到数据时，它们的缓冲区也会变满，因此数据会立即发送到网络服务器。网络服务器也轮流缓冲数据，根据操作系统的不同，最多可达`4KB`或`8KB`。由于我使用的是 64 位操作系统，我这边的缓冲极限是`8KB`。服务器接收`4KB`的数据，但其缓冲区大小为`8KB`，因此这不会导致缓冲区溢出，也不会向浏览器发送输出。当 PHP 循环准备好另一个`4KB`时，重复上述过程，但是这一次由于已经在服务器的缓冲区中保存了`4KB`，即将到来的`4KB`将导致缓冲区溢出，导致缓冲区被清除并发送到浏览器。

现在继续，在`$size = 1024 * $multiplier;`之后放置以下代码:

```
$size -= 1;
```

刷新，您将会看到，这一次浏览器直到五秒钟后才显示它已经开始获取内容。这是因为我们将循环迭代到`8KB - 1`次，这不会导致缓冲区溢出，并且直到五秒钟后才会有数据发送到浏览器。现在将下面的代码放在`sleep(5);`之前:

```
echo ".";
```

再次刷新您的浏览器，您将看到这一次浏览器显示它已经开始接收内容，没有五秒钟的延迟。我们将循环迭代到`8KB - 1`次，这意味着第一个 4096 字节已经被推送到服务器并被缓冲。当循环结束时，PHP 的缓冲区将有 4095 字节，但循环后的`echo ".";`帮助我们用 4096 字节填充缓冲区，导致将缓冲区内容发送到上层，从而发送到浏览器。

有一点需要注意。PHP 的`output_buffering`设置有两个可能的值。一个是指示它是否是`On`，第二个是指示缓冲区的最大大小。如果`output_buffering`设置为`1`，那么在 PHP 代码执行完成之前，您可能看不到您的内容或浏览器加载指示器旋转。这是因为在`1`上有`output_buffering`意味着我们已经启用了它，但是还没有指定最大大小，所以在这种情况下 PHP 缓冲区可以容纳数据达到`memory_limit`设置中的数量。

### ob _ 冲洗和冲洗

我们现在已经熟悉了 PHP 中输出缓冲和流的概念，也知道了如何将响应分块发送给浏览器。然而，您可能想知道是否有更好的方式来发送内容。仅仅为了提前向客户端发送数据而生成`8KB`块是不可行的，因为普通的网页没有太多内容，而`8KB`无疑是要以块的形式发送的大量数据。发送无用的数据也没有好处，因为这只会增加延迟。事实证明，有一些内置的方法，我们可以用来克服这个问题。

![](img/f202ae795e7f5fd8e18b1e8f6ff3056f.png)

`ob_flush()`和`flush`是 PHP 的内置方法，用于向上层发送数据。除非缓冲区已满或者 PHP 代码执行完毕，否则缓冲的数据不会发送到上层。为了在缓冲区未满和 PHP 代码执行未完成时发送数据，我们可以使用`ob_flush`和`flush`。

现在让我们看一个例子:

```
<?php 
		$multiplier = 1;
		$size = 1024 * $multiplier;
		for($i = 1; $i <= $size; $i++) {
			echo ".";
		}
		sleep(5);
		echo "Hello World";
	?>
```

在上面的例子中，在`sleep(5);`之前放置以下行

```
ob_flush();
	flush();
```

保存文件并在浏览器中访问它。当您要求浏览器获取网页时，您将看到浏览器正在指示它已经开始接收内容。这正是我们想要的，因为我们不必担心生成内容，我们可以轻松地将内容传输到浏览器，而不必等待整个内容生成。你可以尝试不同的乘数来更好地理解这些概念。

然而，有一些你应该知道的警告。上面的代码在 Apache 中使用`mod_php`可以很好地工作。它甚至可以在没有`for`循环的情况下工作。一旦`ob_flush()`和`flush()`被执行，浏览器将开始指示一些内容即将到来。然而，由于 Nginx 处理请求的方式，`ob_flush()`和`flush()`可能无法与 Nginx 一起使用。为了让`ob_flush`和`flush`在 Nginx 中无缝工作，您可以使用以下配置:

```
fastcgi_buffer_size   1k;                              
	fastcgi_buffers       128 1k;  # up to 1k + 128 * 1k
	fastcgi_max_temp_file_size 0;
	gzip off;
```

你可以在[这篇文章](http://www.justincarmony.com/blog/2011/01/24/php-nginx-and-output-flushing/)中找到更多相关信息。

### 使用 Ajax 流式传输

既然我们已经看到了如何在标准的 HTTP 请求/响应周期中发送内容，那么让我们看看如何对 Ajax 请求做同样的事情。Ajax 请求是一种很好的、优雅的获取数据的方式，无需重新加载整个页面。我们将一个回调与一个 Ajax 请求相关联，一旦接收到所有内容，这个回调就会被执行。这意味着我们不能在 Ajax 请求中传输内容。幸运的是，我们有`XMLHTTPRequest 2`，它是 Ajax API 的下一个版本，并且在最新的浏览器中[支持](http://caniuse.com/#feat=xhr2)。这个新版本有很多很酷的特性，比如跨源请求、上传进度事件和支持上传/下载二进制数据。进度事件用于告诉用户我们已经上传了多少数据，我们也可以获得成块下载的数据。让我们看一个例子:

使用以下代码创建一个 HTML 文件:

```
<html>
       <head>
         <title>Ajax Streaming Test</title>
       </head>
       <body>
         <center><a href="#" id="test">Test Ajax Streaming</a></center>
         <script type="text/javascript"> document.getElementById('test').onclick = function() {
             xhr = new XMLHttpRequest();
             xhr.open("GET", "response.php", true);
             xhr.onprogress = function(e) {
               alert(e.currentTarget.responseText);
             }
             xhr.onreadystatechange = function() {
               if (xhr.readyState == 4) {
                 console.log("Complete = " + xhr.responseText);
               }
             }
             xhr.send();
           }; </script>
       </body>
	</html>
```

现在在浏览器中加载这个文件并点击链接。发起一个 Ajax 请求从`response.php`获取数据，我们正在监听`onprogress`事件。每当有新的数据块到达时，我们都会在警报中输出它。

现在把下面的代码放到`response.php`里，保存在同一个文件夹里，相对于上面的 HTML 文件。

```
<?php for ($i = 1; $i <= 10; $i++): ?>
	  <?php sleep(1); ?>
	  Count = <?php echo "$i\n"; ?>
	  <?php ob_flush(); flush(); ?>
	<?php endfor; ?>
```

如您所见，我们运行了十次循环，每次运行时暂停一秒钟，然后回显一些内容。这些内容通过刷新发送到上层。现在继续点击`Test Ajax Streaming`。如果一切顺利，您会注意到`Count = 1`出现在一个警告中。当您解除提醒时，您会看到另一个带有`Count = 1 \n Count = 2`的提醒。当您关闭那个时，您将在另一个提醒中看到`Count = 1 \n Count = 2 \n Count = 3`，以此类推，直到 10。当整个 Ajax 请求成功完成时，您将在控制台中看到完整的输出。我们刚刚在 Ajax 请求中实现了流式传输，我们可以轻松地相应更新我们的界面，为最终用户提供出色的体验。

注意:有一些浏览器不兼容。在 Chrome 和 Firefox 中测试上述代码。Firefox 在输出方面的表现将与演示完全一样，但 Chrome 将首先显示一个空警告，然后按预期继续。在实现流式传输时，请记住这种边缘情况！

## 结论

流式传输是向用户发送内容以模拟速度的一种很棒的方式。但是像所有的事情一样，流媒体并不是一颗银弹，它也有自己的缺点。以下是流不是理想解决方案的一些情况:

1.  处理异常:状态代码对于浏览器决定每个请求的成功/失败是必不可少的。因为我们已经提前发送了状态代码以及标题、cookies 等。如果在某个时候服务器端发生异常，服务器将无法将它传送到浏览器，因为状态代码已经发送。

2.  发送小数据块是低效的，因为[网络更喜欢具有较大响应的少量数据块，而不是具有较小响应的大量数据块](http://en.wikipedia.org/wiki/Nagle%27s_algorithm)。为了以块的形式发送内容，我们必须仔细选择块的大小。

我希望这篇文章能帮助你掌握流和缓冲区的基础知识。请让我们知道你读完这篇文章后想到的其他实验，如果有的话，当然，在下面的评论中留下你的反馈。你想看更多的例子吗？更多解释？让我们知道！

## 分享这篇文章