# 在开发人员晚宴上虚张声势

> 原文:[https://www.sitepoint.com/bluff-your-way-through-react/](https://www.sitepoint.com/bluff-your-way-through-react/)

如果您正在考虑使用 React，但是被大量的资源所淹没，已经放弃抵抗噪音，或者只是想了解事情的最新进展，请继续阅读。如果你已经使用了 React，讨厌 React，还想抵制 React…请继续阅读本周末聚会的克里夫笔记。

## 有点反应过度了

关于这个话题，可能没有什么可以写的了，除非已经涉及到了。阅读[牛逼 react repo](https://github.com/enaqx/awesome-react) 中的每一个资源，相当于完成了整部大英百科全书炮。耗时，印象深刻，有启发。然而，为了避免尴尬，我们只有周六之前的时间，一个编码教程不可能涵盖所有可能出现的流行词汇。

## 请告诉我反应是什么

Ben Backbone 说，“它只是 MVC 中的 V 所以只有 1/3 好”。

你说，“我发现与 MVC 比较没有帮助，也不直观，我玩乐高，专注于制作可以放在任何地方的漂亮积木”。

这是一个构建模块:

```
({ someText }) => <div>{ someText }</div> 
```

React 不是一个框架，它是一个库，允许你组合这些构件来构建可维护的交互界面。

现在你可能想知道为什么 React 如此令人生畏，为什么滚动条比你希望的要高得多…嗯，就像露营一样，你不能只穿着内衣走进树林，你需要这个…还有这个…还有这个…

## 我对 JSXmas 的所有期望就是[你](https://facebook.github.io/jsx)

Alan Angular 说，“你把 HTML 放在你的 JS 中，并且混合了关注点”。

你说，“你喝醉了，艾伦，回家吧…但是，这也是一种表达标记的令人愉快的方式，可以转换成许多东西，看起来像 HTML，所以我没有新的 DSL 需要学习，实际上我唯一关心的是呈现我的数据的视图”。

是的，JSX 可能受到了仇恨的冲击，但这才是 React 与众不同的地方，现在已经被其他图书馆所采用。不再需要在底层摆弄 DOM，检查属性或者担心跨浏览器的问题。我可以写一些看起来很像 HTML 的东西，但是我也可以使用传统的 JS 来[操作它](https://www.sitepoint.com/video-using-map-to-create-lists-in-react/)。

## 虚拟 DOM，DOM，DOM，DOM，DOM

爱德华·恩伯说，“微光引擎重画比虚拟 DOM 快得多”。

你说，“虽然性能是我关心的问题，但我很少/从不构建需要呈现 10k 个不断变化的列表项的应用程序。如果这项技术符合社区、稳定性、可维护性、可测试性的标准，它可能就不会慢。”。

与 DOM 交互相对较慢，因为在给定的操作中，与内存中的 JS 相比，它通常占用最多的时间。React 团队开发了虚拟 DOM (VDOM ),允许他们快速比较状态变化，以最大限度地减少需要完成的缓慢工作。

## 我不懂艺术，但我知道我喜欢什么

夏洛特 CSS 说，“内联风格是互联网的所有问题。否:之前/:之后，不完整的@media 打印支持，非干代码，混合问题[Alan +1]，额外开销:悬停等。我需要继续吗？”。

您认为，“与他们甚至没有严格的内容安全政策*相比，这一切都相形见绌，很高兴她没有提到这一点”。

你会说，“在沙漠之前，这太夸张了。无论如何，伪选择器是一个黑客，我不喜欢使用它们，我喜欢树，DRY 是我不喜欢你的一揽子 CSS 的原因，我再次强调，我只是关心如何使用我的表示层来达到它的预期目的。

好的，所以你不必使用 React 的内联样式，你可以**不那么大胆**试试 [CSS 模块](https://github.com/css-modules/css-modules)(如果你喜欢你的 HTML 中的长类名)，许多 CSS 内联工具中的一个或者*只是*使用 [BEM](http://getbem.com/) 。

我强烈建议您尝试一下，这意味着您的组件的内容和风格是紧密耦合的(这正是您想要的)，并且可以放心地放在任何地方。开发人员不会不小心踩了对方的脚，也没有必须教授和监管的笨拙的命名约定。JS 也很擅长为[动画](https://aerotwist.com/blog/flip-your-animations/)做繁重的工作。

*为了避免这种轻微的皱纹，你可以使用阴影 DOM，看看 T2 的反应阴影或 T4 的枫树。

## 你在同一个方向流动

Kevin Knockout 说，“通过双向数据绑定，你可以用很少的样板代码得到高度交互的界面”。

你说，“单向数据流是头痛的一半，单向调试和测试更令人愉快，尤其是没有副作用的纯函数”。

因此，我们用看起来像 HTML 的方式编写我们的构建块，它们有自己受保护的样式，它们只会在必要时更新 DOM 但是如何让它们显示内容呢？通过使用具有参照透明性的幂等渲染函数，这些函数当然就像未驱动的雪一样纯净；-)

如果你只为聚会记住一件事，那就是这个核心概念， **React 组件只是函数**。如果你给他们相同的输入，他们应该返回相同的输出，你通过[道具](https://www.sitepoint.com/video-using-props-to-pass-data-in-react/)传递这个数据。*但是，组件也可以保持自己的[状态](https://www.sitepoint.com/video-an-introduction-to-component-state/)，要小心处理*。

在 React 应用程序中，理想情况下，您需要一个真实的来源，[智能组件](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.dizvyhnix)(它们知道数据以及如何传递数据)和非智能组件(它们什么都不知道，并按照要求去做)。您的应用程序的大部分应该由哑组件(工蜂)组成，更高级的组件编排数据以传递给它们。

## 被 Redux 弄糊涂

Jeremy jQuery 说:“React 的问题是，你要花三天时间去尝试[十五种 Flux 实现](https://github.com/voronianski/flux-comparison)才能得出结论，你真的不知道哪一种是最好的。你带着一个去，然后花一天时间写我 10 分钟做的事情”。

你会说，“是的，这是脸书的一块宝石，让社区来研究一个模糊的哲学，我完全同意。尽管现在我有了 Flux 实现，但我的代码很容易推理、测试和扩展”。

开源社区(OSC)的美妙之处在于，一个最优的解决方案最终会出现，所以向 OSC 建议哲学并不是一件坏事。FB 本身以许多不同的方式做通量，那么它是什么呢？

本质上，这是我们讨论过的单向数据流的机制。一个*视图*执行一个*动作*，该动作通过一个*调度器*更新一个*存储库*，该存储库更新你的更高级组件和后续子组件。**总是一种方式，总是可预测的**。

今年早些时候，一个叫[丹](https://github.com/gaearon)的厚颜无耻的家伙为一次谈话准备了一些东西。人们喜欢它，它在 GitHub 上的星星比银河系还多，所以他全职研究它。它叫做 Redux，是我推荐的实现。它不是完全不变的，但是[开发工具](https://youtu.be/xsSnOQynTHs?t=6m23s)在时间旅行和撤销/重做等方面非常出色。由于仅通过纯减速器存储更新，开箱即用。

## 我永远不会为你改变

在这个节骨眼上，人们太忙于葡萄酒和奶酪了，但是如果他们要问关于[不变性](https://www.sitepoint.com/immutability-react/)的问题，这里有一个高层次的观点。

当我们 React 应用程序*中的状态发生变化时，在对 DOM 差异进行另一次检查之前，会对所有内容*进行适当的差异检查。进行深度平等检查的成本很高，区分 VDOM 也是如此。幸运的是，我们可以通过使用不可变数据来帮助 React。如果一个组件的属性没有改变，并且它们是一个不可变的对象，那么当前的属性值和下一个属性值将有相同的引用，这意味着我们可以在 [shouldComponentUpdate](https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate) 中执行一个快速的浅层相等检查。React [生命周期的这个成员](https://facebook.github.io/react/docs/component-specs.html)将减少 VDOM 的不同节省工作和时间。

有了 Redux 的 reducers，你就可以把这个概念从盒子里拿出来，你可以接受一个先前的状态，然后根据一个动作的有效负载创建一个全新的状态。这是不变性的第二个好处，也是一个反复出现的主题；它使您的应用程序可预测。没有 bug 是因为某个东西意外地改变了它不打算改变或与之有业务往来的其他东西。

## 告诉我该走哪条路

Edward Ember 说，“我可以在几分钟内完成我的项目，并且绝对拥有我需要的一切，我发现 React 太轻量级了”。

你说，“对我来说，使用大量的库/构建块，每一个都做好一件事(UI 微服务)是高度可维护的，并且易于未来验证”。

所以 React 没有配备路由器，但迈克尔杰克逊配备了路由器。这是 React 中事实上的路由方式，也是任何单页面应用程序(SPA)的虚拟需求。我们现在有了承诺，获取 API，服务工人，web 工人，本地存储，， [intl](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Intl) 等等。等等。你可以[构建一个本地 SPA](https://www.sitepoint.com/frameworkless-javascript/)，除了几个聚合填充，几乎不需要大型框架。

*框架本身并不是不好的

## 把接力棒传过来

你说，“我已经得到了这个 SPA 所需要的一切，我的杯子是空的，这篇文章太长了，没有可辨别的 TL；博士，我要在星期六之前整理好我的干洗衣物”。

我说，“我告诉你要说什么，不是反过来，而是……还有最后一个可选的部分，然后我们需要讨论如何将所有这些放在一起”。

Redux 不遗余力地解释如何执行异步操作，并通过包括中间件在内的各种方式为您的应用程序播种数据。尼尔·网飞突然出现，说道:*“让我们冷静下来，看看[法尔考](https://github.com/Netflix/falcor)*【你说，】“实际上这听起来相当不错，但我打算让[接力](https://facebook.github.io/relay/)和 [GraphQL](http://graphql.org/) 先走一点”。

FB 在构建移动原生应用、移动网络应用和其他网络产品套件时遇到了一个问题。当 REST 不能解决这个问题时，你如何协调这些平台上极其复杂的数据同步，并使用同一种语言呢？因此，我们有了 GraphQL(与图形数据库无关)，它很像 Flux，只是一个有相当多实现的概念([包括 JS](https://github.com/graphql/graphql-js) )。

GraphQL 是一种允许前端开发人员控制他们的数据需求的语言。没有定制的 REST 端点，没有为要发送的额外字段而困扰各种后端团队，只需请求带有可选参数的数据片段，它就会返回给您。

Relay 然后[通过容器连接【React 组件，并路由到 GraphQL 端点。这种相当复杂的结合带来了乐观的更新、查询批处理和数据同步……只要你有一个 GraphQL 服务器……和模式……以及理解中继变异和时髦的查询语言的能力……](https://www.sitepoint.com/react-data-fetching-with-relay/)

## 昨晚浅薄的渲染改变了我的生活

Roberto Reacto 说，“脸书使用 [Jest](https://facebook.github.io/jest/) 来测试他们的组件，所以这就是我所使用的”。

你说，“这太慢了，太复杂了。它真的很爱嘲讽一切。浅薄渲染和考验一切事物”。

如果 FB 真的使用 Jest，我只能称赞他们的耐心，但你很少会在会议上看到它。读到[这个](http://simonsmith.io/unit-testing-react-components-without-a-dom/)的时候，我顿悟了，剩下的就是历史了。

这是测试前端的最好方法。没有 DOM，只有很少的依赖，只要破解 [Mocha](https://mochajs.org/) 和 [Assert](https://nodejs.org/api/assert.html) ，你就会有**坚如磐石**、**超快的**单元测试可以依赖。通过测试各种移动部件，你会有很长的路要走，这只是留下一些轻量级的功能性[冒烟测试](https://en.wikipedia.org/wiki/Smoke_testing_(software))来确认交互，不错。

## 建造它，他们就会来

格雷厄姆吃了一片冷西兰花后咕噜咕噜地说:“没有构建工具，你怎么构建你的应用呢？”。

你会说，“有了 node、npm 脚本和一个模块加载器，我的工作流大大减少了，但功能却非常强大”。

对我来说，另一个关键的阅读是[这个](http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/)，然后我使用 [webpack](https://www.sitepoint.com/watch-using-webpack-to-transform-jsx/) 作为我选择的武器，但是 [jspm](http://jspm.io/) 和 [Browserify](http://browserify.org/) 是完美的替代品，或者任何给你:

*   热重装:因为我们是超级懒惰的开发者，时间就是金钱
*   巴别塔整合:原因我们会谈到
*   缩小，资产/供应商管理，资源散列:因为你想让一个小小的缓存崩溃的 JS 运行你漂亮的应用程序

## 我想把*[B-阿贝尔](https://babeljs.io/)* 用上 [ES2015](http://es6-features.org/#Constants)

Oscar Old-School 说，“我从 2009 年就开始使用 ES5，遗留浏览器不支持 ES2015，JS 中的类！？该规范每年都在变化，像 Object.observe 这样的阶段性命题在你使用它们的时候会被放弃，Babel 会放弃对常用功能的支持，还有[这三个点](https://youtu.be/gdnuOa7tDco?t=30s) …？”。

你说，“对于一个如此老派的人来说，你非常熟悉所有这些东西，而且你提出了一些很好的观点。正如你提到的 Babel，你知道我们可以向下转换到运行在所有现代浏览器中的 ES5。您不必使用 ES2015 中的每个功能，如果您使用建议的功能，您会自找麻烦。[三个点](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)也很牛逼，把爱传播出去”。

因此，当巴别塔在他的历史课上被一个小孩写出来时(直到他发现多莉少工作了三个小时)，它是 JS transpiler 的首选，除非你喜欢更多的[高卢工具](https://github.com/google/traceur-compiler)。

这不是一个要求(就像 TypeScript 不是针对 Angular 2 的；-))，但在 ES2015 中编写所有代码(为附带项目准备提案)只会让你的一天变得更好。一旦你开始破坏，你将永远不想停止。

是的，原则上最好避免类，组合优先于继承，但是…如果你只扩展一次，并且使用惯用的本机代码使你的 React 组件更可读…也许我们就这样做…

## 同构服务器端呈现通用 JavaScript

Ally Anderson 说，“JavaScript 是互联网的所有问题。这些动态网站不是搜索引擎优化优化，你想要多少嵌套元素！?"。

你说，“没错，JS 不应该用于所有的东西，但是我构建的东西需要交互和伟大的 UX，我仍然关心优雅的退化和渐进的增强。这就是为什么我在服务器端尽可能多地呈现语义元素和形式的内容，这给了我免费的 SEO。

通常当人们使用*同构*和*通用*时，他们指的是服务器端渲染，React 的目标是从 react-dom 和 react-dom/server 中分离出它的主引擎。

作为一个小警告，不要盲目渲染服务器端，因为玻璃的时间更快。视情况而定，在往返行程、延迟、浏览器和硬件等方面可能并非如此。等等。

## 啊，我的代码里有棉绒…哦，还有一些口香糖

关于这一点，没有必要争论，桌子周围有普遍的共识，很多人点头(甚至来自艾伦)，林挺在共享代码基础上的合作是必不可少的。时间不应该浪费在分号和缩进的代码审查上；它们应该是关于意图和架构的。

现在，代码质量和代码风格是有区别的，质量侧重于代码最佳实践，而风格侧重于…用分号之类的东西对代码进行样式化。举例来说，你可以将这些工作分配给 JSCS 和 T2，但林挺世界目前的宠儿是 T4 的 ESLint T5。

对于 React，我使用了 Airbnb 的配置，它使用[这个](https://github.com/yannickcr/eslint-plugin-react)作为它们的 React 位。把这个贴在你的**后测**脚本里，像过时一样合并简历。

## 用过的箱子

Sally Static 说，“我不会对一个静态站点使用 React，没有真正的交互，我从 [Jekyll](https://jekyllrb.com/) 那里得到我需要的一切”。

你说，“你试过[盖茨比](https://github.com/gatsbyjs/gatsby)吗？你确定这辈子不要直播重装了？”。

有人可能会说，对所有事情都使用 React 有些矫枉过正，如果你不需要通过 42kb 的 JS 进行交互和 VDOM，你就不应该使用它。然而…React 不仅仅是关于 VDOM，它是关于可测试风格的乐高积木。如果你做的事情稍微有点复杂，并且你不介意写一点 JS，我建议你使用 React*。

*或任何其他具有组件理念的库，但本文是关于 React 的优点；-)

## 开始的结尾

React 提供了一个庞大的社区和生态系统来补充单一责任库，这意味着您可以将一个组件放入您现有的站点，这对于一个庞大的框架来说是不可能的，或者从头开始编写一个完整的应用程序。

React 已经接管了世界 <sup>1</sup> ，WordPress 正在进行所有 React <sup>2</sup> ，你必须使用 React <sup>3</sup> 。如果您正在寻找一个可靠的、非专有的、能做好一件事的组件库，那么希望这篇文章已经为您提供了足够的下个月到 google/sitepoint 的链接和单词。

这就像在 90 年代用全页面刷新(尽管是优化的客户端)、内联样式(尽管不是必需的)和内联事件(尽管是一个[根事件](https://www.sitepoint.com/video-understanding-react-events/))…和“你的 JS 中的 HTML”来编码一样，但这并没有什么错 <sup>4</sup> 。

1.  它没有
2.  现在还不是……
3.  你没有，但这是一个好主意；-)
4.  90 年代有很多错误，这个结论使用了自由创作许可证

## 分享这篇文章