# 如何用 Insphpect 确保灵活、可重用的 PHP 代码

> 原文:[https://www . site point . com/how-to-确保-灵活-可重用-PHP-code-with-inshpect/](https://www.sitepoint.com/how-to-ensure-flexible-reusable-php-code-with-insphpect/)

inshpect 是我写的一个工具，是我博士项目的一部分。它扫描代码，寻找阻碍代码可重用性和灵活性的面向对象编程技术。

## 为什么？

让我从两个平凡的观察开始:

1.  业务需求会随着时间而变化。
2.  程序员不是千里眼。

新产品发布、紧急锁定法规、拓展新市场、经济因素、更新数据保护法:商业软件需要更新的潜在原因很多。

从这两个观察中，我们可以推断出程序员知道他们编写的代码将会改变，但不知道这些改变会是什么或何时发生。

以一种易于改编的方式编写代码是一项需要多年才能掌握的技能。

您可能已经熟悉了那些反复困扰您的编程实践。编程新手很快意识到全局变量带来的麻烦比它们的价值更大，曾经非常流行的单例模式在过去的十年里已经成为一个肮脏的词汇。

如何编写应用程序对适应新需求的难易程度有很大影响。随着您职业生涯的进展，您会学到使代码适应更容易的技术。一旦你掌握了面向对象编程的基础，你会想没有它你会怎样！

如果你让十个开发者开发软件，给定相同的需求，你会得到十个不同的解决方案。其中一些解决方案不可避免地会比其他方案更好。

考虑瓶子里的船和乐高模型船。两者都是模型船，但是在瓶子里改变船上的帆是非常困难的，并且重复使用零件几乎是不可能的。然而，对于乐高船，你可以很容易地更换船帆或使用相同的组件来建造模型火箭、房子或汽车。

某些编程技术导致*瓶子里的船*方法，并使你的代码难以改变和适应。

## 检查

Insphpect 是一个工具，它扫描你的代码，寻找导致这种瓶中船设计的编程实践。

它根据代码的灵活程度对代码进行分级，并突出显示灵活性可以改进的地方。

### Insphpect 寻找的是什么？

目前，Insphpect 查找以下内容:

*   [紧耦合](https://insphpect.com/traits/tight-coupling)
*   硬编码配置
*   一个
*   定型剂注射
*   在构造函数中使用`new`关键字
*   服务定位器
*   遗产
*   静态方法
*   全球状态
*   具有多个角色的文件(例如，定义一个类并运行一些代码)

如果它检测到任何它认为不灵活的地方，它会突出显示代码，解释为什么它会突出显示问题，然后以 0-100 分(100 分表示没有检测到问题)对整个项目和单个类进行评分。作为概念证明，对于某些检测，它能够自动生成一个补丁文件，重写代码以完全消除不灵活性。

[在这里看一份样本报告](https://insphpect.com/report/5e63a943a8da7)。

Insphpect 目前处于测试阶段，如果您能查看它并在网站的“给出您的反馈”部分完成调查，这将对我的研究进展有很大帮助。

### 背景

然而，那些不好的做法真的不好吗？

这是背景研究中较为困难的部分之一，你可以在[inshpect 网站](https://insphpect.com/background)上详细了解这是如何完成的。

然而，这可以总结为:

*   每个不良实践的观点是从每个实践的 100 个作者那里收集的。
*   作者对这种做法的看法被分为 1-5 级。
*   基于临床试验使用的 Jadad 评分，作者的方法严谨性被分为 1-7 级。

然后这些被绘制成如下图:

![Singleton pattern results](../Images/d91e40c1e7e3f71440f6e42ddc2e5e29.png)

每条水平线代表一篇文章，每篇文章的左边(橙色)条是从 5-不惜一切代价避免这种做法(最左边)-到 1-相对于备选方案更喜欢这种做法的建议。

每篇文章的右边(蓝色)条是 Jadad 风格的分数，用来衡量分析的严谨性。7 分意味着文章描述了实践、提供了代码示例、讨论了备选方法、提供了同类代码示例、讨论了每种方法的优缺点并对应该使用哪种方法提出了建议。

在上面的单例案例中，作者比较了单例方法和其他方法，讨论了利弊，等等。，更有可能建议使用替代方法。

## 游戏攻略

目前，Insphpect 允许通过 Git 存储库 URL 或 ZIP 文件上传代码。

因此，不去指出别人工作中的缺陷，让我们来看看我自己的一个项目，看看它确定了什么。

我们将使用[https://github.com/Level-2/Transphporm](https://github.com/Level-2/Transphporm)作为一个示例项目。

这是一个很好的例子，因为它在另一个代码质量工具[审查员](https://scrutinizer-ci.com/g/Level-2/Transphporm/)上有很高的分数。

首先，在主页顶部的文本框中输入 git URL `https://github.com/Level-2/Transphporm`，然后点击“Go”。这将需要几秒到几分钟的时间，具体取决于项目的大小，并将生成如下所示的报告:

![Transphporm Report](../Images/01f2b8ab9b9c0a10286bb48c725432da.png)

进入报告页面后，您会在顶部看到一个总结，总分为 100 分，100 分为非常好，0 分为非常差。

在总结下面，你会看到项目中所有班级的列表，每个班级都有自己的分数。

不要担心你的代码没有得到满分。不太可能。记住，Insphpect 是一个识别代码灵活性的工具。代码的某些部分(比如入口点)没有保证灵活性。

对于 Transphporm，它突出了七个类中的问题。

让我们来看看其中的一些。向下滚动到`Transphporm\Parser\CssToXpath`并点击链接。您将看到该特定课程的分数以及已确定的问题列表。

在本例中，它标识了一个静态变量和一个静态方法。单击其中一条红线将会显示该行被标记原因的解释。

例如，点击第 12 行将给出为什么静态变量不如实例变量灵活的解释。

![Single class report](../Images/9771dcf7b4106f38221c33b9829c65ab.png)

尽管在[报告](https://insphpect.com/report/class/5e63a8f479b6d/Transphporm%5CParser%5CCssToXpath)中有关于静态属性引起的问题的更深入的解释，但是作为一个快速复习，静态变量有一个在类的所有实例中共享的值。

这在本质上不如实例变量灵活，因为使用实例变量允许每个实例有不同的值。

例如，考虑以下情况:

```
class User {
    public static $db;
    public $id;
    public $name;
    public $email;

    public function save() {
        $stmt = self::$db->prepare('REPLACE INTO user (id, name, email) VALUES (:id, :name, :email)');

        $stmt->execute([
            'id' => $this->id,
            'name' => $this->name.
            'email' => $this->email
        ]);
    }
} 
```

因为`$db`是静态的，这个类的每个实例共享同一个`$db`实例，记录将总是被插入到同一个数据库中。

虽然这听起来很合理，但让我给你一个真实的例子。

### 在现实世界中

我们的一个客户是一家招聘机构。大约两年后，我们开发了他们的网站，他们接管了另一个小公司。他们希望保留第二家公司的网站和品牌，因为它在他们所处的利基市场非常有名。

我们的客户问了我们以下问题:

> 在第二家公司的网站上，您可以在添加工作时添加一个复选框，同时将该工作添加到我们的数据库中，这样查看我们网站的人也可以看到该工作，反之亦然。

一个相当简单的请求。在两个不同的数据库中运行插入查询。

但是因为网站使用了一个静态的全局数据库实例，这是不必要的困难！

该站点的开发人员编写代码时确信只需要一个数据库连接。他们错了。

请记住，你不是千里眼，也不可能预测未来可能需要什么样的灵活性。

### 解决方案

正如 Insphpect 所建议的，解决这个问题的方法是使用实例变量:

```
class User {
    private $db;
    public $id;
    public $name;
    public $email;

    public function __construct(\PDO $db) {
        $this->db = $db;
    }

    public function save() {
        $stmt = self::$db->prepare('REPLACE INTO user (id, name, email) VALUES (:id, :name, :email)');

        $stmt->execute([
            'id' => $this->id,
            'name' => $this->name.
            'email' => $this->email
        ]);
    }
} 
```

现在一个`User`实例可以用于不同的数据库实例:

```
new User($database1);
new User($database2); 
```

对于`Transphporm\Parser\CssToXpath`,我们可以做同样的事情，删除静态变量，并考虑让它成为实例变量而不是静态变量。

### 在构造函数中使用 new

再来看看另外一个类:`Transphporm\Builder`。

![Builder class report](../Images/bce6b54fd05dbcb58c17095d825cfa06.png)

这个得了零分，相当差。仔细检查报告，Insphpect 已经三次发现同一个问题:在构造函数中使用`new`关键字。

[谷歌编程蔻驰·米斯科·赫维里很好地解释了为什么这是一种糟糕的编程实践](http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/)，但这里有一个来自 Insphpect 输出的简单例子:

```
class Car {
    private $engine;

    public function __construct() {
        $this->engine = new PetrolEngine();
    }
} 
```

这里，每当创建一个`Car`的实例时，就会创建一个`PetrolEngine`的实例。这使得它非常不灵活，因为没有办法用不同的引擎类型建造一辆`Car`。这个系统中建模的每辆车都必须有一个`PetrolEngine`。

相反，我们可以使用依赖注入:

```
class Car {
    private $engine;

    public function __construct($engine) {
        $this->engine = $engine;
    }
} 
```

可以使用`PetrolEngine`、`DieselEngine`、`ElectricEngine`、`JetEngine`或项目中存在的任何其他引擎类型的实例来创建不同的汽车。

要修复`Transphporm\Builder`中的这个错误，所有当前具有硬编码类名的变量都应该使用构造函数参数。

Insphpect 还发现了其他问题，但是您可以自己尝试一下，看看您的项目进展如何。

## 在幕后

你可能想知道分数是如何计算的，为什么这门课得了零分。目前，一旦扫描了更多的项目并提供了更多的反馈，权重可能会发生变化。

分数的设计是为了将一个项目/课程与另一个项目/课程进行比较。

总的项目分数只是项目中所有课程的平均值。这是因为在 1000 个类中有两个问题的项目比在两个类中有两个问题的项目要好得多。

每一个不好的实践都是基于它是阻碍了整个类的灵活性，还是仅仅阻碍了一个方法的灵活性。

## 结论

Insphpect 可以用来识别代码中使将来的修改变得更加困难的区域，并且它提供了如何以更灵活的方式编写代码的建议。请记住，你不是千里眼，没有办法知道你的代码将需要如何改变！

inshpect 目前正在进行中，使用它(并完成调查)的人越多，它就会变得越好。

你的项目或最喜欢的库得分如何？请务必完成调查，因为它将为我的博士项目提供有价值的数据，并帮助工具改进！

## 分享这篇文章