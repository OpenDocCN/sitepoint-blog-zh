# 建筑质量角形 1.5 组件指南

> 原文：<https://www.sitepoint.com/building-angular-1-5-components/>

*这篇文章由[马克·布朗](https://www.sitepoint.com/author/mbrown)和[于尔根·范·德·摩尔](https://www.sitepoint.com/author/jvandemoere/)进行了同行评审。感谢 SitePoint 的所有同行评审员使 SitePoint 的内容尽可能做到最好！*

![A scientist with various flasks and jars](img/179e84c2c93a766eedb28aefa1a4d0ff.png)

* * *

**2017.01.10** :文章更新，明确了单向绑定部分，增加了一次性绑定信息。

* * *

在 Angular 1 中，组件是一种机制，允许您创建自己的定制 HTML 元素。这在过去的 Angular 指令中是可能的，但是组件是建立在 Angular 的各种改进之上的，并在它们的构建和设计中执行最佳实践。

在本文中，我们将深入探讨组件的设计，以及如何在您的应用程序中使用它们。如果你还没有开始使用 Angular 1 中的组件，你可以在我们最近的教程之一中阅读它们的语法和设计。我的目标是概述一些可以提高应用程序质量的最佳实践。

还应该注意的是，Angular 2 的许多最佳实践通过新的组件 API 被引入 Angular 1，允许您构建以后更容易重构的应用程序。Angular 2 影响了我们思考和设计 Angular 1 元件的方式，但仍有许多明显的差异。Angular 1 仍然是构建应用程序的一个非常强大的工具，所以我相信，即使您不打算或不准备迁移到 Angular 2，投资用组件改进您的应用程序也是值得的。

## 什么是好的组件？

组件的设计应该考虑到许多关键特征，以使它们成为应用程序的强大构件。我们将更详细地研究其中的每一个，但是这里是组件应该遵守的主要概念。

*   **隔离**–组件的逻辑应该被封装以保持内部和私有。这有助于减少组件之间的耦合。
*   聚焦–组件应该作为一个单一的单元来完成一个主要的任务，这使得它们更容易推理，通常更容易重用。
*   **单向绑定**–如果可能，组件应该利用单向绑定来减少摘要周期的负载。
*   **使用生命周期事件**–组件的生命周期以实例化开始，以从页面中删除结束。最好是挂钩这些事件，以便随着时间的推移来维护组件。
*   **定义良好的 API**–组件应该以一致的方式接受配置作为属性，因此很容易知道如何使用它们。
*   **发出事件**–为了与其他组件通信，它们应该发出具有适当名称和数据的事件。

现在让我们从为什么以及如何将组件与应用程序的其余部分隔离和封装开始。

## 组件应该被隔离

Angular 1 功能的发展是为了支持隔离和封装的组件，这是有道理的。一些早期的应用程序高度结合了`$scope`和嵌套控制器的使用。最初 Angular 没有提供解决方案，但现在它提供了。

好的组件不会暴露它们的内部逻辑。由于它们的设计方式，这很容易实现。但是，除非绝对必要，比如发射/广播事件，否则不要使用`$scope`来滥用组件。

## 组件应该是集中的

组件应该承担单一的角色。这对于可测试性、可重用性和简单性非常重要。最好是制造额外的组件，而不是让单个组件过载。这并不意味着你不会有更大或更复杂的组件，它只是意味着每个组件都应该专注于它的主要工作。

我根据组件在应用程序中的角色将组件分为四个主要组，以帮助您思考如何设计组件。构建这些不同类型的组件没有不同的语法，重要的是要考虑组件所扮演的特定角色。

这些类型是基于我 5 年多的角度经验。您可以选择稍微不同的组织方式，但是基本的概念是确保您的组件有一个清晰的角色。

### 应用组件

只能有一个应用程序组件充当应用程序的根。您可以把它想象成 web 应用程序的主体中只有一个组件，所有其他的逻辑都是通过它加载的。

```
<body>
  <app></app>
</body> 
```

这主要是为 Angular 2 设计奇偶校验而推荐的，因此如果您愿意，将来某一天会更容易迁移。通过将应用程序的所有根内容转移到一个单独的组件中，而不是将其中一些放在`index.html`文件中，这也有助于测试。app 组件还为您提供了一个进行应用实例化的地方，这样您就不必在 app `run`方法中进行实例化，从而增强可测试性并减少对`$rootScope`的依赖。

这个组件应该尽可能简单。如果可能的话，它可能只包含一个模板，而不包含任何绑定或控制器。然而，它不能代替`ng-app`或者引导你的应用程序的需要。

### 路由组件

过去，我们在 ui-router 状态(或 [ngRoute](https://docs.angularjs.org/api/ngRoute) route)下链接控制器和模板。现在，可以将路由直接链接到组件，因此组件仍然是控制器和模板配对的地方，但也具有可路由的优点。

例如，对于 ui-router，这就是我们链接模板和控制器的方式。

```
$stateProvider.state('mystate', {
  url: '/',
  templateUrl: 'views/mystate.html',
  controller: MyStateController
}); 
```

现在，您可以将 url 直接链接到组件。

```
$stateProvider.state('mystate', {
  url: '/',
  component: 'mystate'
}); 
```

这些组件可以绑定来自路由参数的数据(比如一个条目 id)，它们的作用是集中设置路由以加载所需的其他组件。定义路由的这个看似微小的变化实际上对于 Angular 2 迁移能力非常重要，而且对于 Angular 1.5 在组件级别更好地封装模板和控制器也很重要。

> Angular 1 实际上有两个路由器模块，ngRoute 和 ngComponentRouter。只有 ngComponentRouter 支持组件，但也不推荐使用。我认为最好的选择是 ui-router。

### 有状态组件

您将为应用程序构建的大多数独特组件都是有状态的。这是您实际放置应用程序业务逻辑、发出 HTTP 请求、处理表单和其他有状态任务的地方。这些组件可能是您的应用程序所特有的，它们侧重于通过可视化表示来维护数据。

假设您有一个控制器，它加载用户的配置文件数据以供显示，并有一个相应的模板(此处未显示)在一个指令中链接在一起。这个片段可能是完成这项工作的最基本的控制器。

```
.controller('ProfileCtrl', function ($scope, $http) {
  $http.get('/api/profile').then(function (data) {
    $scope.profile = data;
  });
})
.directive('profile', function() {
  return {
    templateUrl: 'views/profile.html',
    controller: 'ProfileCtrl'
  }
}) 
```

有了组件，你可以比以前设计得更好。理想情况下，您也可以使用服务，而不是直接在控制器中使用`$http`。

```
.component('profile', {
  templateUrl: 'views/profile.html',
  controller: function($http) {
    var vm = this;
    // Called when component is ready, see below
    vm.$onInit = function() {
      $http.get('/api/profile').then(function (data) {
        vm.profile = data;
      });
    };
  }
}) 
```

现在您有了一个加载自己数据的组件，从而使它有状态。这些类型的组件类似于路由组件，只是它们可能不链接到单个路由就可以使用。

有状态组件将使用其他(无状态)组件来实际呈现 UI。此外，您仍然希望使用服务，而不是将数据访问逻辑直接放在控制器中。

### 无状态组件

无状态组件专注于呈现而不管理业务逻辑，并且不需要对任何特定的应用程序是唯一的。例如，大多数用于 UI 元素的组件(如表单控件、卡片等)也不处理逻辑，如加载数据或保存表单。它们旨在高度模块化、可重用和隔离。

无状态组件可能不需要控制器，如果它只是显示数据或控制模板中的一切。它们将接受来自有状态组件的输入。这个例子从有状态组件(上面的`profile`例子)获取一个值，并显示一个化身。

```
.component('avatar', {
  template: '<img ng-src="http://example.cimg/{{vm.username}}.png" />',
  bindings: {
    username: '<'
  },
  controllerAs: 'vm'
}) 
```

要使用它，有状态组件将通过属性传递用户名，如 so `<avatar username="vm.profile.username">`。

您使用的大多数库都是无状态组件(或许还有服务)的集合。他们当然可以接受配置来修改他们的行为，但他们并不意味着要负责自己之外的逻辑。

## 组件应该使用单向绑定

这不是组件的新特性，但是在组件中利用它通常是明智的。单向绑定的目的是避免在摘要循环中加载更多的工作，这是影响应用程序性能的一个主要因素。现在，数据可以流入组件，而不必查看组件外部(这导致了现在存在的一些耦合问题)，组件可以简单地呈现输入本身。这种设计也适用于 Angular 2，有助于将来的迁移。

在这个例子中，`title`属性只根据提供的初始值绑定到组件一次。如果某个外部参与者改变了`title`,它不会在组件中得到反映。表示单向绑定的语法是使用`<`符号。

```
bindings: {
  title: '<'
} 
```

当`title`属性改变时，组件仍然会更新，我们将讨论如何监听`title`属性的改变。建议在任何可以的时候使用单向。

## 组件应该考虑一次性绑定

Angular 还具有一次性绑定数据的能力，因此可以优化摘要周期。本质上，Angular 将等待，直到第一个不是`undefined`的值被提供到绑定中，绑定该值，然后(一旦所有绑定都已解析)从摘要循环中删除相关的观察器。这意味着特定的绑定不会给将来的摘要循环增加任何处理时间。

这是通过将`::`放在绑定表达式前面来实现的。只有当您知道输入绑定在生命周期中不会改变时，这才有意义。在这个例子中，如果`title`是一个单向绑定，它将继续在组件内部更新，但是这里的绑定不会更新，因为我们把它标记为一次性的。

```
<h1>{{::title}}</h1> 
```

## 组件应该使用生命周期事件

您可能已经注意到$onInit 函数是一项新功能。组件有一个带有相应事件的生命周期，您应该使用这些事件来帮助管理组件的某些方面。

### `$onInit()`

组件生命周期的第一步是初始化。该事件在控制器和绑定初始化后运行。您几乎应该总是使用这种方法来进行组件设置或初始化。它将确保所有值在运行前对组件可用。如果您要直接访问控制器中的绑定值，则不能保证这些值对您可用。

```
controller: function() {
  var vm = this;
  console.log(vm.title); // May not yet be available!
  vm.$onInit = function() {
    console.log(vm.title); // Guaranteed to be available!
  }
} 
```

### `$postLink()`

下一步是链接模板中的所有子元素。当组件初始化时，不能保证它也会呈现模板中使用的任何子级。如果您需要以任何方式操作 DOM，这是很重要的。一个重要的警告是，异步加载的模板在该事件触发时可能还没有加载。您可以始终使用模板缓存解决方案来确保模板始终可用。

```
controller: function() {
  var vm = this;
  vm.$postLink = function() {
    // Usually safe to do DOM manipulation
  }
} 
```

### `$onChanges()`

当组件处于活动状态时，它可能需要对输入值的变化做出反应。单向绑定仍然会更新您的组件，但是当输入改变时，我们有一个新的`$onChanges`事件绑定来监听。

对于这个示例，假设有一个产品标题和描述提供给一个组件。您可以检测到如下所示的变化。您可以查看传递给函数的对象，该函数有一个映射到可用绑定的对象，该绑定具有当前值和先前值。

```
bindings: {
  title: '<'
},
controller: function() {
  var vm = this;
  vm.$onChanges = function($event) {
    console.log($event.title.currentValue); // Get updated value
    console.log($event.title.previousValue); // Get previous value
  }
} 
```

### `$onDestroy()`

最后一个阶段是从页面中删除组件。该事件正好在控制器及其范围被销毁之前运行。清理组件可能创建的或占用内存的任何东西是很重要的，比如事件侦听器、观察器或其他 DOM 元素。

```
controller: function() {
  var vm = this;
  vm.$onDestroy = function() {
    // Reset or remove any event listeners or watchers
  }
} 
```

## 组件应该有一个定义良好的 API

要用一组数据配置和初始化组件，组件应该使用绑定来接受这些值。这有时被认为是组件 API，它只是描述组件接受输入方式的一种不同方式。

这里的挑战是给绑定一个简洁而清晰的名字。有时开发人员试图缩短名称以真正简洁，但这对组件的使用是危险的。假设我们有一个接受股票代码作为输入的组件，这两个组件哪个更好？

```
bindings: {
  smb: '<',
  symbol: '<'
} 
```

希望你认为`symbol`更好。有时开发人员也喜欢给组件和绑定加上前缀，以避免名称冲突。给组件加前缀是明智的，就像`md-toolbar`是一个素材工具栏，但是给所有绑定加前缀会变得冗长，应该避免。

## 组件应该发出事件

为了与其他组件通信，组件应该发出自定义事件。使用服务和双向数据绑定在组件之间同步数据的例子很多，但事件是更好的设计选择。事件作为一种与页面交流的方式要高效得多(也是 JavaScript 语言的基础部分，以及它在 Angular 2 中的工作方式，这不是巧合)。

Angular 中的事件可以使用`$emit`(沿范围树向上)或`$broadcast`(沿范围树向下)。这里有一个快速的实例。

```
controller: function($scope, $rootScope) {
  var vm = this;
  vm.$onInit = function() {
    // Emits an event up to parents
    $scope.$emit('componentOnInit');
  };
  vm.$onDestroy = function() {
    // Emits an down child tree, from root
    $rootScope.$broadcast('componentOnDestroy');
  };
} 
```

在两种主要情况下，您需要在组件之间进行通信:在您知道的组件和您不知道的组件之间。为了说明不同之处，让我们假设我们有一组帮助管理页面上的选项卡的组件，以及一个具有到相应帮助页面的链接的工具栏。

```
<my-toolbar></my-toolbar>
<my-tabs>
  <my-tab title="Description"></my-tab>
  <my-tab title="Reviews"></my-tab>
  <my-tab title="Support"></my-tab>
</my-tabs> 
```

在这种情况下，`my-tabs`和`my-tab`组件可能知道彼此，因为它们一起工作来创建一组三个不同的选项卡。然而，`my-toolbar`的成分不在他们的意识范围之内。

每当选择一个不同的选项卡时(在`my-tab`组件实例上可能是一个事件)，`my-tabs`组件需要知道，这样它就可以调整选项卡的显示来显示该实例。`my-tab`组件可以向父`my-tabs`组件发出一个事件。这种类型的通信类似于两个组件之间的内部通信，这两个组件一起工作以形成单一功能(选项卡式界面)。

但是，如果`my-toolbar`想知道当前选择了哪个选项卡，以便根据可见的内容更改帮助按钮，该怎么办呢？事件`my-tab`永远不会到达`my-toolbar`，因为它不是父事件。所以另一个选择是使用`$rootScope`沿着整个组件树向下发送事件，这允许任何组件监听和反应。这里潜在的问题是，您的事件现在到达每个控制器，如果另一个组件使用相同的事件名称，您可能会触发意想不到的效果。

决定这些方法中的哪一个对您的用例有意义，但是任何时候另一个组件可能需要知道一个事件，您可能想要使用第二个选项来发出到整个组件树。

## 摘要

Angular 1 应用程序现在可以用组件编写，这改变了我们编写应用程序的最佳实践和本质。这是为了变得更好，但是仅仅简单地使用一个组件并不一定会使它变得比以前更好。以下是在构建 Angular 1 组件时需要记住的关键事项。

*   孤立你的逻辑。将尽可能多的组件逻辑放在内部，远离应用程序的其他方面，以确保一致性和质量。
*   保持组件简单，专注于单一角色。它们可能是复杂的组件，但是单个组件的各种任务应该作为一个单元在逻辑上连接起来。
*   **使用生命周期事件。**通过与组件生命周期挂钩，您可以确保数据在正确的时间准备好，并且您可以清理数据。
*   **使用单向和一次性绑定。**在可能的情况下，单向绑定更有效率，促进良好的设计，而一次性绑定可以加快你的应用程序。您可以随时使用`$onChanges`生命周期事件来观察变更。
*   **利用事件进行交流。**组件可以使用自定义事件进行通信，这符合 Angular 2 的功能和更好的设计。
*   拥有定义良好的 API。确保你的组件命名清晰，易于理解。

您是否在 Angular 1.x 应用中使用组件？或者，你打算等到你跳转到角度 2？我很想在下面的评论中听到你的经历。

## 分享这篇文章