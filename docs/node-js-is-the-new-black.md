# Node.js 是新的黑色

> 原文：<https://www.sitepoint.com/node-js-is-the-new-black/>

如果你在过去的一年里一直在关注关于 web 技术的新闻，你很可能至少一两次听说过 node.js 这个名字。接下来发生的事情大概是这样的:你问:“什么事？”有人(或 Google)告诉你，这是一种用 JavaScript 编写 web 服务器的方法。如果这没有把你吓跑，你可能会问，“你为什么要用它？”答案可能是 it 利用非阻塞、事件驱动的 IO 在长轮询或基于 comet 的应用程序中实现高并发性。

从那时起你不再问问题。我不怪你。为了帮助打破行话之墙，我尝试解释 node.js 是什么以及为什么你应该关注它。

事情是这样的，一直都是这样的:浏览器向网站发送请求。该站点的服务器接收请求，跟踪所请求的文件，根据需要执行任何数据库查询，并向浏览器发送响应。在传统的 web 服务器中，比如 Apache，每个请求都会导致服务器创建一个新的系统进程来处理该请求。

然后是 Ajax。我们不再每次都请求一个全新的页面，而是只请求我们真正想要的信息。好吧，这是个进步。

但是现在想想你会如何着手建立一个像 [FriendFeed](http://friendfeed.com/) 这样的服务，每个用户的订阅都是实时更新的，一直如此。唯一可能的方法是每个用户一直都有一个到服务器的活动连接。目前最简单的方法是通过长轮询。

长轮询本质上欺骗 HTTP 像一个持久连接:*一旦页面加载*，它就向服务器发出一个 Ajax 请求，*，即使页面不想要任何特别的东西*。但是，与普通的 Ajax 请求不同，服务器不会立即响应。它只是等待，只有当它有新的东西希望浏览器显示时，它才会发出响应。例如，只要你的一个朋友添加了一个新帖子，服务器就会返回响应，告诉浏览器更新它的显示。一旦浏览器收到响应，它就返回另一个请求。这样，浏览器总是等待服务器端发生新的事件。

现在想想这对 Apache 这样的传统 web 服务器意味着什么。对于连接到网站的每个用户，您的服务器必须保持连接打开。每个连接都需要一个进程，每个进程的大部分时间要么处于空闲状态(消耗内存)，要么等待数据库查询完成。这意味着很难在不接近停顿和耗尽所有资源的情况下扩展到大量的连接。

那么解决办法是什么呢？这里是以前的一些术语发挥作用的地方:特别是**非阻塞**和**事件驱动**。这些术语在上下文中的含义并没有你担心的那么复杂。把非阻塞服务器想象成一个循环:它只是不停地循环。一个请求进来，循环抓住它，把它传递给其他进程(比如数据库查询)，建立一个回调，继续循环，为下一个请求做好准备。它不会只是坐在那里，等待数据库返回所请求的信息。

如果数据库查询返回——好的，我们将以同样的方式处理:向客户机返回一个响应，并继续循环。理论上，您可以等待多少个数据库查询，或者有多少个客户端有打开的请求是没有限制的，因为您不需要花费任何时间来等待它们。你在它们自己的时间里处理它们，这就是事件驱动的含义:服务器只在事件发生时做出反应。那可能是一个请求，一个正在加载的文件，或者一个正在执行的查询——这真的无关紧要。

FriendFeed 使用了一个用 Python 编写的非阻塞框架，名为 [Tornado](http://www.tornadoweb.org/) ，来做这件事。nginx web 服务器也以这种方式运行。然而，Node.js 有一张王牌:因为它使用 JavaScript——运行在谷歌的疯狂快速的 V8 引擎上——它从来不需要担心它对另一段代码的请求是否会导致循环阻塞。原因是 JavaScript 本质上是事件驱动的。想想看:当你为浏览器编写 JavaScript 时，你只是附加了事件处理程序和回调函数。这就是语言的设计方式。

Node.js 仍处于起步阶段，所以如果你想基于它编写一个应用程序，你需要做一些相当低级的编码。但是随着下一代浏览器中 [WebSockets](http://dev.w3.org/html5/websockets/) 的即将到来(完全消除了长时间轮询的需要)，这种技术只会在网络上变得更加重要。我希望我已经给了你动力，让你开始思考这些概念。

## 分享这篇文章