# 授权您的 Rails 应用程序

> 原文:[https://www . site point . com/authorization-your-rails-app-with-authority/](https://www.sitepoint.com/authorizing-your-rails-app-with-authority/)

假设您正在编写一个 Rails 应用程序来组织会议。一旦你知道应用程序能做什么，你就要开始决定谁能做什么。谁可以:

*   决定谁将在大会上发言？
*   编辑演示者时间表？
*   上传演示幻灯片？
*   评论一下那些幻灯片？
*   创建音乐播放列表？
*   制作一个个人日程表，看看哪些讲座？

所有这些问题都是关于授权的:“这个用户被授权做什么？”显然，让这个逻辑正确是很重要的:它需要是正确的，它需要是一致的。如果这种逻辑被组合在一起，而不是分散在你的应用程序中，那就更好了。

我刚刚发布了一个 gem 来干净利落地解决这个问题。这叫权威(见 [Github](http://github.com/nathanl/authority) 和 [Rubygems](http://rubygems.org/gems/authority) )。

## 保护您的模型

在我向您展示权威是如何工作的之前，让我们来谈谈一些一般的想法。

在你的 Rails 应用程序中，权限的概念集中在你的模型上；在上面的例子中，这些可能是演示者、评论、播放列表等。在某些情况下，问题非常简单:一个与会者不能对任何演示者做任何更改，句号。你可以认为这是一个“类级”规则:`Presenter`模型对于任何不是会议组织者的人来说都是只读的。如果一个与会者试图访问页面来编辑一个演示者的个人资料，我们不需要问任何关于这个特定演示者的问题就可以知道这个操作是不允许的。

在其他情况下，问题更加微妙:与会者可以编辑自己的个人日程，但不能编辑其他人的日程。您可以把它看作是一个“实例级”规则:要知道一个会议与会者是否可以编辑日程安排，您必须查看该日程安排实例并了解它属于谁。

使用 Authority，您可以使用类方法，如`def self.updatable_by?(user)`来设置类级别的规则，使用实例方法，如`def deletable_by?(user)`，来设置实例级别的规则。

但是那些方法应该写在哪里呢？

## 保持你的权限干燥

显然，不同的模型有不同的规则，所以您可能认为授权方法应该在模型本身上进行。

但是很可能你的一些模型共享规则:任何可以编辑`Presenter`的人也可以编辑`PresenterSchedule`。如果这是真的，最好保持原样:让`Presenter`模型和`PresenterSchedule`模型使用相同的授权逻辑。

Authority 通过让模型将任何授权问题委托给指定的授权者类来实现这一点。具有相同规则的模型可以指向相同的授权人。

## 一个例子

从 gem 的自述文件中取一个简单的例子，假设你们两个在应用程序中有不同类别的资源:一些用于普通用户，一些用于管理员。使用 Authority，您将有两个授权者类。你可以称它们为`BasicAuthorizer`和`AdminAuthorizer`。

您可以像这样对模型进行分组: