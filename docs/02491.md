# 编写自文档化 JavaScript 的 15 种方法

> 原文：<https://www.sitepoint.com/self-documenting-javascript/>

*这篇文章由[蒂姆·塞韦里恩](https://www.sitepoint.com/author/tseverien/)和[马克·布朗](https://www.sitepoint.com/author/mbrown/)进行了同行评审。感谢 SitePoint 的所有同行评审员使 SitePoint 的内容尽可能做到最好！*

在代码中找到一个完全不合时宜、毫无用处的注释不是很有趣吗？

这是一个容易犯的错误:你修改了一些代码，却忘了删除或更新注释。一个不好的注释不会破坏你的代码，但是想象一下调试时会发生什么。你看了评论。它说的是一回事，而代码做的是另一回事。你很可能会浪费时间去弄清楚它，在最坏的情况下，它甚至会误导你！

但是编写没有注释的代码是不可取的。在我超过 15 年的编程经验中，我从未见过注释完全没有必要的代码库。

然而，有办法*减少*对注释的需求。我们可以利用某些编码技术来阐明我们的代码，简单地利用编程语言的特性。

这不仅有助于我们的代码更容易理解，也有助于改善程序的整体设计！

这种类型的代码通常被称为*自文档*。现在让我向您展示如何使用这种方法进行编码。虽然我在这里展示的例子是用 JavaScript 编写的，但是您也可以将大多数技术应用到其他语言中。

## 技术概述

一些程序员将注释作为自文档代码的一部分。在本文中，我们将只关注代码。评论很重要，但是它们是一个需要单独讨论的大话题。

我们可以将自文档化代码的技术分为三大类:

*   **结构**，其中代码或目录的结构用于阐明目的
*   **命名相关的**，如函数或变量命名
*   **语法相关**，我们利用(或避免使用)语言的特性来阐明代码。

其中许多在理论上很简单。挑战来自于知道什么时候使用什么技术。当我们处理每一个问题时，我会给你看一些实际的例子。

## 结构的

首先，我们来看结构类。结构变化指的是为了提高清晰度而移动代码。

### 将代码移入函数

这与“提取函数”重构是一样的——意味着我们将现有的代码移动到一个新的函数中:我们将代码“提取”到一个新的函数中。

例如，试着猜猜下面一行是什么意思:

```
var width = (value - 0.5) * 16; 
```

不是很清楚；这里的注释可能非常有用。或者，我们可以提取一个函数，使其自我记录:

```
var width = emToPixels(value);

function emToPixels(ems) {
    return (ems - 0.5) * 16;
} 
```

唯一的变化是我把计算移到了一个函数中。函数的名字描述了它的功能，所以代码不再需要澄清。作为一个额外的好处，我们现在有一个有用的助手函数，您可以在其他地方使用，所以这个方法也有助于减少重复。

### 用函数替换条件表达式

如果没有注释，带有多个操作数的 If 子句通常很难理解。我们可以应用与上面类似的方法来阐明它们:

```
if(!el.offsetWidth || !el.offsetHeight) {
} 
```

上述条件的目的是什么？

```
function isVisible(el) {
    return el.offsetWidth && el.offsetHeight;
}

if(!isVisible(el)) {
} 
```

同样，我们将代码转移到一个函数中，代码立即变得更容易理解。

### 用变量替换表达式

用变量替换某些东西类似于将代码移入函数，但我们只是使用变量，而不是函数。

让我们再来看看 if 从句的例子:

```
if(!el.offsetWidth || !el.offsetHeight) {
} 
```

除了提取一个函数，我们还可以通过引入一个变量来阐明这一点:

```
var isVisible = el.offsetWidth && el.offsetHeight;
if(!isVisible) {
} 
```

这可能是比提取函数更好的选择—例如，当您想要阐明的逻辑非常特定于仅在一个地方使用的某个算法时。

这种方法最常见的用途是数学表达式:

```
return a * b + (c / d); 
```

我们可以通过拆分计算来澄清上述问题:

```
var multiplier = a * b;
var divisor = c / d;
return multiplier + divisor; 
```

因为我数学很差，想象一下上面的例子有一些有意义的算法。无论如何，关键是您可以将复杂的表达式移动到变量中，为难以理解的代码增加意义。

### 类和模块接口

类或模块的接口(即公共方法和属性)可以作为其用法的文档。

让我们看一个例子:

```
class Box {
    setState(state) {
        this.state = state;
    }

    getState() {
        return this.state;
    }
} 
```

这个类也可以包含一些其他的代码。我故意保持这个例子简单，以说明公共接口是如何文档化的

你能告诉我这个类应该如何使用吗？可能需要一点努力，但不是很明显。

这两个函数都有合理的名字:从它们的名字中可以清楚地看出它们做什么。尽管如此，还不清楚应该如何使用它们。最有可能的是，你需要阅读更多的代码或者这个类的文档来解决这个问题。

如果我们把它改成这样会怎么样:

```
class Box {
    open() {
        this.state = 'open';
    }

    close() {
        this.state = 'closed';
    }

    isOpen() {
        return this.state === 'open';
    }
} 
```

看用法容易多了，你不觉得吗？请注意，我们只更改了公共接口；内部表示仍然与`this.state`属性相同。

现在你可以一眼看出`Box`类是如何使用的。这表明，即使第一个版本在函数中有很好的名字，完整的包仍然令人困惑，以及如何，通过这样简单的决定，您可以产生非常大的影响。你总是要考虑大局。

### 代码分组

将代码的不同部分分组也可以作为文档的一种形式。

例如，您应该始终致力于在尽可能接近使用变量的地方声明变量，并尝试将变量的使用分组在一起。

这可以用来表示代码不同部分之间的关系，这样任何人在将来修改代码时都可以更容易地找到他们可能还需要接触的部分。

考虑下面的例子:

```
var foo = 1;

blah()
xyz();

bar(foo);
baz(1337);
quux(foo); 
```

一眼就能看出`foo`用了多少次？与此相比:

```
var foo = 1;
bar(foo);
quux(foo);

blah()
xyz();

baz(1337); 
```

将`foo`的所有用法组合在一起，我们可以很容易地看出代码的哪些部分依赖于它。

### 使用纯函数

纯函数比依赖于状态的函数更容易理解。

什么是纯函数？当用相同的参数调用一个函数时，如果它总是产生相同的输出，那么它很可能是一个所谓的“纯”函数。这意味着函数不应该有任何副作用或者依赖于状态——比如时间、对象属性、Ajax 等等。

这些类型的函数更容易理解，因为影响其输出的任何值都是显式传入的。你不必四处挖掘来弄清楚某样东西是从哪里来的，或者是什么影响了结果，因为这一切都显而易见。

这些类型的函数使得代码更加自文档化的另一个原因是你可以信任它们的输出。不管怎样，函数总是根据你给它的参数返回输出。它也不会影响任何外部的东西，所以你可以相信它不会引起意想不到的副作用。

一个很好的例子就是`document.write()`。有经验的 JS 开发人员知道你不应该使用它，但是许多初学者会被它绊倒。有时它工作得很好，但其他时候，在某些情况下，它可以清除整个页面。说一个副作用！

要更好地了解什么是纯函数，请参阅文章[函数式编程:纯函数](https://www.sitepoint.com/functional-programming-pure-functions/)。

### 目录和文件结构

命名文件或目录时，请遵循项目中使用的相同命名约定。如果项目中没有明确的约定，请遵循您选择的语言标准。

例如，如果你正在添加新的与 <abbr title="user interface">UI</abbr> 相关的代码，在项目中找到相似的功能。如果 UI 相关的代码放在`src/ui/`里，你也应该这么做。

基于您对项目中其他代码片段的了解，这使得查找代码并显示其用途变得更加容易。毕竟所有的 UI 代码都在同一个地方，所以一定是 UI 相关的。

## 命名

有一句关于计算机科学中两个难题的流行名言:

> 计算机科学只有两个硬东西:缓存失效和事物命名。— *菲尔·卡尔顿*

因此，让我们看看如何使用命名的东西，使我们的代码自我记录。

### 重命名功能

函数命名通常并不太难，但是有一些简单的规则可以遵循:

*   避免使用像“处理”或“管理”这样模糊的词:`handleLinks()`、`manageObjects()`。这两个是做什么的？
*   使用主动动词:`cutGrass()`、`sendFile()`——主动执行某事的功能。
*   指明返回值:`getMagicBullet()`，`readFile()`。这不是你可以一直做的事情，但是在有意义的地方是有帮助的。
*   具有强类型的语言也可以使用类型签名来帮助指示返回值。

### 重命名变量

对于变量，这里有两条好的经验法则:

*   指示单位:如果有数字参数，可以包括预期的单位。例如，用`widthPx`而不是`width`来表示值是以像素为单位，而不是其他单位。
*   不要使用快捷键:`a`或`b`是不可接受的名字，除了循环中的计数器。

### 遵循既定的命名约定

尽量在代码中遵循相同的命名约定。例如，如果您有一个特定类型的对象，请将其命名为相同的名称:

```
var element = getElement(); 
```

不要突然决定称之为节点:

```
var node = getElement(); 
```

如果你遵循与代码库中其他地方相同的约定，任何阅读它的人都可以根据它在其他地方的含义对事物的含义做出安全的假设。

### 使用有意义的错误

Undefined 不是对象！

大家的最爱。让我们不要遵循 JavaScript 的例子，让我们确保代码抛出的任何错误都包含有意义的信息。

什么使得错误消息有意义？

*   它应该描述问题是什么
*   如果可能，它应该包括导致错误的任何变量值或其他数据
*   要点:错误应该帮助我们找出哪里出了问题——因此作为函数应该如何工作的文档。

## 句法

与语法相关的自我记录代码的方法可以更具体一些。例如，Ruby 和 Perl 允许你使用各种奇怪的语法技巧，这通常是应该避免的。

让我们来看看 JavaScript 中发生的一些情况。

### 不要使用语法技巧

不要用怪招。这里有一个迷惑人的好方法:

```
imTricky && doMagic(); 
```

它相当于这个看起来更合理的代码:

```
if(imTricky) {
    doMagic();
} 
```

总是倾向于后一种形式。语法技巧不会给任何人带来任何好处。

### 使用命名常量，避免幻值

如果您的代码中有特殊值，如数字或字符串值，请考虑使用常数。即使现在看起来很清楚，但通常情况下，当一两个月后回过头来看时，没有人会知道为什么把那个特定的数字放在那里。

```
const MEANING_OF_LIFE = 42; 
```

(如果你没有使用 ES6，你可以使用一个`var`，它会工作得同样好。)

### 避免布尔标志

布尔标志会使代码难以理解。考虑一下这个:

```
myThing.setData({ x: 1 }, true); 
```

`true`是什么意思？你完全不知道，除非你深究`setData()`的来源并找到答案。

相反，您可以添加另一个函数，或重命名现有函数:

```
myThing.mergeData({ x: 1 }); 
```

现在你可以立即知道发生了什么。

### 利用语言的优势

我们甚至可以使用我们选择的语言的一些特性来更好地传达一些代码背后的意图。

JavaScript 中一个很好的例子是数组迭代方法:

```
var ids = [];
for(var i = 0; i < things.length; i++) {
  ids.push(things[i].id);
} 
```

上面的代码将 id 列表收集到一个新数组中。然而，为了知道这一点，我们需要阅读整个循环体。与使用`map()`进行比较:

```
var ids = things.map(function(thing) {
  return thing.id;
}); 
```

在这种情况下，我们立即知道这产生了一个新的数组，因为这就是`map()`的目的。这可能是有益的，特别是如果你有更复杂的循环逻辑。在 MDN 上有一个其他迭代函数的[列表。](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods)

JavaScript 的另一个例子是`const`关键字。

通常，您会在值应该永远不变的地方声明变量。一个非常常见的例子是用 CommonJS 加载模块:

```
var async = require('async'); 
```

我们可以更清楚地表明永远不改变这一点的意图:

```
const async = require('async'); 
```

作为一个额外的好处，如果有人曾经试图改变这一点，我们现在会得到一个错误。

## 反模式

有了这些方法，你可以做很多好事。然而，有些事情你应该小心…

### 为了短功能而提取

有人提倡使用微小的微小函数，如果你把所有东西都提取出来，那就是你能得到的。然而，这会对代码的易懂性产生不利影响。

例如，假设您正在调试一些代码。你看函数`a()`。然后，你发现它使用了`b()`，而 T1 又使用了`c()`。诸如此类。

虽然短函数很棒，也很容易理解，但是如果你只在一个地方使用函数，可以考虑使用“用变量替换表达式”的方法。

### 不要强求

通常，没有绝对正确的方法来做这件事。因此，如果某件事看起来不像是个好主意，就不要勉强。

## 结论

让您的代码自文档化对提高代码的可维护性大有帮助。每个评论都是必须维护的额外资源，所以尽可能地删除评论是一件好事。

然而，自文档化代码不能取代文档或注释。例如，代码在表达意图方面是有限的，所以你也需要有好的注释。API 文档对库也很重要，因为除非你的库很小，否则阅读代码是不可行的。

## 分享这篇文章