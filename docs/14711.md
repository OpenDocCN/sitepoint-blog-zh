# 经济高效的网站加速

> 原文:[https://www.sitepoint.com/effective-website-acceleration/](https://www.sitepoint.com/effective-website-acceleration/)

**这个由三部分组成的系列文章根据两个简单的 Web 性能法则概述了一个常识性的、经济高效的网站加速方法:**

1.  发送尽可能少的数据

3.  尽可能不要发送它

如果使用得当，这些基本原则将会导致:

*   更快的网页加载
*   减少服务器使用
*   提高带宽利用率

这些技术不仅应该提高用户对你的网站或基于 Web 的应用程序的满意度，还应该帮助你节省网站交付成本。

我们将在本系列中介绍的原则不仅适用于开发人员可访问的 Web 页面源代码，包括(X)HTML、CSS 和 JavaScript，还将涉及 Web 服务器的配置和修改。有些建议可能会涉及到结构性站点更改或对服务器端编程环境的修改，但我们的主要关注点将是可以对现有站点进行的相对容易的更改。

从上述两个原则衍生的技术分为三大类:

1.  客户端代码优化——将在本系列的第 1 部分讨论，从下面开始。

3.  [最佳缓存控制](https://www.sitepoint.com/effective-website-acceleration/)—本系列的第 2 部分

5.  [服务器端修改](https://www.sitepoint.com/effective-website-acceleration/)——本系列的第 3 部分

在本系列的第一部分中，我们将重点关注客户端代码优化——这是三种站点加速技术中实现起来最简单也是最便宜的。如上所述，本系列的后续部分将依次讨论 chache 控件和服务器端修改。

##### 第 1 部分–客户端加速

##### 为自己编码，为交付而编译

任何应用程序程序员都知道，我们使用的代码不是我们应该交付的代码是有充分理由的。最好对源代码进行广泛的注释，将其格式化以获得最大的可读性，并避免过于简洁但复杂的语法，这使得维护变得困难。随后，我们使用编译器将源代码翻译成其他形式，以优化性能并防止逆向工程。

这个模型也可以应用到 Web 开发中。要做到这一点，您需要获取站点的“源”版本，并通过简单的技术(如减少空白、图像和脚本优化以及文件重命名)对其进行“压缩”,从而为交付做好准备。然后，你可以把你的交付就绪的网站，并张贴出来。

现在，可以推测，这不是一个太陌生的概念，因为你可能至少是在你的站点的一个副本上工作，而不是直接将改变发布到活动的站点上。如果没有，请立即停止阅读，并复制一份您的网站！这是唯一合适的开发方式，不管这个网站是一个静态的小册子还是一个复杂的 CMS 驱动的应用程序。如果你现在不相信我们，在不久的将来的某一天，当你毁坏了你的一些站点文件并且不能轻易地恢复它们的时候，你就会相信我们了。

当你建立你的网站时，你可能会关注网站下载速度降低的罪魁祸首——图片和 Flash 之类的二进制文件。虽然减少 GIF 文件中的颜色、压缩 JPEGs 和优化 SWF 文件肯定会有很大帮助，但仍有许多其他方面需要改进。

记住 Web 性能的第一条规则，我们应该总是努力发送尽可能少的字节，不管文件是标记、图像还是脚本。现在，专注于在(X)HTML、CSS 或 JavaScript 中减少字节似乎是浪费精力。然而，这可能恰恰是最应该注意的地方。

在一个典型的网页获取过程中，一个(X)HTML 文档首先被传递给浏览器。我们可以称之为宿主文档，因为它决定了所有其他文件之间的关系。一旦接收到 XHTML 文档，浏览器就开始解析标记，并且在这样做的过程中，通常会发起许多对相关对象的请求，例如外部脚本、链接的样式表、图像、嵌入式 Flash 等等。这些 CSS 和 JavaScript 文件反过来可以承载对相关图像或脚本文件的额外调用。

对相关文件的这些请求排队越快，它们返回浏览器并开始在页面中呈现的速度就越快。考虑到宿主文档的重要性，尽可能快地将它提交给浏览器并进行解析似乎是至关重要的，因为尽管它在整个页面中所占的比例相对较小，但它会极大地阻碍页面的加载。记住:用户测量的不是字节，而是时间！

那么，具体来说，你需要做些什么来为你的站点做好充分的准备以获得最佳的交付呢？基本方法包括减少空白、处理 CSS 和 JavaScript、重命名文件，以及使交付的代码尽可能简洁的类似策略(参见 [Google](http://www.google.com) 的例子)。这些通用技术是众所周知的，在网上和书中都有记载，比如安迪·金的[加速你的网站:网站优化](http://www.websiteoptimization.com)。

在本文中，我们介绍了我们认为的前二十种标记和代码优化技术。您当然可以手动执行其中的一些优化，找到一些 Web 编辑器和实用程序来为您执行一些功能，或者推出您自己的计算实用程序。我们也不知羞耻地向您推荐一个在 Port80 Software 开发的工具，叫做 w3 编译器。这个工具是目前市场上唯一一个为这里描述的几乎所有优化特性提供参考实现的工具，并且是代码优化的“真实世界”价值的合法示例。现在，继续提示！

##### 标记优化

典型的标记要么是非常紧凑的、手工制作的、以标准为中心的、充满注释和格式化空白的标记，要么是庞大的、编辑器生成的标记，具有过多的缩进，特定于编辑器的注释通常用作控制结构，甚至是冗余的或不必要的标记或代码。这两种情况都不适合交付。以下提示是减小文件大小的安全而简单的方法:

***1。尽可能删除空白。*T3】**

一般来说，可以安全地消除多个空白字符(空格、制表符、换行符)，但是当然要避免更改受空白 CSS 属性影响的`<pre>`、`<textarea>`和标签。

***2。删除评论。*T3】**

除了 IE 和`DOCTYPE`语句的客户端条件注释之外，几乎所有的注释都可以安全地删除。

***3。将颜色值重新映射到它们的最小形式。*T3】**

不要使用所有的十六进制值或所有的颜色名称，而是在每个特定的情况下使用最短的形式。例如，像`#ff0000`这样的颜色属性值可以替换为红色，而 lightgoldenrodyellow 将变成`#fafad2`。

***4。将字符实体重新映射到它们的最小形式。*T3】**

与颜色替换一样，您可以用数值实体替换较长的面向 alpha 的实体。比如`&Egrave`；会变成`&#200`；。偶尔，这也反过来起作用:`&#240`；如果引用为`&eth`，则保存一个字节；。然而，这样做并不十分安全，潜在的节省也是有限的。

***5。去掉无用的标签。*T3】**

一些“垃圾”标记，如多次应用的标签或某些用作编辑广告的`<meta>`标签，可以安全地从文档中删除。

<q>**有问题的标记优化技术**</q>
<q>虽然前五种技术可以带来大约百分之十到十五的显著节省，但是许多寻求最大交付压缩的工具和开发人员采用了一些有问题的技术，包括:</q>

*   <q>属性上的引用移除</q>
*   <q>Doctype 语句删除</q>
*   <q>可选关闭标签移除</q>
*   <q>标签替换如`<strong>`到`<b>`T3】</q>

虽然大多数浏览器确实能够理解他们所收到的任何“标签汤”,但理性的开发人员不会依赖于此，相反，他们总是试图交付符合标准的标记。一般来说，与绕过标准相关的问题(例如，降低的可移植性和互操作性)超过了速度上的小收益，并且，在缺少结束标记的情况下，甚至可能在页面呈现上有性能损失。虽然像 Google 这样的网站已经有意识地在他们的主页标记上使用了很多这样的技术，但是你可能不需要走那么远。我们建议您避免使用它们，除非您有极端的性能要求。

##### CSS 优化

CSS 也适合简单的优化。事实上，今天创建的大多数 CSS 比(X)HTML 压缩得更成功。以下技术都是安全的，除了最后一种，它的复杂性展示了客户端 Web 技术的复杂程度。

***6。删除 CSS 空白。*T3】**

与(X)HTML 的情况一样，CSS 对空白不太敏感，因此移除空白是显著减小 CSS 文件和`<style>`块大小的好方法。

***7。移除 CSS 注释。*T3】**

就像标记注释一样，CSS 注释应该被删除，因为它们对一般的最终用户没有任何价值。然而，如果你担心下层浏览器，那么`<style>`标签中的 CSS 屏蔽注释可能不应该被删除。

***8。将 CSS 中的颜色重新映射到它们的最小形式。*T3】**

和 HTML 一样，CSS 颜色可以从 word 格式重新映射到 hex 格式。然而，在 CSS 中这样做的好处要稍大一些。主要原因是 CSS 支持三个十六进制的颜色值，比如白色的`#fff`。

***9。合并、减少和删除 CSS 规则。*T3】**

字体大小、字体粗细等 CSS 规则通常可以用简单的符号表示，只使用一个属性 font。如果使用得当，这种技术可以让您:

```
p {font-size: 36pt; 

    font-family: Arial; 

    line-height: 48pt; 

    font-weight: bold;}
```

并将其重写为:

```
p{font:bold 36pt/48pt Arial;}
```

您还会发现，如果正确使用继承，样式表中的一些规则可以显著减少，甚至完全消除。到目前为止，还没有可用的自动规则缩减工具，所以 CSS 向导将不得不手动调整这些额外的节省。然而，即将发布的 w3 编译器 2.0 版将包含这一特性。

***10。重命名类和 id 值。*T3】**

可以对 CSS 执行的最危险的优化是重命名类或 id 值。考虑这样一条规则:

```
.superSpecial {color: red; font-size: 36pt;}
```

将该类重命名为`sS`似乎比较合适。您也可以采用 id 规则，例如:

```
#firstParagraph {background-color: yellow;}
```

这里，您可以使用`#fp`代替`#firstParagraph`，在整个文档中更改适当的 id 值。当然，在这样做的过程中，您开始遇到标记-样式-脚本依赖性的问题:如果一个标记有一个 id 值，那么这个值可能不仅用于样式表，还用作脚本引用，甚至是链接目的地。如果修改这个值，您需要非常确定您也修改了所有相关的脚本和链接引用。这些引用甚至可能位于其他文件中，所以要小心。

更改类值并不那么危险，因为经验表明，大多数 JavaScript 开发人员不像处理 id 值那样频繁地处理类值。然而，类名缩减最终会遇到与 id 缩减相同的问题，所以，还是要小心。

注意:你可能永远不应该重新映射名称属性，尤其是在表单字段上，因为这些值也是由服务器端程序操作的，它们也必须被修改。尽管并非不可能，但在许多网站环境中，计算这种依赖性是很困难的。

##### JavaScript 优化

越来越多的网站依赖 JavaScript 来提供导航菜单、表单验证和各种其他有用的东西。不足为奇的是，这些代码大部分都很庞大，需要优化。JavaScript 优化的许多技术与用于标记和 CSS 的技术相似。然而，JavaScript 优化必须非常小心地执行，因为如果处理不当，结果不仅仅是视觉失真，还可能是页面损坏！让我们从最明显和最容易的改进开始，然后继续那些需要更多关注的。

***11。移除 JavaScript 注释。*T3】**

除了`<!-- //-->`屏蔽注释之外，所有由`//`或`/* */`指示的 JavaScript 注释都可以安全地删除，因为它们对最终用户没有任何价值(除了那些想了解你的脚本如何工作的人)。

***12。删除 JavaScript 中的空白。*T3】**

有趣的是，JavaScript 中的空白移除并不像看起来那么有益。一方面，代码是这样的:

```
x = x + 1; 
```

显然可以归结为:

```
x=x+1;
```

然而，由于 JavaScript 开发人员通常草率的编码实践没有用分号结束行，空格减少可能会导致问题。例如，考虑下面的合法 JavaScript，它使用隐含的分号:

```
x=x+1  

y=y+1
```

简单的空白去除程序可能会产生以下结果:

```
x=x+1y=y+1
```

这显然会抛出一个错误。如果添加所需的分号来生成:

```
x=x+1;y=y+1;
```

实际上，您在字节数方面没有任何收获。然而，我们仍然鼓励这种转换，因为对 w3compiler 测试版提供反馈的 Web 开发人员发现“可视化压缩”的脚本更令人满意(可能是因为他们看到的是转换后的代码，而不是原始代码)。他们还喜欢交付更多模糊代码的附带好处。

***13。执行代码优化。*T3】**

一些简单的想法，如删除隐含的分号、某些情况下的 var 语句或空的 return 语句，有助于进一步减少一些脚本代码。在许多情况下也可以使用速记。例如:

```
x=x+1;
```

可以变成:

```
x++;
```

然而，要小心，因为除非你的优化非常保守，否则很容易破坏你的代码。

***14。重命名用户定义的变量和函数名。*T3】**

为了获得良好的可读性，任何脚本都应该使用像`sumTotal`这样的变量，而不是`s`。

然而，对于下载速度来说，冗长的变量 sumTotal 是一个缺点，它不提供任何用户价值，所以 s 是一个更好的选择。这里，再一次，以可读的方式编写源代码，然后使用工具为交付做准备，这显示了它的价值，因为将所有用户定义的变量和函数名称重新映射到短的单字母和双字母标识符可以产生显著的节约。

***15。重新映射内置对象。*T3】**

除了长的用户变量名，JavaScript 代码的庞大来自于内置对象的使用，比如窗口、文档、导航器等等。例如，考虑以下代码:

```
alert(window.navigator.appName);  

alert(window.navigator.appVersion);  

alert(window.navigator.userAgent);
```

您可以将上面的内容重写如下:

```
w=window;n=w.navigator;a=alert;  

a(n.appName);  

a(n.appVersion);  

a(n.userAgent);
```

当对象被重复使用时，这种类型的重映射非常有价值，通常都是这样。但是，请注意，如果 window 或 navigator 对象只使用了一次，这些替换实际上会使代码变得更大，所以如果您是手动优化，请小心。幸运的是，许多 JavaScript 代码优化器会自动考虑这一点。

这篇技巧文章提出了一个与带有重映射对象的脚本的性能相关的问题:除了大小减少的好处之外，这种重映射实际上稍微改善了脚本的执行时间，因为对象被复制到 JavaScript 的作用域链的更高层。编写 JavaScript 游戏的开发人员已经使用这种技术很多年了，虽然它可以提高下载和执行性能，但它是以牺牲本地浏览器内存使用为代价的。

<q>**JavaScript 优化的混淆副作用**</q>
<q>你会注意到，如果你应用这些不同的 JavaScript 优化，源代码实际上变得不可读，甚至有些人可能会说，混淆。虽然优化 JavaScript 的逆向工程确实很困难，但也并非不可能。真正的混淆会使用像 O1l1l1O0l1 和 Ol11l001l 这样的变量，这样解开代码会更加混乱。有些人甚至会在页面上使用轻度加密。但是，请注意，通常情况下，混淆和优化可能会相互矛盾，以至于更多的混淆代码可能会比原始代码更大。幸运的是，轻量级代码混淆通常足以阻止偶然的代码窃贼，同时仍然提供性能改进。</q>

##### 文件相关优化

最后一组优化技术与文件和站点组织相关。这里提到的一些优化可能需要服务器修改或站点重组。

***16。重命名非用户访问的相关文件和目录。*T3】**

对于用户从不通过 URL 访问的相关对象，站点通常会有 SubHeaderAbout.gif 或 rollover.js 之类的文件名。通常，它们保存在一个标准目录中，如`/images`，所以您可能会看到这样的标记:

```
<img src="/images/SubHeaderAbout.gif">  

Or, worse:  

<img src="../../../images/SubHeaderAbout.gif">
```

鉴于这些文件永远不会被直接访问，这种可读性对用户没有任何价值，只对开发人员有价值。为了便于交付，使用如下标记更有意义

```
<img src="/0/a.gif">
```

尽管手动文件和目录重新映射可能是一个密集的过程，但一些内容管理系统可以将内容部署到目标名称，包括缩短的值。

此外，w3 编译器具有自动复制和设置这些依赖项的特性。如果使用得当，这可以在引用这些对象的(X)HTML 文件中产生非常显著的节省，并且还可以使修改被盗用的站点标记更加困难。

***17。使用 URL 重写器缩短所有页面 URL。*T3】**

请注意，上一步并不建议像 products.html 那样重命名主机文件，这样会更改标记，如下所示:

```
<a href="products.html">Products</a>
```

像这样:

```
<a href="p.html">Products</a>
```

主要原因是最终用户将会看到一个类似 http://www.sitename.com/p.html,的网址，而不是更有用的 http://www.sitename.com/products.html.

但是，如果您将重命名技术与更改 Web 服务器的配置结合起来，就有可能在不牺牲有意义的页面 URL 的情况下获得减少源代码中文件名的好处。例如，您可以在源代码中用`p.html`代替`products.html`，然后设置一个 URL 重写规则，由像 [mod_rewrite](http://httpd.apache.org/docs/mod/mod_rewrite.html) 这样的服务器过滤器使用，将 URL 扩展回用户友好的值。请注意，如果重写规则采用“外部”重定向，这个技巧只会将新的 URL 放在用户的地址栏中，从而迫使浏览器重新请求页面。在这种情况下，文件本身不会被重命名，因为短标识符只在源代码 URL 中使用。

由于对 URL 重写的依赖以及开发人员对 mod_rewrite 等服务器端工具缺乏广泛的访问和理解，即使像 w3 编译器这样的高级工具目前也没有推广这种技术。然而，考虑到像雅虎这样的网站。积极使用这种技术可以节省大量资源，但不应该忽略它，因为当站点中使用描述性极强的目录和文件名时，它确实可以显著减少(X)HTML。

***18。删除或减少文件扩展名。*T3】**

有趣的是，包含诸如。gif，。jpg，。js，等等。浏览器不依赖这些值来呈现页面；相反，它在响应中使用 MIME 类型头。知道了这一点，我们可以采取:

```
<img src="images/SubHeaderAbout.gif">
```

并将其缩短为:

```
<img src="images/SubHeaderAbout">
```

如果与文件重命名结合使用，这可能会产生:

```
<img src="/0/sA">
```

不要被这种技术看起来有多奇怪吓到；您的实际文件仍然是 sA.gif。只是最终用户不会看到它！

然而，为了利用这种更先进的技术，您确实需要对您的服务器进行修改。您需要做的主要事情是启用所谓的“内容协商”，这可能是您的服务器的固有功能，或者需要一个扩展，例如用于 Apache 的[mod _ negation](http://httpd.apache.org/docs/mod/mod_negotiation.html)或用于 IIS 的 Port80 的 pageXchanger。这样做的缺点是可能会对服务器的性能造成轻微的影响。

然而，增加内容协商的好处远远超过成本。干净的 URL 提高了网站的安全性和可移植性，甚至允许自适应的内容交付，这样您就可以根据用户浏览器的功能或系统偏好向用户发送不同的图像类型或语言！有关更多信息，请参见同一作者的[“迈向下一代 URL”](http://www.port80software.com/support/articles/nextgenerationurls)。

注意:无扩展名的网址不会损害你在搜索引擎中的排名。Port80 软件以及像 W3C 这样的主要网站都使用这种技术，并且没有受到不良影响。

***19。重构<脚本>和`<style>`包含，以获得最佳请求数。***

你会经常在一个 HTML 文档的`<head>`中发现这样的标记:

```
<script src="/scripts/rollovers.js"></script>  

<script src="/scripts/validation.js"></script>  

<script src="/scripts/tracking.js"></script>
```

在大多数情况下，这应该简化为:

```
<script src="/0/g.js"></script>
```

这里，`g.js`包含了所有全局使用的函数。虽然将脚本文件分成三部分对于可维护性来说是有意义的，但是对于交付来说却没有意义。单个脚本下载远比三个独立的请求更有效，它甚至减少了所需的标记数量。有趣的是，这种方法模仿了传统编程语言编译器中的链接概念。

***20。在代码级别考虑可缓存性。*T3】**

对站点性能的一个最重要的改进就是提高可缓存性。Web 开发人员可能非常熟悉使用`<meta>`标签来设置缓存控制，但是(除了 meta 对代理缓存没有影响的事实之外)可缓存性的真正价值在于它对依赖对象(如图像和脚本)的应用。

为了让你的站点做好改进缓存的准备，你应该考虑根据变化的频率对你的依赖对象进行分段，将你更多的可缓存项存储在一个目录中，比如`/cache`或者`/images/cache`。一旦你开始以这种方式组织你的站点，添加缓存控制规则将非常容易，这将使你的站点对于经常访问的用户来说非常“流行”。

##### 结论

你现在有 20 个有用的代码优化技巧来让你的网站更快。一个接一个，它们可能看起来不是很强大，但是，将它们应用在一起，你会看到站点交付的明显改善。

在本系列的下一期文章中，我们将主要关注缓存，解释它是如何被滥用的，以及如何通过一些简单的改变来显著提高性能。到时候见！

##### 第 2 部分–有效的缓存控制

在本系列的第一部分中，我们介绍了 Web 性能的两个基本法则:

1.  发送尽可能少的数据

3.  尽可能不要发送它

在第一部分中，我们重点关注规则一，并提供了 20 个技巧来通过代码优化从交付的页面中挤出每一个字节，远远超越明显占用带宽的图像，到 JavaScript、HTML、CSS，甚至文件名优化。

在这一期中，我们将主要关注第二条规则，即更好地利用 Web 上的缓存。一旦你开始设计你的网站，着眼于有效的缓存控制，你将大大减少你的用户的页面加载时间，特别是你最忠实的回头客，同时降低你的整体带宽消耗，释放你的服务器资源。

##### 网络上多种类型的缓存

缓存背后的基本思想很简单:与其浪费精力在每次需要时重新下载一个资源，不如保留一个本地副本，只要它仍然有效就重用它。Web 缓存最常见的例子是浏览器缓存，它将图像和其他页面对象的副本存储在最终用户的硬盘上，以供重复使用。

尽管 Web 上有许多其他的缓存——在原始 Web 服务器上，沿着网络路径，甚至在最终用户的本地网络上——所有类型的缓存的目的本质上是相同的。从本地浏览器缓存向外看，您接下来可能会遇到本地网络上的代理缓存，它的实现使得局域网上的其他用户不必像您一样访问 Web 来获取相同的站点。接下来，您的 ISP 或其他各种中转 ISP 也可能使用代理缓存来为其网络上的访问者提供站点对象。最后，实际的网站可以利用反向代理高速缓存以完成的形式保存生成的页面，以备交付，从而减轻服务器重复生成和交付频繁请求的页面的负担。

我们可以将所有的网络缓存分为两大类:私有的和公共的。私有缓存(最常见的是 Web 浏览器)是单个用户代理所独有的，用于存储只能由单个最终用户重用的项目。另一方面，代理和反向代理缓存是公共缓存。这些用于共享资源，即可以由多个最终用户安全重用的项目。下图显示了常见的缓存类型:

![1305_Fig1](../Images/e84bb9b86ac5ed7d5f9d7029733e932b.png)
*网上缓存使用情况*

这张图说明了我们讨论中的一个关键点:在 Web 上的许多地方都可以找到缓存，只要有可能，缓存就会不断尝试保存您的站点内容。虽然很容易保持无知并允许他们决定缓存行为，但从站点性能的角度来看，有目的地使用不同形式的缓存是至关重要的，决定哪些对象应该或不应该被缓存，以及缓存多长时间。

##### 新鲜度和验证

为了充分利用任何缓存，包括浏览器缓存，我们需要在资源不再有效并因此需要重新获取时提供一些指示。更具体地说，我们需要能够指示 Web 页面对象的缓存规则，范围从设置适当的过期时间，到指示特定对象何时根本不应该被缓存。幸运的是，我们拥有 HTTP 缓存控制规则形式的所有这些功能。

了解缓存的关键在于理解控制缓存行为的两个概念:新鲜度和有效性。新鲜度是指缓存的对象是否是最新的，或者用更专业的术语来说，缓存的资源是否与源服务器上的相同资源处于相同的状态。如果浏览器或其他 Web 缓存缺少足够的信息来确认缓存的对象是新的，它将总是小心翼翼地将其视为可能过期或陈旧的对象。验证是一个过程，通过该过程，缓存与源服务器进行检查，以查看那些可能过时的缓存对象之一是否是新的。如果服务器确认缓存的对象仍然是新的，浏览器将使用本地资源。

##### 缓存的一个基本例子

新鲜度和验证的概念最好用一个例子来说明(在这个例子中使用浏览器缓存，但是核心原则也适用于公共缓存):

***第一步***

远程站点包含一个名为 page1.html 的页面。此页面引用了 image1.gif、image2.gif 和 image3.gif，并有一个到 page2.html 的链接。当我们第一次访问这个页面时，HTML 和相关联的 GIF 图像被逐个下载并存储在本地浏览器缓存中。

![1305_Fig2](../Images/b65a5f5efdae07a79dc22b6e28401fdd.png)
*初始缓存加载*

一旦数据被下载到缓存中，它就会被“标记”以表明它来自哪里以及何时被访问。它也可能被印上第三条信息:何时需要重新获取。但是，由于大多数站点不使用这种显式的缓存控制信息来标记它们的数据，我们将假设我们的示例缺少这种信息。

 **第二步

用户跟随链接到 page2.html，该链接以前从未被访问过，并且引用了 image1.gif、image3.gif 和 image4.gif。在这种情况下，浏览器下载新页面的标记，但是问题是:即使已经缓存了 image1.gif 和 image3.gif，它还应该重新下载它们吗？显而易见的答案是否定的，但是，我们怎么能确定自从我们下载了 page1.html 之后图像没有被改变呢？没有缓存控制信息，事实是我们不能。

因此，浏览器需要通过向服务器发送请求来重新验证图像，以便检查每个图像是否都被修改过。如果它没有被更改，服务器将发送一个快速的“`304 Not Modified`”响应，指示浏览器继续使用缓存的图像。但是，如果它已被修改，则必须下载一份新的映像副本。这个常见的`Not Modified`请求-响应循环如下所示:

![1305_Fig3](../Images/e01a9b38f592507b3718a3fb56ade464.png)
*缓存检查*

从这个基本示例中可以明显看出，即使 CSS、图像和 JavaScript 是新的，我们也可能无法获得预期的缓存优势，因为浏览器在重用缓存副本之前仍然需要往返于服务器。

Internet Explorer 中的默认“自动”设置通过在单个浏览器会话期间跳过缓存对象的重新验证，部分地减少了浏览器和服务器之间的这种持续的干扰。您会注意到，当您在同一个浏览器会话中再次访问同一个页面时，页面加载时间通常会快得多。要查看所有这些`304 Not Modified`响应所导致的性能损失，请选择“每次访问页面”

![1305_Fig4](../Images/50b7df29f9fdc4ca90bf192265204e94.png)
*IE 的缓存控制对话框*

注意:虽然 IE 的“智能缓存”确实减少了不必要的验证请求，但这也是 IE 不断提醒用户清空缓存以查看新内容的原因。有了缓存，一切都有了取舍！

##### 缓存的好处

最大限度地减少 Web 上的往返以重新验证缓存的项可以大大缩短浏览器页面的加载时间。也许最生动的例子是当用户在第一次浏览后第二次返回网站时。在这种情况下，所有的页面对象都必须重新验证，每一个都要花费宝贵的几分之一秒(更不用说消耗带宽和服务器周期)。另一方面，利用适当的高速缓存控制允许这些先前查看的对象中的每一个都直接从浏览器的高速缓存中提供，而不用返回到服务器。

向页面对象添加缓存规则的效果通常在页面加载时可见，即使使用高带宽连接，用户可能会注意到您的站点似乎绘制得更快，并且在后续页面加载之间“闪烁”减少了。除了改善用户感知，Web 服务器将不再响应缓存重新验证请求，从而能够更好地为新流量提供服务。

然而，为了享受缓存的好处，开发人员需要花时间写出一组精心制作的缓存控制策略，根据站点对象的预期生命周期对其进行分类。下面是一个简单电子商务网站的完整缓存控制策略示例:

![1305_Acceleratetable1](../Images/d8ed83f9e8baf6dabfb42fb3ea74e1b3.png)

如您所见，从缓存控制的角度来看，该站点有六种不同类型的对象。由于徽标和其他公司品牌不太可能改变，导航和徽标图像被视为几乎是永久的。级联样式表和 JavaScript 文件被赋予了刷新生命周期，以支持定期的半年更新计划。就搜索引擎优化和用户体验而言，新鲜的网站内容非常重要，因此主标题图片的变化会更加频繁。当然，每月一次的“特价商品”图片旨在保持一个月的新鲜度。还有一种个性化的特价商品图像，在用户初次访问后的两周内，它会在用户的缓存中保持新鲜；请注意，此类别被标记为“private ”,表示它不会被共享/代理缓存缓存。最后，站点上所有其他内容的默认策略规定，不应该缓存任何其他内容，这保证了文本和动态内容对于每个请求都是新鲜的。

您需要非常小心不要缓存 HTML 页面，不管它们是否是静态生成的，除非您真的知道自己在做什么。如果有的话，您应该使用缓存控制来确保这些页面没有被缓存。如果用户缓存您的 HTML 页面，并且您设置了很长的过期时间，那么在缓存的对象过期之前，他们将看不到您对内容所做的任何更改。另一方面，如果您专注于缓存依赖对象，如图像、Flash 文件、JavaScript 和样式表，您可以通过重命名对象来替换缓存的内容。

例如，假设您有一个每年更改一次网站徽标文件的策略，但是在这一年的中期，您的公司进行了一次重大的品牌更改，需要在网站上反映出来。幸运的是，如果您没有将 HTML 文件设置为缓存，您仍然可以通过将文件从 logo.gif 重命名为 newlogo.gif 并更改相关的 HTML `<img>`引用来提供新的徽标。当 HTML 被解析时，浏览器将注意到它的缓存中没有新图像，并将下载它。当然，旧图像在相当长的一段时间内仍会在用户的缓存中，但不再使用。

仔细考虑了哪些站点资源应该缓存，哪些不应该缓存之后，下一步就是实现这些策略。

##### 负责缓存

有三种方法可以用来设置 Web 的缓存控制规则:

1.  通过一个`<meta>`标签指定缓存控制头

3.  以编程方式设置 HTTP 头

5.  通过 Web 服务器设置设置 HTTP 头

这些方法各有利弊。

##### `<meta>`用于基本缓存的标签

实现缓存控制的最简单方法是使用`<meta>`标签。例如，我们可以将 Expires 标头设置为未来的某个日期:

```
<meta http-equiv="Expires" content="Sun, 31 Oct 2004 23:59:00 GMT" />
```

在这种情况下，解析该 HTML 的浏览器将假设该页面直到 2004 年 10 月才到期，并将它添加到缓存中。因为页面将会被打上这个`Expires`标题，所以浏览器不会重新请求页面，直到这个日期之后，或者直到用户修改浏览器的缓存首选项或者手动清除缓存。

当然，正如我们上面提到的，虽然缓存页面数据通常是有利的，但是在某些情况下，您根本不想缓存数据。在这些情况下，您可以将`Expires`值设置为过去的某个日期:

```
<meta http-equiv="Expires" content="Sat, 13 Dec 2003 12:59:00 GMT" />
```

您可能会担心用户系统上的时钟变化，因此选择一个早已过去的日期，但实际上，这很少是一个问题，因为服务器的`Date`响应头响应对缓存控制很重要。

在`<meta>`标签中使用带有过去日期的`Expires`应该适用于兼容 HTTP 1.0 和 1.1 的浏览器。还有两个常用的`<meta>`标签来确保页面不被缓存。`Pragma`标签用于与 HTTP 1.0 浏览器缓存对话，而`Cache-Control`标签用于 HTTP 1.1 客户端。如果您想确保无论浏览器类型或版本如何，页面都不会被缓存，那么包含这两个选项也无妨:

```
<meta http-equiv="Pragma" content="no-cache" />
```

```
<meta http-equiv="Cache-Control" content="no-cache" />
```

虽然看起来很简单，但是它们有一个主要问题——它们不能被中间代理缓存读取，中间代理缓存通常不解析 HTML 数据，而是直接依赖 HTTP 头来控制缓存策略。由于这种潜在价值的损失，并且考虑到浏览器很容易使用 HTTP 头的事实，基于`<meta>`的缓存控件真的不应该成为开发人员缓存控件的主要方法。

##### 编程缓存控制

大多数服务器端编程环境，如 PHP、ASP 和 ColdFusion，都允许您添加或修改伴随特定响应的 HTTP 头。例如，要在 ASP 中做到这一点，您可以通过在页面顶部包含这样的代码来使用内置的`Response`对象的属性:

```
<%     

Response.Expires = "1440"    

Response.CacheControl = "max-age=86400,private"     

%>
```

这里，您要求 ASP 创建一个`Expires`头(用于符合 HTTP 1.0 的缓存)和一个`Cache-Control`头(用于 HTTP 1.1 缓存)。您还为这个缓存对象指定了一个 24 小时的刷新生命周期(注意，`Expires`属性需要一个以分钟为单位的值，而`CacheControl`使用秒)。因此，以下标头将被添加到 HTTP 响应中(假设“现在”是格林威治标准时间 2004 年 2 月 13 日星期五晚上 8:46):

```
Expires: Sat, 14 Feb 2004 20:46:04 GMT    

Cache-control: max-age=86400,private
```

总的来说，依靠这些类型的服务器端机制，而不是`<meta>`标签，来与缓存通信要有效得多。因此，当您在使用`<Meta>`元素实现缓存控制策略和使用 ASP 这样的服务器端编程环境之间进行选择时，请始终选择后者。

然而，有一个不同的问题，服务器端编程环境对此无能为力。想象一下，我们为其创建上述代码的 ASP 文件链接到几个图像，根据您的缓存控制策略，这些图像具有一整年的刷新寿命。如何实现 HTTP 头来告诉缓存，它们可以将这些图像存储那么长时间？您可以尝试使用服务器端脚本以编程方式返回图像，但这既复杂又浪费。为静态外部对象(如 CSS、JavaScript 和图像等二进制对象)设置缓存控制信息的更好方法是在服务器本身上设置缓存控制信息。

##### 基于 Web 服务器的缓存设置

Microsoft IIS 和 Apache 都为缓存控制提供了各种工具。不幸的是，每一个都有不同的缓存方法，并且缓存控制策略的委托并不完全掌握在那些最熟悉站点资源的人手中——开发人员！

##### Apache 缓存控制

如果安装了 Apache 模块[http://httpd.apache.org/docs-2.0/mod/mod_expires.html](http://httpd.apache.org/docs-2.0/mod/mod_expires.html)mod _ expires，那么 Apache Web 服务器的用户比运行 IIS 的用户更容易实现缓存控制策略。

使用 mod_expires，服务器管理员可以在主服务器配置文件(通常是 httpd.conf)中为站点上的不同对象设置到期寿命。与 Apache 模块的常见情况一样，虚拟主机和目录容器都可以用于为不同的站点指定不同的指令，甚至可以为给定站点中的不同目录指定不同的指令。这比必须使用 IIS 的图形用户界面或元数据库脚本对象要方便得多。

更方便的是 mod_expires 的`ExpiresByType`指令，它允许您用一行代码为给定 MIME 类型的所有文件设置有效期。该指令允许您轻松地为站点中的所有脚本、样式表或图像设置缓存策略。当然，您通常需要根据对象类型或目录制定更细粒度的策略。在这种情况下，主配置文件中指定的设置可以被给定目录及其子目录的. htaccess 文件中的指令覆盖(由服务器管理员决定)。这样，开发人员可以编写和维护他们自己的缓存控制指令，而不需要对服务器进行管理访问，即使在共享的托管环境中也是如此。

如果您的 Apache 服务器不是用 mod_expires 构建的，那么启用它的最佳方式是将其构建为一个共享对象(使用 aspx 通常是最简单的),然后在 httpd.conf 文件中包含以下行:

```
LoadModule expires_module modules/mod_expires.so
```

然后，您可以将您的配置指令放入 httpd.conf 中。但是，许多管理员希望将它们放在外部配置文件中，以保持整洁。在我们的示例中，我们将遵循这种做法，在 httpd.conf 中使用 Apache 的`Include`指令(IfModule 容器是一种可选的、但传统的安全措施):

```
<IfModule mod_expires.c>    

     Include conf/expires.conf    

</IfModule>
```

我们现在可以在一个名为 expires.conf 的特定于模块的配置文件中找到控制 mod_expires 行为的指令。

```
ExpiresActive On    

ExpiresDefault "access 1 month"    

ExpiresByType image/png "access 3 months"
```

`ExpiresActive`指令只是启用 mod_expires，而`ExpiresDefault`指令设置了一个默认的到期期限，该期限将用于为任何不适用更具体规则的文件创建`Expires`和`Cache-Control`头。请注意用于指定过期生存期的语法；时间单位可以是秒到年，而基准时间可以指定为`modification`和`access`。

接下来是前面提到的非常有用的`ExpiresByType`指令，这里适用于所有人。服务器上的 png 图像文件:

```
<Directory "/usr/local/apache/htdocs/static">    

AllowOverride Indexes    

ExpiresDefault "access 6 months"    

</Directory>
```

最后，我们有一个`Directory`容器，它覆盖了目录`/static`中所有其他规则。这个目录有自己的`ExpiresDefault`指令，以及一个`AllowOverride`指令，允许通过。htaccess 文件。的。反过来，htaccess 文件可能看起来像这样:

```
ExpiresByType text/html "access 1 week"
```

请注意，这将覆盖任何原本应用于`/static`中的文件及其 MIME 类型为 text/html 的子文件的指令。使用配置文件指令的组合，然后使用。htaccess，几乎任何一组缓存控制策略，无论有多复杂，都可以由管理员和开发人员(如果授权得当)轻松实现。

##### IIS 缓存控制

如果您在 Microsoft 的 Internet 信息服务(IIS)上设置缓存控制规则，您需要访问 IIS 元数据库。这通常通过 Internet 服务管理器(ISM)来访问，ISM 是控制 IIS 管理设置的 Microsoft 管理控制台应用程序。

要在 IIS 中设置过期时间，只需打开 ISM，显示要配置的文件或目录的属性页，然后单击“HTTP Headers”选项卡。接下来，在标有“启用内容过期”的框中打勾，并使用单选按钮，选择所提供的选项之一。您可以选择让内容立即过期，设置相对过期时间(以分钟、小时或天为单位)，或者设置绝对过期时间。请注意，`Expires`和`Cache-Control`标题都将被插入到受影响的响应中。这里展示了基本思想。

***IIS 缓存控制设置***

![1305_Fig5](../Images/8dd0cabc446faf954c314ab8ac64fa41.png)

尽管 GUI 对用户友好，但在 IIS 上为不同类别的文件设置不同的缓存控制策略实际上是相当笨拙的。如果网站的文件没有根据它们期望的新鲜期整齐地分类到不同的目录中，情况会变得更糟。如果您碰巧在设计站点时考虑到了缓存，并将不同类别的文件放在不同的目录中，比如/images/dynamic、images/static、images/navigation 等等，那么通过 MMC 设置缓存策略是很容易的。但是，如果你没有这样设计过你的站点，或者你正在优化一个现有的站点，你可能真的必须为每个文件设置策略，这将是一件相当麻烦的事情。

更麻烦的是，与 Apache 不同，IIS 没有提供简单的方法来授权开发人员设置缓存策略，因为修改所需的设置需要 MMC 访问。幸运的是，在启用 mod_expires 的情况下，IIS 和 Apache 之间的这些功能差距可以通过第三方工具(如 Port80 Software 的 CacheRight)很容易地弥补。

CacheRight 模仿 mod_expires，创建了一个基于文本的规则文件，它位于每个网站的文档根目录中，允许管理员和开发人员为整个网站设置过期指令。此外，CacheRight 通过添加一个`ExpiresByPath`指令来补充`ExpiresByType`指令，超越了 mod_expires。利用此功能，可以非常轻松地为给定类型的文件设置通用缓存控制策略，并为该类型的文件子集设置更具体的策略来覆盖该规则，如下例所示:

```
ExpiresByType image/* : 6 months after access public    

ExpiresByPath /navimgs/*, /logos/* : 1 year after modification public
```

在这里，除了位于`navimgs`和`logos`目录中的映像之外，所有映像的新鲜期都是六个月。像 mod_expires 一样，CacheRight 允许您设置相对于文件修改时间以及用户第一次访问的过期时间。当发布或更新计划不是一成不变时，这种灵活性非常有用，当然，这在 Web 开发中太常见了。

无论您使用哪种服务器，花时间弄清楚如何在服务器级别管理缓存控制都是非常值得的。与编程式缓存控制一样，行为良好的中间缓存会尊重这些指令，而不仅仅是浏览器缓存，就像在`<meta>`标记方法中一样。此外，与基于编程或`<meta>`标签的缓存控制不同，基于服务器的缓存控制可以轻松地为站点中所有真正重要的对象(如图像或 Flash 文件)设置缓存策略。正是在这些对象的缓存中，性能的提高最为明显。

##### 结论

虽然我们只是触及了缓存这个复杂主题的表面，但希望我们已经揭示了网站性能的这个不被重视的方面。特别是，我们希望您能够更好地理解为什么为您的站点制定一套缓存控制策略是至关重要的，并且您已经获得了一些关于如何有效地实施这些策略的想法。

正确应用缓存规则的结果是显而易见的——为您的最终用户，尤其是回头客，显著加快页面加载速度。此外，您将更有效地利用带宽和服务器资源。事实上，所有这些改进都可以通过加强对 HTTP 头的关注来实现，这使得有效的、基于过期的缓存控制成为您对站点进行的最经济高效的性能优化之一。

下周，我们将通过关注 Web 服务器的修改，特别是标准的 HTTP 压缩，来总结这个关于经济高效的网站加速的系列。然后，我们将展示一个案例研究，展示通过将所有技术结合使用可以获得的具体性能提升。

##### 第 3 部分–服务器端修改

在本系列的第一部分中，我们介绍了 Web 性能的两个基本法则。提醒你一下，这些是:

1.  发送尽可能少的数据

3.  尽可能不要发送它

在那篇文章中，我们重点讨论了规则一，并提供了 20 个技巧来通过代码优化从交付的页面中挤出每一个字节，远远超越明显占用带宽的图像，到 JavaScript、HTML、CSS，甚至文件名优化。

在第二部分中，我们转向了规则二，并了解了如何通过使用缓存控制头来增强站点性能。我们发现缓存控制的最佳方法是在服务器级别。

因此，在这最后一期文章中，我们将从 HTTP 压缩开始，看看还可以做哪些服务器端的改变来加速站点交付。

##### HTTP 压缩到底是什么？

HTTP 压缩是一个历史悠久的 Web 标准，只是现在才受到应有的重视。HTTP 压缩的基本思想是将标准的 gzip 或 deflate 编码方法应用于 HTTP 响应的有效负载，在资源通过 Web 传输之前对其进行大幅压缩。

有趣的是，自 4.0 早期以来，该技术在所有主流浏览器实现中都得到了支持。x 世代(用于 Internet Explorer 和 Netscape)，然而很少有网站真正使用它。Port80 Software 的一项研究显示，不到 4%的财富 1000 强网站在其服务器上采用 HTTP 压缩。然而，在领先的网站上，如谷歌、亚马逊和雅虎！HTTP 内容编码几乎无处不在。鉴于它为 Web 上一些最大的站点节省了大量带宽，进步的管理员应该自己探索 HTTP 压缩的想法。

HTTP 内容编码的关键可以在浏览器发送的 Accept 请求头中找到。考虑下面来自 Mozilla Firefox 的请求，特别注意`Accept`、`Accept-Language`、`Accept-Encoding`和`Accept-Charset`头:

```
GET / HTTP/1.1     

Host: www.port80software.com     

User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.6) Gecko/20040206 Firefox/0.8     

Accept:text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,     

text/plain;q=0.8,video/x-mng,image/png,image/jpeg,image/gif;q=0.2,*/*;q=0.1     

Accept-Language: en-us,en;q=0.5     

Accept-Encoding: gzip,deflate     

Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7     

Keep-Alive: 300     

Connection: keep-alive
```

服务器可以使用这些“接受”值来确定使用[内容协商](https://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html)发回的适当内容——这是一个非常强大的功能，允许 Web 服务器根据用户特征返回不同的语言、字符集，甚至技术。内容协商是一个非常广泛的话题，所以我们将只关注与服务器端压缩相关的元素。`Accept-Encoding`头表示除了标准的纯文本响应之外，浏览器可以接受的内容编码类型，在本例中是 gzip 和 deflate 压缩的内容。

查看 Internet Explorer 的请求头，我们看到类似的`Accept-Encoding`值:

```
GET / HTTP/1.1     

Host: www.google.com     

User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)     

Accept:image/gif,image/x-xbitmap,image/jpeg,image/pjpeg,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,application/x-shockwave-flash,*/*     

Accept-Encoding: gzip,deflate     

Accept-Language: en-us     

Connection: keep-alive
```

鉴于目前使用的几乎所有主流浏览器都支持 gzip 和 deflate 编码(少数不支持 gzip 和 deflate 编码的浏览器不应该发送`Accept-Encoding`头)，我们可以很容易地修改 Web 服务器，将压缩内容返回给某些浏览器，将标准内容返回给其他浏览器。举个例子(如下图)，如果我们的浏览器告诉 Google 不接受内容编码，我们得到的是 3358 字节的数据；然而，如果我们发送了`Accept-Encoding`头，我们得到的只是 1213 字节的压缩数据，以及一个表示`Content-Encoding: gzip`的响应头。如果您“查看源代码”，您不会看到页面之间的任何差异，但是如果您有网络跟踪，您会注意到响应是不同的:

![acceleration3fig1](../Images/d1c86bb63ecd077aed4ae04492c12e96.png)
*谷歌压缩/未压缩对比*

虽然在这种情况下，文件很小，但您可以看到减少的幅度仍然很大—在这种情况下，文件大小减少了 74%。通过 HTML、CSS、JavaScript 代码优化(如本系列第一部分所述)和 HTTP 内容编码的结合，Google 实现了一个令人印象深刻的壮举——将其页面放入一个 TCP 响应包中！

虽然 Google 对带宽的关注可能远远超过一般网站，但 HTTP 内容编码可以将 HTML、CSS、JavaScript 和纯文本文件的大小减少 50%或更多。不幸的是，HTTP 内容编码(术语“压缩”和“内容编码”大致同义)实际上只适用于文本内容，因为压缩像图像文件这样的二进制格式通常没有任何价值。即使假设二进制文件构成了一般站点的大部分有效负载，如果使用 HTTP 内容编码，您仍然会看到平均 15-30%的页面大小总体减少。

##### 服务器对 HTTP 内容编码的支持

如果你已经确信 HTTP 压缩的价值，下一个大问题是:你如何使用它？在 Apache Web 服务器的情况下，可以使用 [mod_gzip](https://www.sitepoint.com/web-output-mod-gzip-apache/) 或 [mod_deflate](https://www.sitepoint.com/mod-deflate-apache-2-0-x/) 来添加 HTTP 内容编码。

在微软 IIS 的情况下，事情会变得有点棘手。虽然 IIS 5 包含对 gzip 编码的本机支持，但它是一个众所周知的错误实现，特别是考虑到为了克服各种浏览器差异而必须进行的细粒度配置更改。因此，在 IIS 5 的情况下，ISAPI 过滤器形式的第三方压缩插件，如 httpZip、PipeBoost 和 XCompress，通常是最佳选择。

IIS 6 内置压缩要快得多，也更灵活，但是如果不进入 [IIS 元数据库](http://weblogs.asp.net/owscott/archive/2004/01/12/57916.aspx)，仍然很难以基本的方式进行配置。ZipEnable 代表了第一个被设计成允许对 IIS 6 内置压缩进行真正细粒度管理的工具。

##### 服务器端内容编码的真正问题

当您实现 HTTP 压缩时，有一个重要的权衡需要考虑；如果您将服务器配置为在输出时压缩内容，您可能会减少带宽使用，但同时会增加 CPU 负载。在大多数情况下，这不是问题，特别是考虑到 Web 服务器实际上做的工作很少。

然而，对于一个流量非常高的网站，在已经达到可用 CPU 周期极限的服务器上运行大量动态内容，压缩的缺点实际上可能超过优点。当然，添加额外的服务器硬件会缓解这个问题，并让您享受压缩带来的大量带宽节省。带宽开支和其他基础设施成本(更少的路由器、交换机和专用线路)的减少是否超过新硬件的前期投资，这取决于您。

尽管最终，HTTP 压缩最有趣的方面是开发人员和管理员在推出它时期望看到的，而不是他们实际看到的。虽然您肯定会发现带宽利用率降低了，但您的所有用户可能都享受不到显著加快的页面加载速度。由于压缩和解压缩过程增加了 CPU 负载，到达第一个字节的时间(TTFB)通常会增加；因此，浏览器不能稍后才开始绘制页面。

对于慢速(即低带宽)连接的用户来说，这仍然是一个很好的权衡；因为数据被压缩成更少、更小的包，所以它将被更快地传送，所以更快的整体页面绘制远远超过了最初的轻微延迟。另一方面，宽带用户可能看不到 HTTP 压缩带来的明显的性能改善。在这两种情况下，您将通过减少带宽来节省资金。但是，如果感知响应时间是您的主要目标，并且您要处理大量的拨号流量，那么您可能希望首先将缓存(在第二部分中讨论)作为一种性能增强策略。

HTTP 内容编码的另一个潜在问题是来自脚本生成页面的服务器负载，比如 PHP 或 ASP 中的脚本。这种情况下的挑战是，可能必须为每个请求重新压缩页面内容(而不是压缩一次然后缓存)，这将为服务器增加大量负载，超过静态内容压缩所增加的负载。如果所有页面都是在页面加载时生成的，那么在添加 HTTP 内容编码时就应该小心。幸运的是，许多商业压缩插件知道在可能的时候缓存生成的内容，但要知道一些更便宜的解决方案缺乏这一重要功能。然而，这个“问题”确实指向了第二个明显的服务器端性能改进——页面预缓存。

##### 动态页面:现在构建还是以后构建？

有趣的是，许多开发人员在访问时动态构建他们站点的许多或所有页面。例如，URL http://www.domain.com/article.php?id=5 表示该页面是通过数据库查询或模板填充构建的。这种常见做法的问题是，在许多情况下，在请求时构建这样的页面是没有意义的，因为大多数时候它主要是静态的。所谓的静态动态页面，或脚本页面，其内容在很长一段时间内不会改变，显然对改善页面交付时间没有任何帮助。事实上，在一个流量很大的网站上，它们会不必要地让你的服务器陷入瘫痪。

解决不必要的动态页面生成问题的一种方法是，每次页面发生变化时，将页面预构建为带有. html 扩展名的静态内容页面。优选地，任何这样生成的页面不仅是静态 HTML 文件，而且是代码优化版本(如第一部分所讨论的)。这不仅使服务器更容易快速发送页面，因为它在返回页面之前不需要做任何工作，而且这种技术实际上使站点对搜索引擎更友好。

不幸的是，在许多情况下，简单地将页面生成为静态 HTML 是不可能的，因为页面确实有必须在页面查看时执行的动态内容。在这种情况下，最好的办法是将页面“烘焙”成执行速度更快的形式。在 ASP.NET 的情况下，这将利用字节码格式，这对于服务器来说执行起来要快得多。不幸的是，在让用户访问页面之前，您需要通过先执行页面来强制执行字节码。幸运的是，即将到来的 ASP.NET 2.0 版本将有助于减轻一些开发者目前承担的令人厌倦的任务，即“触摸”所有页面一次，以确保用户快速首次下载。就 PHP 而言，你可能会发现像 [Zend](http://www.zend.com) optimization suite 这样的产品是明智的投资。

考虑到服务静态和动态页面，或者 HTML 和图像的不同需求，重新考虑物理服务器和其他硬件以获得额外的加速想法似乎是明智的。一个更聪明的想法是专业化——不同的元素需要以最高的效率做不同的工作，这种想法可以引导人们为了网络加速而增加或增强硬件。尽管以节约成本的名义，我们在本系列中主要关注的是源代码和 Web 服务器(以及相关的)软件，现在让我们快速地看一下这些其他的元素。

##### 加速您的网络服务器

为了加速你的站点，一个好的地方是服务器软件和硬件本身。从软件开始，Web 管理员不太可能很快抛弃 IIS for Apache 或 Apache for IIS，即使安全性、易用性或性能被作为离开一个阵营去另一个阵营的理由。简而言之，Web 服务器及其相关的操作系统经常与网站交织在一起，以至于迁移成为一项繁重甚至危险的任务。如果你开始考虑放弃一个平台，转而使用另一个平台，你也应该认真考虑替代平台，比如 Zeus T1，尤其是当速度是首要考虑因素的时候。

就硬件而言，请仔细考虑服务器执行的主要任务。在静态网站的情况下，它主要是编组网络连接和将文件从磁盘复制到网络。为了加速这样一个站点，您需要专注于构建一个 Web 服务器，它具有非常快的磁盘和网络子系统，以及足够的内存来处理并发请求。事实上，您可能会选择非常积极地为系统增加内存，并尝试在内存中缓存所有频繁使用的对象，以完全避免磁盘访问。有趣的是，在一个提供静态文件的站点中，处理器速度并不像你想象的那么重要；这确实有所帮助，但磁盘往往会成为更大的瓶颈。

当站点同时提供动态和静态页面时，显然，处理器速度变得更加重要，但即使在这种情况下，拥有一个快速驱动器或双网卡仍然更加重要。另一方面，大量动态页面生成与 SSL 和/或 HTTP 压缩等其他处理器密集型任务的结合，使得 CPU 更有可能是需要增强的资源。换句话说，服务器做什么将决定如何最有效地增强它。

即使您没有预算来定制您的服务器硬件或软件，也可能有一些您可以相当便宜地进行的更改。例如，您可以考虑调整操作系统的 TCP/IP 设置，以便最有效地利用 HTTP 所依赖的底层 TCP/IP 资源。这可能需要将 TCP 接收窗口调整到最适合您的应用程序和服务器网络连接的大小。您可以确保使用或不使用可以切换的 TCP 功能，如延迟 ack 或 TCP_NODELAY，这同样取决于应用程序和网络环境的特征。或者只是简单地确保你的机器不会因为过多的等待时间或其他原因而出现端口耗尽。

但是，在改变网络特性之前，无论是在 Web 服务器上还是在操作系统上，都要确保设置真实的负载测试，以验证您的改进实际上没有降低用户速度或导致网络上的过度重新传输。换句话说，不要试图实现这些类型的修复，除非您了解如何衡量它们的价值。

##### 分工加速

解决站点加速的另一个考虑是，不是每种形式的站点内容都有相同的交付特征。鉴于不同的内容具有不同的特征，我们可能会发现，将一个站点的特定服务职责划分给几个服务器比简单地在一个服务器群中平均复制站点职责要好。

一个简单的通过分工加速的例子发生在一个站点对购物车或外联网使用 SSL 加密的时候。在 SSL 的情况下，当您的站点的 https 部分有多个用户时，您可能会发现您的服务器很快就瘫痪了，这是由于加密带来的巨大开销。在这种情况下，将这种流量转移到另一台服务器上是有意义的。例如，你可以把你的主网站放在 www.domain.com，并把网站的结账部分链接到 shop.domain.com。shop.domain.com 服务器可以是一个特殊的设备，用来处理 SSL 流量，可能使用 SSL 加速卡。

细分可以让你把必要的资源集中在结账的用户身上，而不会让那些只是浏览的用户陷入困境。您甚至会发现，为您的图像或其他繁重的二进制文件(如 PDF 文件或。从一台服务器下载. EXE 文件可能是有意义的，因为这些连接比普通连接需要更长的时间来关闭，同时，占用了宝贵的 TCP/IP 资源。此外，您不必为媒体服务器上的 HTTP 内容编码费心，但当然会将它应用于 HTML、CSS 和 JavaScript 的主文本服务器。这样，为了优化带宽，您可以最大限度地利用该服务器未充分利用的 CPU，同时让媒体服务器的 CPU 自由工作。

分段可以进一步应用于生成的页面。您可能会考虑从专门构建的机器中提供生成的页面，将静态内容卸载到不同的机器上。许多网站已经采用了这样的场景，使用反向代理缓存，如 [Squid](http://www.squid-cache.org) 。在这个设置中，代理快速提供静态内容，而后端服务器构建真正必须在页面查看时生成的内容。在这种类型的设置中，本系列第二部分中讨论的缓存控制策略和规则变得非常重要；您需要确保代理服务器的缓存存储了所有可以安全地存储在共享缓存中的内容，并且不会保留任何只针对特定用户的内容。

##### 出售速度

在本系列中，我们主要关注低成本加速技术，但是当我们接近尾声时，成本以新软件和新硬件的形式出现。通过购买特殊的加速设备，为你的站点执行连接卸载、压缩、缓存和各种其他功能，在 Web 加速上花费相当多的钱是可能的。如果您的带宽费用非常高，这些解决方案可能会非常有效，但大多数网站可以坚持使用我们在这里讨论的更便宜的方法，如代码优化、缓存和 HTTP 编码。

然而，即使你真的有很多钱，能够建立一个专门的服务器场，并添加外来的加速设备，你最终会达到从压缩和缓存内容中获得的好处的极限。为了提高速度，现在你只有最后一个选择——让内容更接近用户(如果可能的话，再次应用所有相同的技术)。您可能已经注意到，提供下载的网站通常会镜像内容，以便用户可以从多个位置下载。然而，有可能以更加地理敏感的方式提供内容，并且透明地这样做。

像 [Akamai](http://www.akamai.com) 这样的内容分发网络(cdn)允许我们通过利用位于世界各地的数千个边缘缓存，将大量内容(如图像和其他二进制下载)转移到离用户更近的地方。虽然这种技术提供了显著的性能改进，并被世界上最大的网站广泛使用，但它肯定不属于经济高效的范畴，因此我们提到它只是为了遵循我们的加速选项来得出它们的逻辑结论。

在您采取这些极端的、通常是不必要的措施之前，我们用一个简单的例子来结束我们的系列，这个例子说明了我们在过去三周提出的低成本想法是如何改善一个真实站点的页面加载时间、带宽使用和服务器负载的，在这个例子中，我们来看看 SitePoint.com 的主页本身。

##### 应用加速度:SitePoint.com

让我们用 Internet Explorer 6.0 打开 SitePoint.com 主页。当我们第一次请求 SitePoint.com 时，我们看到主页实际上由大约 37 个不同的对象组成。但是，我们也马上注意到 SitePoint 的开发者正在做一些有趣的事情来加速他们的主页:

1.  在页面的主要或包含部分，HTML 内容使用 HTTP 内容编码(特别是 gzip)进行压缩。如果没有 gzip，原始文件大小将是 28，218 字节。有了它，传输的大小只有 7，774 字节，节省了大约 72%。SitePoint 的拨号用户肯定会为此感谢他们。仔细观察响应头，我们会发现同样的页面也是使用分块传输编码发送的，这有助于减少与 HTTP 压缩相关的首字节时间损失。这意味着，即使是宽带用户也可能体验到更快的页面加载速度。

*   我们还从响应头中了解到，虽然主页是使用 PHP 动态构建的，但开发人员已经通过使用第三方工具最小化了性能影响，该工具预解释 PHP 脚本并将解释后的指令缓存在内存中(答案是响应头 X-Accelerated-By: PHPA/1.3.3r2)。有了这样的脚本缓存，页面仍然是动态的(在某种意义上，它的 HTML 输出没有被缓存)，但是避免了每次请求时加载脚本并将其解释为可执行指令的服务器端开销——这是完全预生成和纯动态页面之间的一个很好的折衷。

SitePoint.com 还能以低廉的成本做些什么来进一步优化事情吗？有几种可能性，我们在下表中进行了总结:

此表(单击此处查看大图)分两个阶段显示了文件大小减小的效果——首先，应用本系列第一部分中描述的源代码优化(“优化”一栏中的字节数),然后应用 HTTP 压缩，这是我们在本文中讨论过的(“Gzipped”一栏中的字节数)。我们已经给了主页面(index.php)的压缩(gzipped)大小，就像我们在 IE 中得到的一样，但是我们没有对它应用源代码优化，因为它是动态的。

然而，除此之外，还有八个静态外部文本文件(5 个 CSS 和 3 个 JavaScript)根本没有经过压缩或代码优化，但肯定会从两者中受益。我们已经在这里展示了结果，正如您在“节省百分比”列中看到的，由此产生的总体节省是巨大的——仅通过源代码优化，整个主页(包括所有依赖项)就节省了 13%,通过源代码优化加上 HTTP 压缩，节省了 50%。如果 index.php 也是源代码优化的，这些百分比可能会更高(这可能会产生额外的 1000 字节左右)。

最后两个专栏关注本系列第二篇文章的主题:缓存控制。除了少数外部托管或高度专业化的资源，SitePoint.com 主页上没有使用基于到期的缓存控制。“重估？”列显示了哪些文件需要在回访时重新验证，即使它们存在于浏览器的缓存中。SitePoint 可以考虑更广泛地使用显式到期时间，特别是对于构成主页的大量相对不变的图像，以及包含 CSS 和 JavaScript 的静态外部文本文件。为这样的对象创作和实现一组好的缓存控制策略将有助于避免当用户在新的浏览器会话中返回主页时重新验证已经缓存的对象所需的 31 次单独的客户机-服务器往返中的一些或全部。对于每个返回页面视图，服务器日志中的 304 未修改消息减少了 31 条，但更重要的是，还会减少访问者返回页面的加载时间。

最后一列显示，这些重新验证的往返每次需要 1 到 7 秒。即使当用户返回主页时，它们中的许多同时发生(并且在这个过程中占用了服务器端的大量 TCP 资源！)，与从浏览器缓存中即时提供这些相同的对象相比，这仍然是一个很长的等待时间——在任何情况下，浏览器缓存都是这些对象的来源。

##### 结论

我们简单的案例研究清楚地表明，当一起使用时，本系列中介绍的技术可以显著改善几乎所有网站的服务器负载、带宽使用和页面加载时间。所有这些实现起来都相对简单，并且都不需要在新硬件或软件上花费大量资金。

诚然，任何加速技术都有缺点；代码优化需要开发人员投入时间，缓存需要开发和管理之间加强协调，为了节省带宽，压缩会占用服务器资源。

总之，我们希望我们已经让你更好地理解了网站性能背后的原理，以及一些具体的增强技术，这将有助于你小心翼翼地踩油门。

***关于作者***

![author_tompowell](../Images/a22cf90a0daaa11daabb0c6dac33f0bc.png) [Thomas Powell](mailto:tpowell@pint.com) 是 [PINT，Inc.](http://www.pint.com) 的创始人，UCSD 计算机科学系的讲师，也是 Web 开发书籍的作者，包括 *HTML & XHTML:完整参考*和 *JavaScript:完整参考*。

![author_joelima](../Images/3060bfc6760368ddd725564e0040126a.png) [乔·利马](mailto:jlima@port80software.com)是 [Port80 软件](http://www.port80software.com/?source=sitepoint)的首席架构师，该公司开发 IIS 服务器模块，如 [CacheRight](http://www.port80software.com/products/cacheright/?source=sitepoint) 、 [httpZip](http://www.port80software.com/products/httpzip/?source=sitepoint) 和 [ZipEnable](http://www.port80software.com/products/zipenable/?source=sitepoint) 以及 Web 开发工具，如[w3 编译器](http://www.w3compiler.com/?source=sitepoint)。Joe 还教授 UCSD 扩展的 Web 服务器技术。

## 分享这篇文章**