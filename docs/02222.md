# AtoZ CSS 截屏:浮动和清晰

> 原文：<https://www.sitepoint.com/atoz-css-screencast-float-and-clear/>

这个截屏是我们 AtoZ CSS 系列的一部分。你可以在这里找到系列[的其他条目。](https://www.sitepoint.com/blog/)

## 副本

float 属性最常用于页面布局。

然而，`float`的最初目的是让文本环绕对象，这在印刷设计中很常见。

由于`float`经常不按最初的意图使用，使用它可能有点脆弱和棘手，直到你习惯了它的怪癖。

我们将首先看一下`float`的预期用途。然后我们将看看如何创建 2 列和 3 列布局，最后看看如何处理一些棘手的浮动部分；清除它们并处理集装箱倒塌。

### 预期用途

浮动属性接受 3 个值，`left`、`right`或`none`。

如果我们获取一幅图像和几段文本，并将图像向左浮动，我们就可以看到浮动属性在 web 上的预期用途；文字环绕图像，一切看起来都很棒。我们可以通过设置`float: right`将图像移动到对面，或者使用默认的`float: none`将其完全移除。

```
img {
  float: left;
}
```

### 两列布局

我们可以更进一步，并排浮动两个内容块来实现两列布局。

这里，主内容容器的宽度为 60%，向左浮动，其最左边与其父容器的最左边对齐。

侧边栏的宽度为 30%，并向右浮动。它们之间有 10%的差距，这提供了一些喘息的空间。

```
.main-content {
  float: left;
  width: 60%;
}
.sidebar {
  float: right;
  width: 30%;
}
```

### 三列布局

那么如何才能做出 3 列布局呢？

当一系列盒子都向一个方向浮动时，它们会彼此相邻对齐。这是因为浮动元素会将其左侧与其父元素或最近的浮动元素的最左边对齐。如果所有三个框的`width`都是 33.333%，并且我们使用的是`box-sizing: border-box`，那么我们会得到一个相等的 3 列布局。想了解更多关于`box-sizing`的信息，请查看[《第二集:`Box-Model`。](https://www.sitepoint.com/atoz-css-screencast/)

```
.box {
  -moz-box-sizing: border-box;
       box-sizing: border-box;

  width: 33.333%;
  float: left;
}
```

我们可以通过将框向右浮动来实现同样的三列。但在这种情况下，第一个盒子将其最右边的边缘与容器的边缘对齐，然后下一个盒子尽可能向右浮动，以此类推。这里的结果是相同的，但是内容顺序颠倒了——这在响应式设计中处理源顺序时会很方便。

### 结算浮动

与`float`齐头并进的另一个属性是`clear`。

当元素浮动时，它们会导致任何相邻的元素试图绕过它们，这会导致布局看起来有点奇怪。一个典型的例子是两个浮动列下面的页脚。

让我们采用之前的两列布局，添加一些尺寸和一些背景颜色，这样我们就可以看到发生了什么。如果我们现在在列下添加一个页脚，我们会得到一个稍微奇怪的行为。

这是因为页脚试图围绕两个浮动列流动，而不是从它们下面开始。我们可以通过将`clear`属性添加到页脚来解决这个问题，如果将它设置为`both`的话，它会清除任何一边的浮动效果。其他可用值与`float` — `left`、`right`或`none`相同。

```
footer {
  clear: both;
}
```

### 集装箱倒塌

浮动导致了另一个布局问题，这个问题有时很难发现。

这里我有一个包含三个浮动元素的部分。该部分有一个粉红色的背景-但这似乎是不可见的。如果我们检查这个截面上的元素，我们看到它的高度是 0。

由于该部分只包含浮动元素，它无法自动计算包含这些框所需的高度。

我们可以通过添加第四个元素并在其上设置 clear 属性来解决这个问题。但是这很笨拙，而且添加一个纯视觉目的的空元素对于编写干净的标记来说不是一个好的实践。

```
.clear {
  clear: both;
}
```

另一种选择是为该部分创建一个新的块格式上下文，其中将包含所有的浮动。

当使用某些值时，`float`、`position`、`display`和`overflow`属性都可以用来创建新的块格式化上下文，但是最常用的防止容器折叠的属性是`overflow: hidden`。

```
section {
  overflow: hidden;
}
```

如果我们移除空地`<div>`并将`overflow: hidden`放在部分上，集装箱倒塌的问题就解决了，整个事情感觉不那么糟糕了。

隐藏元素的`overflow`并不总是可能的，任何有意重叠或超出框边界的内容都将被隐藏。处理容器崩溃的一个更健壮的方法是使用一个*伪元素*来进行清理。我们将在第 16 集把伪元素作为主要话题，但这里有一个方便的片段，可以同时修复容器崩溃。

```
/*source: Nicolas Gallagher*/
/*http://nicolasgallagher.com/micro-clearfix-hack/*/
.clearfix:before,
.clearfix:after {
  content: " ";
  display: table;
}
.clearfix:after {
  clear: both;
}
```

通过将这个代码片段添加到您的 CSS 中，并将类`.clearfix`添加到您想要防止折叠的元素中,“不可见的”`:after`伪元素完成了我们清除前面示例中的`<div>`的工作。

现在我们解决了容器崩溃的问题，不会遇到隐藏溢出的问题，并尽可能保持标记的整洁，这是一个双赢的局面。

请关注我们即将发布的快速技巧文章！

## 分享这篇文章