# 赛璐珞简介，第一部分

> 原文：<https://www.sitepoint.com/an-introduction-to-celluloid-part-i/>

![](img/8da2a7f96f76ac08c426d9bb5534b058.png "logo")

几年前，曾经有一种非常简单的优化代码的方法。如果您发现您的处理器密集型代码运行速度比您希望的要慢一些，简单的解决方案就是等待下一次硬件迭代，这将神奇地提高 CPU 的时钟频率，您的应用程序将突然运行得更快。

不幸的是，那些时代已经过去了。由于逻辑门(运行处理器的极其微小的电子控制“开关”)内部有一种称为“转换能量”的东西，以合理的价格进一步提高时钟频率几乎是不可能的。但是，一个聪明的解决方案很快被发现。我们没有试图让一个处理器以极快的速度运行，而是将工作负载分散到多个处理器上。多好的主意啊！

对于编写软件的人来说，理解并发并很好地使用它突然变得非常重要。为了与硬件一起扩展，您的代码必须使用并发！起初，这对每个人来说似乎都很简单；不会那么难吧？嗯，确实是。最流行的并发机制是线程，它非常复杂。这里或那里的一些小错误会造成严重破坏。如果你真的对这类东西感兴趣，我会推荐你读读[小](http://en.wikipedia.org/wiki/Race_condition)。

如果你有足够的勇气点击其中的一些链接，你应该很快就会意识到线程管理并不总是在公园里散步。例如，考虑死锁。

## (死)锁定

假设有两个人都有一本他们都想读的书。假设他们不能同时阅读同一本书，那么一个人必须等到另一个人读完。现在，考虑一种情况，每个人都认为另一个人还没有读完这本书，因此决定不开始读它。现在，两个人都不读这本书了。

这种情况称为死锁。

如果你的程序有两个“线程”(类似于我们讨论的两个人)，它们都写一个名为“steve”的文件。这两个线程不能同时写入文件，因此当一个线程写入文件时，文件被“锁定”。共享变量也可能出现类似的情况。

当然，这种情况很好，但是当有一些错误导致文件被两个线程锁定时，问题就出现了。如果你写过任何数量的线程驱动代码，你就会知道这种情况经常发生。当它出现时，追踪和修复是一件非常痛苦的事情。

## 竞赛条件

在死锁中，两个线程永远互相等待。然而，死锁有一个同样糟糕的表亲，如果不是更糟糕的话。

当两个线程试图同时访问和写入一个变量时，就会发生争用情况。因此，两个线程都读取变量，然后每个线程比赛看谁能第一个/最后一个写入变量。

这会导致各种各样的问题，因为它可能会导致一个线程对变量的更改被另一个线程完全破坏。

## 解决方案？

上面提到的两个问题只是冰山一角——在使用线程时还有各种各样的其他问题需要处理。

大约在 20 世纪 80 年代，人们开始思考所有这些问题到底从何而来，以及如何解决它们。他们发现，几乎所有这些问题都是由共享状态(即变量、文件等)引起的。)和锁定。如果您忘记锁定一个共享资源，那么将会有一大堆线程问题等着您。

提出了多种解决方案，其中之一是 evented I/O，对于 ruby 爱好者来说，这意味着 [eventmachine](https://www.sitepoint.com/introduction-to-event-machine) 。

与此同时，一些聪明的学者提出了一个新模型，该模型吸收了量子物理学的一些想法。整个并发系统不是共享状态，而是基于传递消息。他们称之为演员模型。

## 演员模型

在参与者模型中，每个对象都是一个参与者。每个参与者都可以向其他参与者发送和接收消息，如果需要，还可以创建其他参与者。所有这一切的要点是，所有通信都可以是异步的，参与者之间不共享任何状态。这意味着可以在发送消息的同时接收其他消息。此外，当一个参与者发送消息时，它并不总是需要等待响应。进程间共享的状态完全是通过消息传递来完成的。

如果你不理解这其中的大部分，那也没关系，跟着做就好了。

当然，这些都不会自己发生。一个名为(Celluloid)[http://Celluloid . io/]的库实现了这一点，这就是我们将要使用的！

## 赛璐珞

赛璐珞给 Ruby 带来了 actor 模型，使得编写并发应用程序变得异常容易。

首先，赛璐珞有内置的死锁保护，因为演员之间的所有消息传递都是以死锁几乎不可能的方式处理的，只要你没有做一些疯狂的事情或弄乱本机(即 C)代码。

如果你熟悉 Erlang(不熟悉也没关系)，赛璐珞借用了它最重要的思想之一:容错。赛璐珞会自动重启并处理崩溃的演员，所以你不必担心所有可能出错的事情。

还有各种各样的其他功能(链接、期货等。)这使得线程化变得轻而易举，但是需要记住一些事情。

## 那个女孩

我们都熟悉的“常规”或普通 ruby 是由 MRI 或 YARV 支持的，它们是 Ruby 的不同类型的解释器/虚拟机。

现在，这个解释器有一个有争议的问题。问题是，MRI/YARV 中的所有线程并不是真正并发的——所有的东西都在一个线程下运行。这被称为全局解释器锁。Ruby 并不是唯一拥有解释器的语言 Python 也是，甚至不要让我开始用 PHP 做线程。

当一个新的线程被创建时，结果是所执行的计算实际上并没有和其他事情同时被执行。会产生一种错觉，使用户认为这就是正在发生的事情。

幸运的是，有一个解决方案。只是使用不同的解释器！挑选你喜欢的:

*   (JRuby)[jruby.org]
*   (Rubini.us)[http://rubini.us/]

请注意，如果您选择使用上述解释器之一，请确保您在 1.9 模式下操作，以便与赛璐珞兼容。

## 潜入水中

让我们从编写一个小演员开始，让它读取我们告诉它的文件，然后在需要时显示结果。