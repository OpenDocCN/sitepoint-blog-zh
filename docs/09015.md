# 红宝石高尔夫

> 原文：<https://www.sitepoint.com/ruby-golf/>

![](img/fc1684dc30788d6d762f307eeef67fcf.png)

Ruby golf 是使用尽可能少的字符编写代码的艺术。这个想法起源于 Perl 世界(毫不奇怪，它被称为 Perl Golf)。作为一种语言，Perl 非常适合这一点，因为它有着超乎寻常的结构和语法。Ruby 还包含一些大块的语法糖，这使得它适合打高尔夫。

试图最小化程序中使用的字节数的困扰可以追溯到过去的时代，那时内存非常珍贵，每个字节都很重要。它在当今世界并没有什么实际用途，但这并不意味着它不再被使用。代码最小化可以在诸如 [1k JavaScript 竞赛](http://js1k.com/)和 [Perl 启示录](http://dev.perl.org/perl6/doc/apocalypse.html)的竞赛中找到。还有许多致力于代码高尔夫艺术的网站。

代码高尔夫通常有一个竞争因素:黑客们努力寻找“完美”的解决方案，试图超越彼此。一种能达到代码目的，但不可能用更少的字符完成的方法。我发现这类似于寻找“优雅证明”的数学学家，这让我想起爱因斯坦的名言“一切都应该尽可能简单，但不是更简单”。

不幸的是，产生的代码通常很难理解，因为它通常依赖于各种技巧和快捷方式。事实上，一个免费的游戏是尝试并找出产生的代码实际上做什么！聪明和太聪明之间往往只有一线之隔…

Code Golf 有点恶名远扬——人们要么喜欢它，要么讨厌它，所以为了保持平衡，我列出了在一两轮比赛中尝试的一些优势和劣势:

## 优势

*   你可以学习一些不太为人所知的语言部分和一些巧妙的技巧。
*   当你设法从最佳解决方案中去掉几个字符时，你会有一种很好的自鸣得意的感觉。
*   有时候，更简洁的代码编写方式实际上看起来更干净。
*   你可以学习在其他情况下可能有用的技巧。
*   这个过程本身鼓励独创性。
*   很好玩！

## 不足之处

*   代码通常看起来很可怕
*   代码通常很难阅读或理解，这是一个遗憾，因为 Ruby 最好的方面之一就是可读性。
*   代码将是一场维护的噩梦——即使是你自己也不要管别人。

## 专业提示

如果你想打高尔夫球，那么这里有一些技巧，可以用来削减你的 Ruby 代码，减少你的高尔夫差点:

*   **Mass Assignment**

    这是一个大多数人都知道的简单方法，但是一次分配所有变量将有助于减少代码膨胀。

    ```
    a,b = 1,2
    ```

*   **Create Arrays Using the Shortcut Notation %w**

    您可以使用以下符号创建字符串数组:

    ```
    a = %w(a b c) => ["a","b","c"]
    ```

*   **使用三元运算符进行逻辑运算**

    ```
    a>10?"too big":"fine"
    ```

*   **对更复杂的逻辑使用链式三元运算符**

    ```
    a<0?"no negatives":(a>10?"too big":"fine")
    ```

*   **Use Scientific Notation for Numbers**

    如果你需要大数字，那么`1e6`比`1000000`短。

*   **Use Dash-Rocket Syntax for Procs**

    如果你使用的是 Ruby 1.9，使用破折号火箭(`->`)语法来处理进程

    ```
    sayhello = -> {p "hello"}
    sayhello = -> name {p "hello #{name}"}
    ```

*   **1 Character Strings**

    对于 1 位数的字符串，使用`?x = "x"`(同样，这只适用于 Ruby 1.9)

*   **Learn Regular Expressions**

    正则表达式可以用几个字符表达一些复杂的表达式。

*   **Use the Modulo Operator to Test if a Number is a Factor**

    `12%3==0`，因为 12 是 3 的倍数
    `13%3!=0`，因为 13 不是 3 的倍数

    **编辑* *

    赛勒斯在评论中对此做了进一步的改进。你可以测试答案是否小于 1，而不是等于 0:

    ```
    12%3<1 => true
    ```

*   **Use Map to Iterate**

    迭代器通常比循环更好，而`map`是最好的迭代器，因为它的字符最少。它可以代替`each`使用，因为你不必改变数组中的每个元素，它仍然循环遍历数组。

    ```
    %w(a b c).map{|x| puts x}
    ```

*   **Use Symbol To Proc**

    这节省了大量时间(并且可能看起来更整洁)。

    ```
    %w(a b c).map{ |e| e.upcase }
    ```

    成为

    ```
    %w(a b c).map(&:upcase)
    => ["A", "B", "C"]
    ```

    实际发生的是`&`为后面的符号调用`to_proc`方法(在这个例子中，对数组的每个元素调用`upcase`方法。

*   **易联**
    `%w(a b c)*"-"`同`%w(a b c).join"-"`
    =>“a-b-c”
*   **Reuse Loops**

    避免对不同的对象类型使用两个循环的一个好方法是将所有的对象放入一个数组中，只使用一个迭代器，然后根据对象类型执行不同的任务。

    ```
    ["a","b",2,4].map{|e|(e.to_s==e)?(e.upcase):(e*2)}
    => ["A", "B", 4, 8]
    ```

*   **Testing Types**

    如果你想测试一个对象是否是一个字符串，那么`e.to_s==e`比`e.is_a? String`短。

你有什么其他的方法来降低自己的障碍吗？请在评论中留下你的建议。

## 几乎是辛纳特拉

康斯坦丁·哈塞(辛纳特拉绝地大师)将辛纳特拉(1646 行代码并不臃肿)压缩成区区 8 行代码，这是 Ruby golf 的一种极端形式。它没有相同的功能，但非常接近。他在做这件事的时候用了一些很棒的技巧，上面列表中的最后几个技巧来自于[差点辛纳屈代码](https://github.com/rkh/almost-sinatra)。

## 一个示例孔

作为一个例子，我试着写了一个方法，它可以找到一个给定数字的所有倍数的和，直到一个给定值。例如，sum(5，24)将计算 5 到 24 的所有倍数之和(即 5 + 10 + 15 + 20)。

这是我最后想到的:

```
def sum(n,t)
  n*(1..t/n).to_a.inject(&:+)
end
```

我利用符号来进行标记，使用 inject 方法对整数求和。通过进行整数除法并依靠余数被忽略的事实，找到了要求和的整数数。

这包含 27 个字符(不包括方法定义)。有人能打败它吗？如果可以，请在评论中留下你的答案。

## 竞争

现在是时候找出谁是红宝石界的老虎伍兹了。下面是组成 RubySource 高尔夫球场的五个“洞”。尝试其中的任何一个或全部，并在评论中发表你的解决方案。

## 第一洞:嘶嘶的嗡嗡声

给定一个数字，如果它是 3 的倍数，函数返回“Fizz ”,如果它是 5 的倍数，函数返回“Buzz ”,如果它是 15 的倍数，函数返回“FizzBuzz”。如果数字不是 3 或 5 的倍数，则数字以字符串形式返回。

#### 示例:

```
fizzbuzz(3) => "Fizz"
  fizzbuzz(10) => "Buzz"
  fizzbuzz(45) => "FizzBuzz"
  fizzbuzz(31) => "31"
```

## 第二洞:凯撒密码

实现凯撒移位密码

#### 示例:

```
caeser("hello",3) => "khoor"
```

你也应该能够产生负的变化。

## 第三洞:石头、布、剪刀游戏

编写一个简单的“玩”这个游戏的方法，玩家输入他们的“移动”作为方法的参数。如果玩家输入了一个无效的选项，那么结果应该是“输”。计算机应该随机选择它的移动。输出给出了计算机的“移动”和以逗号分隔的字符串形式的结果。

#### 示例:

```
play("Rock") => "Rock,Draw"
    play("Paper") => "Rock,Win"
    play("Scissors") => "Rock,Lose"
    play("Soap") => "Paper,Lose"
```

## 孔 4:字符串计数器

编写一个方法，当给定一个字符串和子字符串时，返回该子字符串在该字符串中出现的次数(忽略大小写)。

#### 示例:

```
count("Banana","a") => 3
    count("RubySource provides advice, tutorials, commentary, and insight into the Ruby and Rails ecosystem","ruby") => 2
```

## 第五洞:摇摆功能

写一个函数来代替“把你的钥匙放在罐子里”。该函数的参数是包含两个对象的数组的数组。该函数返回一个新数组，其中的对象对已经混合在一起。一个对象不应该以它的原始“伙伴”结束。

#### 示例:

```
swingers([["Homer","Marge"],["Micky","Minnie"],["Fred","Wilma"],["Peter","Lois"],["George","Judy"]])
=> [["Homer","Wilma"],["Micky","Lois"],["Fred","Judy"],["Peter","Marge"],["George","Minnie"]]
```

要参加，请在下面的评论中写下你的方法。其条目包含最少数量字符的人将赢得每个洞。每个洞的获胜者都有 Sitepoint book 可供争夺。可以用 Ruby 1.8 或者 1.9。截止日期是 2011 年 12 月 31 日。只有方法定义中的字符会被计算在内，所以我上面的例子中的洞会计算为 27 个字符。随意给你的代码贴上一个[要点](http://gist.github.com)。

前进！

## 分享这篇文章