# PHP 陷阱:第 1 部分

> 原文：<https://www.sitepoint.com/php-gotchas-part-1/>

PHP 是一门非常容易上手的语言，但是从那以后，如果我自己的经验是可靠的话，开发人员似乎在生产力方面经历了一次“过山车”。有人把 PHP 称为“开源的 Visual Basic”，这既是抱怨，也是补充。一句归功于[比雅尼·斯特劳斯特鲁普](http://www.research.att.com/~bs/homepage.html)(c++的设计者)的名言；"世界上只有两种编程语言:那些人们经常使用的语言和那些没人使用的语言."…

在接下来的几个星期(也许几个月)里，我将试图突出 PHP 的“陷阱”；使用 PHP 时，会导致开发人员速度变慢和头晕的事情。换句话说，这些问题在一开始并不明显，只有当你“亲身经历”后才会变得清晰。有些纯粹是技术问题(PHP 配置、遗留问题等)。)而另一些则更加理论化(就代码设计而言，哪些“可行”，哪些不可行)。

目的是给开始使用 PHP 的开发人员一个路标“陷阱”,并希望在挫折发生之前阻止它。将主要基于我自己近五年的 PHP 经验，以及我在 [Sitepoint 的 PHP 论坛](https://www.sitepoint.com/forums/forumdisplay.php?f=34)上看到的东西。非常感谢进一步的输入/见解，以及对主题的请求。

**PHP 环境和可移植性问题**

首先，这些是一些常见的与 php.ini 相关的陷阱。当在这里谈论“可移植性”时，我指的是在不同的 PHP 安装下运行代码，而不是操作系统的可移植性或与旧 PHP 版本的向后兼容性，这两者都需要单独研究。

其中一些已经在[这里](https://www.sitepoint.com/php-anthology-3-php-mysql/)讨论过了，所以请原谅我的重复；我认为尝试整理一个完整的列表是值得的，因为我在开源 PHP 项目中一次又一次地看到了这些问题。

基本的误解似乎是假设所有的 PHP 安装都是平等的；在一种环境下运行的代码应该在所有环境下都能正常运行。虽然这在很大程度上是正确的，但一些关键的 PHP 配置设置和遗留问题合在一起令人头疼。可以编写在任何 PHP 安装下都能运行良好的代码(假设 PHP 版本相当)，但是需要小心。

**控制运行时配置**

首先，您需要知道如何更改 PHP 的运行时配置(PHP 构建和安装时的运行时配置，而不是编译时配置)。

本质上，有四种基本机制来控制 PHP 的运行时配置； *php.ini* 文件，Apache*httpd . conf*文件(或者类似的，比如[Windows 注册表](http://www.php.net/manual/en/configuration.changes.php#configuration.changes.windows))，使用 Apache *。使用类似于 [ini_set()](http://www.php.net/ini_set) 的函数来访问*文件或者在脚本本身内部访问。值得阅读关于[运行时配置](http://www.php.net/manual/en/configuration.php)的手册，以及浏览[核心指令](http://www.php.net/manual/en/ini.php)和在 [ini_set()](http://www.php.net/ini_set) 下找到的或多或少完整的参考。更多的注释可以在 *php.ini* 文件中找到。

这里要注意的关键点是，在共享的 web 服务器上(你典型的 PHP 主机)，用户只能通过脚本本身和*可能*使用*来改变设置。htaccess* 文件(很少有主机会让用户改 *php.ini* 或者 *httpd.conf* )。用*改变设置。htaccess* 要求 Apache 配置为向用户提供“AllowOverride Options”或“AllowOverride All”权限(通常放在 *httpd.conf* 中的<directory>描述下)——这很常见，但不能 100%依赖。</directory>

更改运行时配置设置的机制取决于设置本身。查看在 [ini_set()](http://www.php.net/ini_set) 下找到的列表，您会注意到“可变”列中的值，如 *PHP_INI_PERDIR* 和 *PHP_INI_SYSTEM* 。这些实际上是常量，定义如下:

–*PHP _ INI _ USER*:配置选项可以在 PHP 脚本中更改(事实上你永远不会看到这个列表——它在下面的 *PHP_INI_ALL* 中)。

–*PHP _ INI _ PERDIR*:可以在 *php.ini* 、 *httpd.conf* 或 a *中更改设置。htaccess* 文件。

–*PHP _ INI _ SYSTEM*:只能在 *php.ini* 或 *httpd.conf* 中更改设置。

–*PHP _ INI _ ALL*:该设置可以通过所有可用的机制来更改，包括用户脚本。

换句话说，为了可移植性，*避免编写依赖 PHP_INI_SYSTEM 的代码，并注意 PHP_INI_PERDIR 对某些用户来说可能是个问题*。

**阿帕奇指令**

有两个 Apache 指令，可以在 *httpd.conf* 和*中使用。htaccess* 文件，可用于更改配置设置，即 *php_value* 用于具有字符串值的设置，以及 *php_flag* 用于具有布尔值(实际上是 0 或 1)的设置。一个例子*。包含两者之一的 htaccess* 文件；

 `# Switch off register_globals
php_flag "register_globals" 0`

`# Set the include_path - Unix! See below...
php_value "include_path" ".:/usr/local/lib/php"`

将它放在服务器上的某个目录中，并放置一个 PHP 脚本，其中包含:

您应该会看到这些设置的*本地*值已经被更改(*全局*值是那些在 *php.ini* 或 *httpd.conf* 中设置的值)。

系统管理员注意——还有另外两个指令， *php_admin_value* 和 *php_admin_flag* 这里描述了。

**脚本配置**

要在 PHP 脚本中更改配置设置，主要的函数有: [ini_set()](http://www.php.net/ini_set) 用于更改配置值， [ini_get()](http://www.php.net/ini_get) 用于获取配置设置的当前*本地*值， [get_cfg_var()](http://www.php.net/get_cfg_var) 用于从 *php.ini* 中获取*全局*值， [ini_get_all()](http://www.php.net/ini_get_all) 用于所有设置的大型数组，包含本地和全局值以及 htaccess 文件)。其他函数，如 [set_include_path()](http://www.php.net/set_include_path) 用作特定配置选项的别名，但在使用这些函数时，请密切注意手册中的 PHP 版本信息。

从 PHP 脚本中向包含路径追加值的示例；

 `**开发设置**

下面描述的设置是您应该在您的开发环境中在 *php.ini* 中设置的。有些是痛苦的，因为如果你写的东西没有它们，可能需要修改代码，但如果你的代码会被其他人使用，这是值得努力的。

**错误报告:E_ALL**

开发时，将*报错*切换到 *E_ALL* 。特别是，这可以捕获 E_NOTICE 类型的错误，这种错误通常可以避免，但是使用这种设置可能会向用户显示错误消息，并且在发送 HTTP 头时可能会中断代码。这将意味着代码更新，例如，你以前写的地方；

 `你需要写作；

 `if ( isset($_GET['doSomething']) && $_GET['doSomething'] == 'yes' ) {
// do something
} else {
// do the default
}`

为了防止在未设置 *$_GET['doSomething']* 时出现错误通知。注意，使用@操作符隐藏错误消息通常比使用 [isset()](http://www.php.net/isset) 构造要慢。

**PHP 标签**

关闭 *short_open_tag* 并避免 *asp_tags* 。可能需要修改代码，例如:

 ``变成了；

 ``关于 *short_open_tag* 的问题是 PHP 解释器会被 XML 标签弄糊涂(另外任何关闭它的人都会把标签看成 HTML ),例如；

PHP 会被 XML 声明绊倒，以为是 PHP。遗憾的是， *short_open_tag* 设置是 *PHP_INI_PERDIR* 设置，所以无法在脚本中修改它(在我看来，这很好，但毫无疑问，实现起来很棘手)。

**注册全局:关**

希望你已经意识到开启 *register_globals* 对于安全来说通常是坏消息，正如这里的[所解释的](http://www.php.net/manual/en/security.globals.php)。下次我会做安全检查。

从可移植性的角度来看，在 *register_globals* 关闭的情况下编写的代码应该在 *register_globals* 打开(*的情况下运行，但可能不安全！* ) -同样的大概反过来就不行了。

长话短说，切换 *register_globals* ！

**通话时间基准通过:关**

PHP4 中的引用是一个棘手的问题，你可以在这里的[中找到更多，并且可能需要他们自己的“gotchas”讨论。](https://www.sitepoint.com/object-oriented-php/)

为了便于携带，关闭*allow _ call _ time _ pass _ reference*。这是指代码，如:

关闭*allow _ call _ time _ pass _ reference*将导致 PHP 警告错误产生。一旦你理解了引用是如何工作的，无论如何都没有必要这样做，这会使代码非常难以理解。

**魔术语录**

神奇的报价是一个棘手的问题。他们做了很多来防止新手搬起石头砸自己的脚，但这可能会在以后引起大麻烦。这里有更深入的讨论和[这里](https://www.sitepoint.com/php-anthology-3-php-mysql/)——请注意，关于魔术报价，有一些重要的安全问题需要注意。

从可移植性的角度来看，最好是编写不依赖于打开 *magic_quotes_gpc* 的代码(例如，使用 [mysql_escape_string()](http://www.php.net/mysql_escape_string) )，但无论 *magic_quotes_gpc* 是打开还是关闭都可以正确运行。一个快速的方法是在剩下的代码之前执行如下代码:

 `// Is magic quotes on?
if (get_magic_quotes_gpc()) {`

 `//是吗？去掉添加的斜线

$_GET = array_map('stripslashes '，$ _ GET)；
$ _ POST = array _ map(' strip slashes '，$ _ POST)；
$ _ COOKIE = array _ map(' strip slashes '，$ _ COOKIE)；` 

`}`

**包含路径分隔符**

虽然我说过我不会谈论操作系统相关的问题，但正如我在上面提到的，值得注意的是 Unix 和 Windows 上的 *include_path* 分隔符是不同的。如果你在一个 PHP 脚本中设置它，你在上面已经看到的技巧会有所帮助；

 `if (strtoupper(substr(PHP_OS, 0,3) == 'WIN')) {
$seperator = ';';
} else {
$seperator = ':';
}`

PHP 4.3.4 提供了预定义的常量 PATH_SEPARATOR，它包含了包含路径所需的上述字符。

感谢约谢利的提示

**安全模式**

呃-不了，谢谢。个人认为不要为在安全模式下运行的用户编写代码。如果有人想填补这个空白，请这样做。

**SAPI 问题**

PHP 有许多服务器 API，也许最流行的两个是 Apache API 和 CGI API。新的 CLI API 增加了更多问题。PHP 函数 [php_sapi_name()](http://www.php.net/php_sapi_name) 可能很有用。

这里有一些关于 Apache 和 CGI API[的讨论](https://www.sitepoint.com/blog/)，特别是关于*$ _ SERVER[' PATH _ TRANSLATED ']【T3]变量。运行命令行脚本时，关于 CLI 和 CGI 二进制文件兼容性的说明可以在[本页](https://www.sitepoint.com/article/php-command-line-1/3)的后半部分找到。*

现在已经够了。请随意添加/更正-我会用我错过的东西更新这个博客。`````` 

## `分享这篇文章`