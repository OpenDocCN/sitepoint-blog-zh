# 也许我对 Java 的理解是错误的——第 2 部分

> 原文:[https://www . site point . com/maybe-I-was-wrong-about-Java-part-ii/](https://www.sitepoint.com/maybe-i-was-wrong-about-java-part-ii/)

*编者按*:在 Java 渠道中，我们大多数人都非常了解这种语言，并且已经在它的生态系统中至少呆了几年。这给了我们常规和专业知识，但也导致了一定程度的狭隘视野。在新的系列 [*中，非爪哇人将向我们展示他们对我们生态系统的看法。*](https://www.sitepoint.com/python-for-java-people/)

我不怎么接触 Java，所以我正在调查我对它的所有先入为主的观念有多真实。[上次](https://www.sitepoint.com/maybe-i-was-wrong-about-java-i/)，我主要探讨了面向用户的问题，比如速度和大小。结果:不确定。

但是现代 Java 越来越多地用在用户看不见的地方:数据中心、电话、我的烤面包机。因此，也许真正有趣的问题是关于 Java 对开发者来说是什么样子的。

## Java 不安全

Java 作为一个移动安全问题的恶名可以追溯到古代，那时 Java 小程序很常见，你相信 JVM 可以有效地保护它们，偶尔它也不能。

也许试图削减整个通用语言及其庞大的标准库，使之能够安全地从网络上运行是一个坏主意，但现在这是一个有争议的问题。我很少再看到 Java 小程序了。我想我甚至没有安装 NPAPI 插件。Firefox [不允许 Java 小程序自动运行](https://support.mozilla.org/en-US/kb/how-allow-java-trusted-sites)，并在三月份完全停止对它们的支持；Chrome [去年停止支持](https://support.google.com/chrome/answer/6213033)。

当然，这可能在一定程度上是因为 Java 小程序已经变成了一个攻击面，而不是一个有用的平台；[思科 2014 年的一份报告](http://www.cisco.com/web/offers/lp/2014-annual-security-report/index.html)明确声称 91%的网络攻击是针对 Java 的。我记得同一年，我当时的雇主警告每个人，如果他们不是特别需要 Java，就在浏览器中手动禁用它。如果这是你接触 Java 的唯一机会，那么它不会给你留下深刻的印象。

嘿，坚持住。这应该是关于开发者的观点。那么独立于 applet 的运行时本身呢？“安全”很难量化，但作为一个非常粗略的近似值，我可以找找今年发的[CVE](https://www.cvedetails.com/)的数量。

*   PHP: [107](https://www.cvedetails.com/product/128/PHP-PHP.html?vendor_id=74)
*   甲骨文 Java: [37](https://www.cvedetails.com/product/19117/Oracle-JRE.html?vendor_id=93)
*   节点: [9](https://www.cvedetails.com/product/30764/Nodejs-Node.js.html?vendor_id=12113)
*   CPython: [6](https://www.cvedetails.com/product/18230/Python-Python.html?vendor_id=10210)
*   Perl: [5](https://www.cvedetails.com/product/13879/Perl-Perl.html?vendor_id=1885)
*   红宝石: [1](https://www.cvedetails.com/product/12215/Ruby-lang-Ruby.html?vendor_id=7252)

呃，哎呀，这让我措手不及。老实说，我本以为会感到惊喜，并被证明是错误的，但是这个列表让 Java 听起来比我想象的还要糟糕。我希望对此有一个很好的解释，但我没有。

## Java 是企业化的

啊，另一个每个人(包括我自己)都使用的词，但这并不意味着什么。它唤起了一个非常具体的形象，但定义非常模糊。我有几个关于它可能意味着什么的猜测。

### Java 被抽象到了平流层

抽象层，如果你愿意的话。声名狼藉的 [`AbstractSingletonProxyFactoryBean`](http://docs.spring.io/spring-framework/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html) 之境。

这个我其实有点搞不清楚。再转到 elasticsearch，偶然发现了这个类， [`WhitespaceTokenizerFactory`](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/index/analysis/WhitespaceTokenizerFactory.java) 。它的完整源代码是:

```
public class WhitespaceTokenizerFactory extends AbstractTokenizerFactory {

    public WhitespaceTokenizerFactory(
            IndexSettings indexSettings,
            Environment environment,
            String name,
            Settings settings) {
        super(indexSettings, name, settings);
    }

    @Override
    public Tokenizer create() {
        return new WhitespaceTokenizer();
    }
} 
```

好的，当然。您希望能够从某个外部状态创建一个任意的记号赋予器，但是您不希望记号赋予器本身依赖于外部状态。有道理。

尽管如此，这段代码*看起来*相当愚蠢，尤其是如果你没有见过其他做更复杂事情的类。同样的话重复三遍；一个 38 行的文件只有两行实际代码。看到这一点，很容易认为 Java 代码因其间接性而走向了荒谬的极端。最坏的情况下，我可能会用 Python 来做:

```
@builder_for(WhitespaceTokenizer)
def build(cls, index_settings, env, name, settings):
    return cls()

@builder_for(SomeOtherTokenizer)
def build(cls, index_settings, env, name, settings):
    return cls(index_settings.very_important_setting)

# etc. 
```

我手摇这将如何实际工作，但没有太多。仔细想想，这在 Java 中甚至是可能的，但可能不太漂亮或不习惯。或者，Python 代码可能只在记号赋予器类本身上有`build`。动态类型的一个好处是代码可以*使用*一个类型而不依赖它。tokenizer 类可以处理`IndexSettings`和`Environment`对象，而不必导入类型，甚至不知道它们的存在。这有点不确定，但在这种一切都是内在的情况下，这可能是有意义的。

但是考虑到 Java 的类型系统，我可以理解为什么你会有上面的代码。让我困惑的是这个。

为什么我在其他语言中看不到同样的东西？

我在 GitHub 上最受欢迎的 Java 项目中随机点击了大约一分钟，发现了这个微型工厂类的集合。我对此完全不感到惊讶。然而我不记得在其他显式的静态类型语言中看到过类似的东西。C++中的微型工厂类在哪里？最明星的 C++项目是[电子](https://github.com/electron/electron)，搜索“工厂”只找到我这样的代码[这个](https://github.com/electron/electron/blob/master/atom/browser/net/atom_url_request_job_factory.h)，还有很多。最受关注的 Objective-C 项目是 [AFNetworking](https://github.com/AFNetworking/AFNetworking) ，它在一个 changelog 中包含“工厂”*一次*。最受瞩目的 Swift 项目是 [Alamofire](https://github.com/Alamofire/Alamofire) ，不知何故，它在任何地方都不包含“工厂”这个词！

因此，虽然我可以接受间接层和小类对于与 C++风格的类型系统相处是有用的，但我不明白为什么我在 Java 中比在 C++中更经常看到它们。

这是文化差异吗？C++开发人员乐于拥有一个错综复杂的相互依赖的网络吗？这些微小的类存在于 C++中，但是都存在于一个容易被忽略的文件中吗？

Java 确实似乎生活在抽象领域，但我不明白为什么它与类似的语言如此不同。

### Java 冗长乏味

“企业”让我想到了重复的官僚主义，它从一切事物中吸取快乐。

#### 随处可见的访问者

Java 让我想到了访问器。同样的想法，真的。

```
private int foo;

public int getFoo() {
    return this.foo;
}

public setFoo(int foo) {
    this.foo = foo;
} 
```

看看这些占用宝贵垂直空间却什么都不做的代码。我可以只说`public int foo;`就完事了。

世界上有三种程序员，根据他们对最后一段的反应来区分。有的点了点头，大概是 Python 程序员吧。有些人认为这违反了封装，当我说我不关心封装时，他们会再次犹豫。最后，一些人翻了翻白眼，指出一个`public`属性被冻结在 API 中，在不破坏现有代码的情况下永远无法更改。

啊，后面那些人可能有道理。问题是 Java 不支持属性。“属性”是一个可怕的语言特性的通称，只是最近才开始流行，但是如果你不熟悉，我指的是你可以在 Python 中做的这件神奇的事情。如果您有一个外部代码可以自由修改的`foo`属性，然后您决定只将它设置为奇数，那么您可以在不破坏 API 的情况下这样做:

```
class Bar:
    def __init__(self):
        # Leading underscore is convention for "you break it, you bought it"
        self._foo = 3

    @property
    def foo(self):
        return self._foo

    @foo.setter
    def foo(self, foo):
        if foo % 2 == 0:
            raise ValueError("foo must be odd")
        self._foo = foo

bar = Bar()
bar.foo = 8  # ValueError: foo must be odd 
```

`@property`是一个强大的工件，它可以透明地拦截读取或写入属性的企图。其他代码仍然可以像预期的那样与`obj.foo`一起工作，并且永远不知道区别。甚至`@property`本身也可以用普通的 Python 代码来表达，还有一些有趣的变体:延迟加载属性、透明地充当弱引用的属性等等。

我知道 Python、Swift 和一些。NET 语言(C#，F#，VB，Boo，…)支持属性。现在 JavaScript 被指定为支持它们，尽管我不确定在野外有多少代码依赖它们。Ruby 拥有它们，只是语义略有不同。Lua 和 PHP 可以伪造它们。Perl 有一个东西，但是你可能不应该使用它。JVM 本身必须能够支持它们，因为 Jython 和 JRuby 已经存在。那么为什么不使用 Java 语言呢？

对我来说很奇怪的是，Java 没有采用这个可以减少大量重复的特性。它显然是为 Java 7 提出的，但我找不到它为什么没有被淘汰的解释，现在它似乎不是一个优先考虑的项目。

#### 但是等等，还有更多

我在这里展示了我的 Python 颜色，但是在我这样做的同时:另一个巧妙的技巧是类在模块加载时很容易操作。类定义就是在执行时创建一个类的代码。所以 Python 有一些有趣的把戏，比如 [attrs 模块](http://attrs.readthedocs.io/en/stable/overview.html)，它允许这样做:

```
import attr

@attr.s
class Point:
    x = attr.ib(default=0)
    y = attr.ib(default=0) 
```

通过这样声明属性，您可以免费获得:一个按顺序或按名称接受参数的构造函数；一个合理的`repr`(类似`toString`，但明确只用于调试)；散列性；比较运算符；和选择加入不变性。没有代码生成，只是在运行时对定义的类进行一些快速操作。

显然，这种精确的方法在 Java 中是行不通的，但是可以模拟。我知道 Java IDEs 在代码生成方面几乎臭名昭著，所以我对 Java 本身没有采用一种在编译时生成或重写代码的方法感到有点惊讶。

#### 不要不重复自己

类似地，这似乎是一种常见的苦恼:

```
ComicallyLongStrawmanTypeName value = new ComicallyLongStrawmanTypeName(); 
```

在这里，一点类型推断将大有帮助。Java 最近确实得到了*一些*类型的推断，但是只针对泛型:

```
List<ComicallyLongStrawmanTypeName> value = new ArrayList<>(); 
```

绝对是一个进步，但是我有点不明白为什么这个特性在这里停止了。事实上，这与我所期望的类型推断工作方式*相反*——通常第一步是从表达式的类型推断变量的类型，而不是反过来。我已经看到了一些关于 Java 10 中更传统的类型推断的[推测](https://www.sitepoint.com/what-java-might-one-day-look-like/#moretypeinference)，如果这被证明是真的，那将是一个不错的改进。

#### ComicallyLongStrawmanTypeName

这个`ComicallyLongStrawmanTypeName`本身也值得一提。Java 因其非常长的类型名而臭名昭著。我从来没有想过这个问题，直到现在，但它几乎肯定是由…包装系统的设计引起的！

包名倾向于以至少由两部分组成的域名和项目名开头，比如`org.mozilla.rhino`，这已经让它们有点拗口了。问题是，包和类名不能有别名。包也没有层次结构，所以您不能导入包的整个“分支”。如果你有一个包含类的包，你有两种方式来引用它:作为`org.mozilla.rhino.ClassName`，或者在导入后作为`ClassName`。就是这样。

结果是类名*必须*有所限定以避免名字冲突！如果你给一个类命名为`List`，你将会惹恼任何想在标准库`List`的同一个文件中使用你的类的人。所以你最终得到了一个包含 T3 的包`com.bar.foo`。

这似乎与包装的观点有点对立。在 Python 中，我可以给一个包起别名，或者导入父包，或者给一个类名起别名。我可以用非常通用的名称填充一个文件，然后用一个短别名导入该文件，并将其内容用作`pkg.List`。这是伟大的，并严重减少了重复的噪音。但是在 Java 中，你必须给类命名，就好像它们是一个全局命名空间的一部分，因为它们可能和其他类一起被导入。

(顺便说一句，这种微妙的全局命名空间也让我对 Java 风格的接口保持警惕。接口中的方法名实际上与所有方法名共享一个全局名称空间，在所有 Java 代码中，*无处不在*——因为接口的全部意义在于一个类可以实现它们的任意集合。所以在这里也不能使用好听的简称，否则会有命名冲突的风险。不过，这并不是对 Java 的抨击——同样的问题存在于许多语言中，包括 Python，尽管缺乏显式接口使它不那么令人担忧。Rust 通过使接口实现不同，而不是单一类体的一部分，很大程度上避免了它。我相信这个想法来自曼梯·里家族。)

让我感到突出的是 Java*让你变得简洁的一个地方:隐式`this`。不太喜欢含蓄的`this`。这使得扫描文件非常困难，因为当我看到这个:*

 *```
foo = 3; 
```

如果不检查方法的其余部分，我无法一眼看出这是局部变量还是属性。(是的，是的，IDEs，但是这里一个持续的主题是，我认为一门语言不需要它也应该是可用的。)我肯定这里有很多人不同意我的观点，这没关系；我只是说隐式的`this`并没有真正节省多少空间或输入，所以当其他语言特性导致更多冗长时，我觉得这是一种奇怪的“优化”。

我有点惊讶；我原以为 Java 的冗长与其说是语言的特性，不如说是一种文化现象，但似乎 Java 本身无意中促进了冗长的代码。最近的一些语言变化看起来很有希望，我希望在未来看到更多这方面的工作。

### 简短的话题

此时，我开始意识到 Java 的冗长实际上是关于 *API 稳定性*:

*   `public` vs `private`声明你愿意支持什么作为稳定接口的一部分。
*   访问器保证了接口的未来性，并为您以后添加更多逻辑提供了空间。
*   静态类型使接口尽可能保守。
*   接口和其他形式的间接方式最大限度地减少了代码对功能的依赖。
*   继承是*也是*每个类的 API 的一部分，这就是`protected`和`final class`的用武之地。
*   工厂是面向未来的，防止以后更改返回类型，这是构造函数做不到的。
*   进口真的很死板，因为…呃…好吧，不能解释那个。

但是从稳定性的角度来看，Java 的一些特点让我觉得不寻常。

如果每个人真正想要的保证是一个稳定的 API，为什么核心语言和工具没有办法…强制一个稳定的 API？相反，我们有一套间接工具，如`public`和`private`，我们必须有意识地记住不会破坏 API 兼容性的允许更改列表。如果我们不小心做了一个突破性的改变，那么，我们最好希望我们有一个依赖于那个 API 的测试，否则我们永远不会注意到。为什么电脑不能帮我们检查这份保证书？当他们中的许多人都强调提供这一小撮原语时，为什么这没有成为*任何一种*主要语言的一部分？

此外，Java 没有办法指出 API 的哪些部分是供公众使用的。方法可以是私有的，也可以是公共的；一个类可以是私有的，也可以是公共的；但是我不知道如何判断整个文件(或目录)是公共 API 的一部分，还是仅仅是一个内部工具。“包私有”的可见性是一件事情，但是由于包是没有层次的，除非你想把你的整个项目塞进一个包里，否则它只能做到这一步。(我所知道的唯一能很好地处理这个问题的语言是 Rust。)我猜解决方法是保留一组独立的公共包装类，但是如果你的公共接口最终完全独立，那么在你的内部代码中散布所有的稳定性关键字又有什么意义呢？也许 Java 9 的[模块](http://openjdk.java.net/projects/jigsaw/spec/sotms/)会在这方面有所改进。

仔细想想，我想知道:许多 Java 开发人员为了内部代码放弃了稳定性吗？我想，在你自己的代码库中使用`private`不会让你付出任何代价，但是在你自己的代码库中使用`public`也不会。我多次听说 Java IDEs 具有近乎神奇的重构能力，所以如果必要的话，属性肯定可以自动更改为使用访问器。有人利用这一点来避免面向未来的样板文件吗？

我*怀疑*答案是“不”,因为访问器被视为最佳实践——甚至本质上是良性的，是面向对象设计结构的一部分。如果是这样，这与 Python 形成了鲜明的对比，在 Python 中，访问器通常被认为是多余的——因为这种语言提供了一种在不破坏 API 的情况下改变普通属性的方法。

类似地，Python 根本没有“隐私”的概念。按照惯例，以单个下划线开头的方法或属性名是“私有”的，但这仅仅意味着“如果以后改变了，不要怪我”，实际上对核心语言没有任何影响。当一个第三方库*几乎*完成了我想要的功能，但在我需要的地方却没有挂钩时，这是非常有用的。如果我愿意接受一点脆弱，我可以只继承一些东西并包装一个“私有”方法。我可能会不小心打破一些对象的保证，但我知道这是我自己愚蠢的错误。原始源代码通常是可用的，这很有帮助。

然而我看到有人坚持认为 Python 没有“真正的”或“完全的”面向对象支持，仅仅是因为它缺少这些 Java 特性。好像“好的面向对象设计/支持”等同于“Java 所做的一切”。这是某种令人印象深刻的强大品牌力量。

两种语言之间的设计原则如此截然相反，这是违反直觉的，这表明这些原则可能没有我们想象的那么有原则。封装被认为是好的，因为它隐藏了对象的表示，但有时一个对象*是它的表示，而 Java 没有令人满意的方式来表达这一点。主机名不是 URL *所做的*的一部分；这是 URL *是*的一部分。以问题或命令(即方法调用)的形式表达“这个 URL 的主机名”对我来说感觉不自然和笨拙。但是在 Java 中，你别无选择，结果是我遇到了将封装视为绝对好处的 Java 开发人员——就好像 OO 原则是根据 Java 自身的局限性定义的一样。*

我不想在这里取笑 Java 或 Java 开发人员。我确信，通过写这么多 Python，我学到了一些更奇特的原则。(“重载除法运算符来连接路径段是很棒的设计！”)但我着迷于我们自己的文化背景传达我们感知世界的方式……以及我们决定世界应该是什么样子的方式。

好吧，我说到哪了？

![wrong-about-java-enterprisey](../Images/560627aa36f2d908d7fa617cb7acb4ff.png)

### Java 是极其保守的

啊，现在我们可能有进展了。

毕竟，这种语言这些年来变化相对较小。它在 2004 年加入了泛型、注释和其他一些细节，后来在 2014 年加入了 lambda 表达式，但除此之外没有什么更基础的了。相比之下，甚至 C++在最近几年也经历了一系列的重大变化。

我喜欢新的和令人兴奋的语言发展，但我理解缓慢而稳定的方法的吸引力。c 在其生命周期中只有三个半版本:C89、C99、C11，可能还有 C95。这种语言足够小和稳定，以至于尖端的编译器仍然可以处理 1990 年的代码。接口足够简单，以至于编译后的代码很有可能与新的库链接。这是一个令人印象深刻的壮举。

代价是 C 没有为你做太多繁重的工作，所以大量的工作被重新发明，大量的地面被翻新。c 也很少删除甚至贬低特性；C #中的已知雷区用一组特定的编译器警告来标记。

另一方面，Python 仅在过去五年中就发布了四个版本。过时的特性或库偶尔会被弃用，并在几个版本之后被删除，因此如果 Python 代码想要与未来的 Python 版本兼容，可能需要一些少量的日常维护。Python 也没有稳定的编译格式来隔离已部署的库和语言变化。这种语言本身被规定得足够好，以至于存在几种可供选择的实现，但是它们往往落后于几个版本。

Java 的目标似乎是一个有趣的妥协。核心语言增长相对较慢，这避免了以后删除错误的需要。标准库相当广泛，但是如果这个弃用列表有任何指示的话，旧的 API 很少被完全移除——我在这里看到了十六年前在 Java 1.3 中弃用的特性。

这表明对稳定性和兼容性的强烈关注。新特性的添加非常小心，尤其是核心语言。作为补偿，生态系统在 Java 之上构建了大量的工具；第三方代码可以更自由地进行试验，保守的开发人员可以完全不使用这些工具。我注意到 Java 注释最初是 javadoc 的一个版本，所以看起来核心语言采用了生态系统中流行的思想，这很好。

不利的一面是，Java 在代码生成、配置/反射层来完成核心语言难以完成的事情，以及出于某种原因的大量 XML 方面有点名声在外。

另一方面，保持语言的稳定增长可能会使 JVM 的实验变得更容易，这反过来也为几种新的语言打开了大门。如果没有坚实的 VM 和庞大的可用库生态系统，Clojure、Scala 和 Groovy 可能不会存在。

也许“Java 保守”太简单了。更准确地说，Java 似乎非常小心地分配了它的自由。毕竟，保守主义实际上是关于规避风险的，这绝对是与企业世界相关的一个特征。

## 启迪

沿着这条蜿蜒的道路，我开始意识到一些别的东西。我对核心语言的许多本能厌恶实际上是 C++的错。

Getters，setters，没有属性…就像 C++。

访问控制…就像 C++一样。在 C++中可能更合理一些，在 c++中，干预对象的内部可能会导致内存损坏。

每个文件一个类…就像(嗯，很多)C++一样。

大括号、分号和 dromedaryCase…就像 C++一样。这是一个完全独立的问题，但我认为括号是噪音。

为构造函数重复类名…就像 C++一样。写点`public new()`什么的可能没问题。

无需显式导入就能使用类型…就像 C++一样。好吧，是的，Java 在这方面比 T2 好得多，但是略读 T0 仍然不足以找出文件的依赖关系。

一个空值…就像 C++。这尤其令人恼火，因为它使整个类型系统变得毫无意义。类型为`T`的变量可能包含类型为`T` … *或*的值，也可能包含类型为`T`的值`null`。每一个单一类型的注释都是谎言。甚至一个`Optional<T>`也可能是`null`！

## 最后

Java 有一些缺点。语言设计带来了一些繁琐的开发开销；平台本身的安全问题可能有点太常见了；而且变化很慢，不管是好是坏。我仍然不确定为什么前一篇文章中的几个程序也占用了这么多内存。

我对 Java 的看法错了吗？算是吧。没有我想的那么糟糕，但也没有好几个数量级。它最初的设计理念可能是“没有太多剃刀线的 C++”，按照*和*的标准，它绝对是成功的。我可以说它不适合我，但它的存在是对同样不适合我的东西的一种替代。嘿，我发现更多的事情要归咎于 C++，这总是让我很高兴。

自从 Java 问世以来，世界发生了很大的变化。现在我们有了一个完整的竞争生态系统。NET，像 LuaJIT 和 PyPy 这样的 JIT 出现了，甚至用 JavaScript 编写的桌面软件也部署了自己的小网络浏览器。Java 可能是 VMs 和 JIT 被广泛接受的原因，对此我非常感激。(嗯……对电子产品还没有定论。)

如果你觉得这些很有趣，而且你以前没有做过，也许可以试试 Python 或 Ruby，看看我是从哪里来的。两种语言都有充满非常聪明的人的繁荣社区，并且两种语言对面向对象的含义都有非常不同的观点。Python 表面上看起来更像 Java，尽管在它下面隐藏着一个非常灵活的原型对象模型；Ruby 采用了 Smalltalk 的消息传递方法，并添加了少量 Perl。尝试两者，甚至；可能发生的最坏的情况是你更加欣赏 Java。(我肯定更了解 Python 也许我会从 Java 或 C++的角度来写它。)

如果我对 Java 社区有什么临别建议的话，那就是:请回到过去，将 Java 建立在 Pascal 的基础上。

## 分享这篇文章*