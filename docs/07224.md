# Ruby 函数式编程技术:第三部分

> 原文:[https://www . site point . com/functional-programming-techniques-with-ruby-part-iii/](https://www.sitepoint.com/functional-programming-techniques-with-ruby-part-iii/)

![](../Images/06b4af3caaba8ee5dee3f4ded83d8e1b.png "Word cloud for Functional programming")在本系列的第一部分[中，我们看了看函数式编程的基础知识，并详细访问了不可变性和无副作用的代码。在第二部分](https://www.sitepoint.com/functional-programming-techniques-with-ruby-part-i/)中，我们探索了高阶函数和 curry 的概念，以及 Ruby 中匿名函数的各种伪装。

在这个系列的最后一部分，我们将研究 Ruby 中的递归和惰性，并看看如何将这些函数式编程的要点应用到日常代码中。

## Ruby 的许多循环

如果你不仅仅是一个编程初学者，你可能会熟悉这个老式的循环。循环的概念很早就出现在大多数编程书籍中，这是有充分理由的:将指令重复给定的次数是高效编码的基本原则。曾几何时，谦逊且经常被滥用的`goto`语句服务于这个目的，但最终像`for`和`while`这样的语言关键字取代了大多数其他形式的循环，用灵活性换取了简洁。

Ruby 有许多不同类型的循环，您可以尝试一下:

*   `for i in range do; ...; end`
*   `n.times do; ...; end`
*   `i.upto(j) do; ...; end`

还有很多其他的(包括[奇怪的成语实现 while 循环](http://stackoverflow.com/a/136815/153432)，还有[隐藏 goto 的](http://patshaughnessy.net/2012/2/29/the-joke-is-on-us-how-ruby-1-9-supports-the-goto-statement))。

然而，在函数式编程中，像这样的循环是闻所未闻的；这主要是因为函数式编程希望你告诉它*做什么*而不是*怎么做*。因此，循环被两个非常强大的概念所取代:

*   折叠(特别是左折叠和右折叠)
*   函数递归

当然，现在[我们已经在本系列的第一部分](https://www.sitepoint.com/functional-programming-techniques-with-ruby-part-i/)中讨论了折叠，所以让我们更详细地看看函数递归。

## 给自己打电话

函数递归是编写调用自身的函数的过程的名称。这是函数式编程中取代标准命令式循环的常用方法。它通过一个函数传递新的参数给自己来模拟迭代，当这些参数达到某个阈值时返回。

一个合适的例子是，让我们跳过递归例子的传统受害者，斐波那契数，而是写一个函数来计算[阶乘](https://en.wikipedia.org/wiki/Factorial):

```
def fact(n)
  return 1 if (0..1).include?(n)
  n * fact(n - 1)
end
```

如果要计算`6!`，或者 6 的阶乘，答案将是`6 * 5 * 4 * 3 * 2 * 1`，或者`720`；上面的函数将通过执行以下命令得到相同的答案:

```
fact(6) = 6 * fact(5)
        = 6 * 5 * fact(4)
        = 6 * 5 * 4 * fact(3)
        = 6 * 5 * 4 * 3 * fact(2)
        = 6 * 5 * 4 * 3 * 2 * fact(1)
        = 6 * 5 * 4 * 3 * 2 * 1
        = 720
```

想想这段代码有多简洁，尤其是与传统的循环相比。循环变体最终看起来应该是这样的:

```
def fact(n)
  factorial = 1

  begin
    factorial *= n--
  end while n > 1

  factorial
end
```

这个使用循环的例子带来了保持循环状态更新的明显负担，但是在简洁性和可读性方面也有问题。

不幸的是，对所有这些的警告是，Ruby 缺省情况下缺乏对[尾部调用优化](http://en.wikipedia.org/wiki/Tail_call)T2 的支持。这意味着我们用来实现阶乘方法的函数递归最终会使堆栈崩溃。[你可以重新编译 Ruby 1.9.x，这样就可以执行尾部调用优化](http://bugs.ruby-lang.org/issues/show/1256)，尽管你应该小心检查这个特性是否启用，如果你的代码运行在 Ruby 的另一个安装上，并且依赖于尾部调用优化来工作，你应该抛出一个合适的运行时错误。

## 枚举器:Ruby 的生成器

如果您能够拥有递归的能力，而不用担心尾部递归优化和编译自定义版本的 Ruby，会怎么样？

在许多语言中，有生成器的概念，它可以被描述为迭代器、循环和函数递归的混合。在 Ruby 中，生成器被称为“枚举器”。

Ruby 实际上试图强迫你对大多数形式的循环使用枚举器，一个明显的例外是我上面使用的那个(`begin; ...; end while ...`)。一直以来，当你忙于使用`#each`时，你实际上是在使用一个枚举器。证明:

```
puts = [1, 2, 3].each.class # => Enumerator
```

枚举器或生成器基于这样一种思想:如果循环的每次迭代都执行一个函数，那么循环就可以变得更加强大，并且可以使用代码来控制循环的逐步执行。

在 Ruby 中，您可以在外部迭代，并自己管理`Enumerator`类的任何实例上的循环:

```
x = [1, 2, 3]

enum = x.each
puts enum.class # => Enumerator
puts enum.next # => 1
puts enum.next # => 2
puts enum.next # => 3
puts enum.next # => StopIteration exception
```

也可以编写自定义枚举器。这些功能非常强大，允许您将任何旧类转换成可以迭代的类。这是通过将`Enumerable`模块包含到一个类中并定义一个`each`方法来实现的，该方法为每个要迭代的值生成一次。

模块定义了你每天可能会用到的大量方法；一些比较受欢迎的包括:

*   `#any?`
*   `#all?`
*   `#find`
*   `#inject`
*   `#select`
*   `#take`

这些方法，实际上是[所有其他被定义为`Enumerable`模块](http://www.ruby-doc.org/core-1.9.3/Enumerable.html)一部分的方法，都是根据你在包含这个模块的类上定义的`#each`方法来定义的。仅此一点就应该展示出普查员的巨大力量。

下面是我们之前使用`Enumerable`函数重写的命令式循环阶乘函数:

```
def fact(n)
  (1..n).inject(:*) || 1
end
```

这太神奇了。可以说，这比我们最初的函数递归版本可读性更好，而且更短。它也非常符合函数式风格:没有变量来保持状态，代码告诉 Ruby *做什么*，而不是*如何做*。

枚举器是大多数 Ruby 循环问题的解决方案，但是有一个限制。假设我们有一个可以无限生成素数列表的类。对于一个应用程序，我们希望找到前 20 个含有数字“3”的质数，对于另一个应用程序，我们希望找到前 10 个数字之和也是质数的质数。用标准的`Enumerable`函数来编写这些函数即使不是不可能，也不会很好。输入惰性枚举器。

## 懒惰的枚举器

在像 Haskell 这样的函数式语言中，[惰性求值](https://en.wikipedia.org/wiki/Lazy_evaluation)是一个用于仅在需要时强制求值的特性。在 Haskell 中，在整个代码中有无限的列表是完全有效的，在任何给定的时间，只使用需要的列表。在像 Ruby 这样的严格求值语言中，这是不可能的。Ruby 将尝试评估整个无限列表，最终在这个过程中运行内存的。

即将到来的 Ruby 2.0 中新增了一个名为`Enumerator::Lazy`的全新类，它允许对枚举器进行惰性求值。这意味着在 Ruby 中无限的数据列表现在也很容易实现。

让我们暂时回到我们的主要例子。假设我们有一个类`Prime`,它是一个枚举器，将生成一个无限的质数流，下面是我们前面两个问题的解决方案:

```
Prime.lazy.select { |x| x.to_s.include?('3') }.take(20).to_a
Prime.lazy.select { |x| 100.to_s.chars.map(&:to_i).inject(:+) }.take(20).to_a
```

在不使用惰性枚举器的情况下实现如此简洁易读的代码将是一项艰巨的任务。这是第一个惰性枚举器示例的替代示例:

```
a = []
Prime.each do |x|
  next unless x.to_s.include?('3')
  a << x
  break if a.size == 20
end
```

这几乎与函数式编程相反:一个用于状态的变量，以及无处不在的循环管理。这段代码更多的是告诉 Ruby *如何做我们想要的事情*；与我们懒惰的例子相比，这个例子是关于告诉 Ruby *我们想要什么*。这是函数式编程的核心本质。

懒评还有一个巨大的好处。看看这段代码:

```
(1..100).select { |x| x % 3 == 0 }.select { |x| x % 4 == 0 }
```

这段代码试图找到 1 到 100 之间所有能被 3 和 4 整除的数字，但是在这个过程中，对这组数字*迭代两次*！惰性计算将所有枚举器操作合并到一次迭代中:

```
(1..100).lazy.select { |x| x % 3 == 0 }.select { |x| x % 4 == 0 }.to_a
```

这可以极大地提高对集合应用多个过滤器时的代码速度。这种可枚举链的折叠适用于在`Enumerable`类上定义的许多方法中的任何一种，包括但不限于`#select`、`#map`和`#take`。

目前， [`Enumerator::Lazy`非常慢，因为创建和调用崩溃块的成本非常昂贵](http://bugs.ruby-lang.org/issues/6183)；有一个补丁可以解决这个问题，所以很有可能 Ruby 2.0 的最终版本会有一个比 trunk Ruby 中当前实现更快的懒惰枚举器版本。

## 将这些经验应用到现实世界中

以函数式风格编写 Ruby 并不是要编写不使用变量的漂亮的命令行程序。当然，这也不是仅仅为了保持功能性而利用 Ruby 的隐藏特性。它是关于编写干净的、可维护的代码。

本系列的第一部分着眼于不变性。真实世界的代码在某些时候需要管理状态。然而，我们看到了一个真实世界的例子，创建了一个 [CSS 生成器](https://www.sitepoint.com/10-best-css3-code-generators/)，它有一个很好的 DSL，是可链接的，并且完全是功能性的；这是一种可以应用于许多问题的模式，可以产生干净且易于测试的代码。事实上，您可能会在野外发现这样的模式，因为它们对于创建流畅的 DSL 是不可或缺的。

本系列的第二部分着眼于高阶函数和 currying。这是从今天开始可以在你的代码中使用的两个原则。您可以使用高阶函数来简化代码和测试，currying 可以用于在您的应用程序或库中提供更多可用的 DSL，而没有通常随之而来的代码包袱。

这是最后一篇文章，第三部分，讨论了递归和懒惰。你今天可以以`Enumerator`和`Enumerable`的形式使用递归，当然你会发现大量的类在使用后来的 mixin。懒惰是一个将在 Ruby 2.0 中首次亮相的新特性，但是你可能希望在使用之前就开始思考，因为它非常有用。

然而，本系列的要点不是关于严格的代码示例，而是关于如何更好地理解日常代码背后的原则。当然，一个更有生产力和更有效率的程序员是理解他所使用的工具的人。这个程序员只在实际需要的时候使用需要的工具。函数式编程是最少编码的练习，实现最有效而简洁的代码，并通过让语言为您工作来增加可读性。Ruby 提供了如此多的方法来做到这一点，这是令人兴奋的。作为一个社区，我们需要尽我们所能去拥抱这些美妙的工具。

祝好运，功能 Rubyists！

## 分享这篇文章