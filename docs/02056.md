# Rails 中 MVC 的基础:瘦一切

> 原文:[https://www . site point . com/the-basics-of-MVC-in-rails-skinny-everything/](https://www.sitepoint.com/the-basics-of-mvc-in-rails-skinny-everything/)

![head1](../Images/257fe26766ff03bf06186d53cb494476.png)

模型-视图-控制器(MVC)是一种结构化软件系统的设计模式。MVC 模式将应用程序逻辑与用户界面分离开来。MVC 代表模型、视图和控制器，这是 MVC web 应用程序架构的三个主要组件。这些组件中的每一个都应该作为独立的单元运行。MVC 组件的离散性对于应用程序的维护和测试至关重要。

我们经常听说，在 Rails 中编写清晰简洁的代码的最佳方式是遵循“胖模型和瘦控制器”的方法，这指的是 MVC 架构中的模型和控制器应该如何完美地协同工作。拥有一个“瘦”控制器(这是常见的做法)意味着所有非关键逻辑都转移到模型中；这简化了测试和维护。然而，我们建议将“瘦身”方法更进一步:让你的模型和控制器都节食。通常我们关注模型和控制器，但是视图呢？视图也可以是“胖的”，事实上，我们认为视图也应该节食。

## 每个 MVC 组件的功能是什么？

![image00](../Images/329a1f45ed2cda2736558ae5b3e38de2.png)

为了清楚地理解为什么我们应该保持所有 MVC 组件精简，我们首先需要澄清这些组件的每一个负责什么。

### 模型

模型是数据库和应用程序之间的一个层，用于存储与特定实体相关的业务逻辑。每个模型负责一个不同的实体，并将这个实体与其他实体连接起来。模型通常由控制器调用。

例如，假设一个用户想要注册。为此，他们必须输入电子邮件、用户名和密码。所有这些属性都被一个控制器接收到，该控制器试图创建一个新用户(在 MVC 架构中，这个用户被概念化为“模型记录”)。该模型运行验证:它检查输入的电子邮件格式是否正确，密码是否足够安全，以及电子邮件和登录名是否唯一。如果验证成功，模型会将数据保存到数据库中，并触发一个`after_save`回调。回调的一个例子是发送给注册用户和管理员的通知电子邮件。如果验证失败，模型将返回一个可以呈现并显示给用户的错误对象。

### 控制器

控制器负责读取输入数据(请求)，选择适当的动作(业务动作)，并返回结果输出数据(响应)。

例如，控制器从客户端接收数据，路由器在现有控制器中选择适当的操作。基于接收到的参数，控制器执行以下动作:

*   认证，当控制器检查登录用户是否正在使用应用程序时
*   授权，当控制器检查用户是否被授权执行某个动作时
*   输入参数的过滤(`permitted_attributes`)，当一个动作控制器提供一个接口来保护最终用户分配的属性。
*   调用模型或服务中的方法。
*   确定向客户端提供信息的格式(JSON、HTML、PDF、XML ),并选择正确的视图。

### 视图

视图是附加模型状态的可视化。简单地说，视图就是用户看到的东西。这是唯一一个用户可以直接交互的 MVC 组件。

例如，控制器选择一个模板来表示用户帖子，并将其插入到适当的布局中。该视图显示用户信息，并包含一些 HTML 元素，比如到文章的链接和用于创建新文章的表单。

## 如果一个 MVC 组件做了别人的工作会怎么样？

*   当控制器包含执行不相关动作的大型方法时，维护代码变得很困难。
*   测试变得几乎不可能，因为编写单元测试意味着测试负责特定功能的具体类和模块。在“意大利面条式代码”(包含大量非结构化和困难的对象和方法的混乱代码)中，很难跟踪一连串的方法调用。
*   每个类都应该负责软件提供的全部功能中的一个部分。但是通常控制器开始包含不属于它的业务逻辑，甚至视图逻辑的形式。模型最终可能包含与持久性无关的逻辑，视图可能包含不受欢迎的计算。

我们必须遵循的避免胖 MVC 组件的主要规则总结如下:“每个人都应该管好自己的事。”

## 如何让 MVC 组件变得骨感？

为了实现瘦模型、视图和控制器，我们必须不断地重构。重构是重构现有代码的过程。虽然从最终用户的角度来看，重构并没有改变什么，但它有助于保持代码的整洁、可维护和易于测试，这对开发人员来说是有益的。

重构遵循一个简单的原则:如果你弄得一团糟，你应该自己收拾干净。重构是在所有代码更改之后发生的持续清理。你不可能建造一座摩天大楼或者画出一幅杰作而过程中没有很多混乱，写高质量的代码也是一样。这就是为什么我们每次实现一个新特性时都需要重构。

我们可以使用各种设计模式来帮助我们进行重构，包括:

*   服务对象(和交互对象)
*   价值对象
*   表单对象
*   查询对象
*   查看对象(序列化程序/演示者)
*   策略对象
*   装修工

为了更好地理解重构是如何工作的，以及什么时候是必要的，我们将在下一篇文章中强调我们经常在 RubyGarage 使用的一些实践。

## 分享这篇文章