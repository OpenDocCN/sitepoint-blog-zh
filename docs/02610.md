# 如何正确实现 Java 的 hashCode

> 原文:[https://www . site point . com/how-to-implementation-javas-hashcode-correctly/](https://www.sitepoint.com/how-to-implement-javas-hashcode-correctly/)

在 SitePoint，我们一直在寻求扩大我们涵盖的主题范围。最近，我们把目光投向了探索 Java 世界。如果您是一名优秀的 Java 开发人员，想要为我们的报道做出贡献，请联系一些您想写的文章的想法。

所以你认为身份对你来说还不够,[写了一个漂亮的`equals`实现](https://www.sitepoint.com/implement-javas-equals-method-correctly/)？
太好了！但是现在你*也必须*实现`hashCode`。

让我们来看看为什么以及如何正确地做这件事。

## 等式和哈希代码

虽然从一般的角度来看，等式是有意义的，但是散列码更具技术性。如果我们对它们有点苛刻，我们可以说它们只是提高性能的实现细节。

大多数数据结构使用`equals`来检查它们是否包含一个元素。例如:

```
List<String> list = Arrays.asList("a", "b", "c");
boolean contains = list.contains("b"); 
```

变量`contains`是`true`,因为虽然`"b"`的实例不相同(再次忽略[字符串实习](http://javatechniques.com/blog/string-equality-and-interning/)),但它们是相等的。

然而，将每个元素与给定给`contains`的实例进行比较是一种浪费，整个数据结构类使用了一种更高效的方法。它们不是将请求的实例与它们包含的每个元素进行比较，而是使用一种快捷方式来减少可能相等的实例的数量，然后只比较那些实例。

这个快捷方式就是哈希代码，它可以被看作是一个对象的相等性归结为一个整数值。具有相同散列码的实例不一定相等，但是相等的实例具有相同的散列码。(或者应该有，我们稍后会讨论这个问题。)这种数据结构通常以这种技术命名，可通过名称中的`Hash`识别，其中`HashMap`是最著名的代表。

它们通常是这样工作的:

*   当添加一个元素时，它的哈希代码用于计算内部数组(称为桶)中的索引。
*   如果其他不相等的元素具有相同的散列码，则它们会出现在相同的桶中，并且必须被捆绑在一起，例如通过将它们添加到列表中。
*   当一个实例被提供给`contains`时，它的散列码被用来计算桶。只有其中的元素会与实例进行比较。

这样，很少，理想情况下不需要`equals`比较来实现`contains`。

与`equals`一样，`hashCode`在`Object`上定义。

## 关于哈希的思考

如果把`hashCode`作为判断相等的捷径，那么我们真的只需要关心一件事:相等的对象应该有相同的哈希码。

这也是为什么如果我们覆盖`equals`，我们必须创建一个匹配的`hashCode`实现！否则，根据我们的实现，相同的东西可能不会有相同的散列码，因为它们使用了`Object`的实现。

## `hashCode`合同

引用[来源](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--):

> `hashCode`的总承包合同是:
> 
> *   在一个 Java 应用程序的执行过程中，只要在同一个对象上多次调用该方法，`hashCode`方法就必须始终返回同一个整数，前提是在对象的 equals 比较中使用的信息没有被修改。这个整数不需要从一个应用的一次执行到同一应用的另一次执行保持一致。
> *   根据`equals(Object)`方法，如果两个对象相等，那么在这两个对象上调用`hashCode`方法必须产生相同的整数结果。
> *   根据`equals(Object)`方法，如果两个对象不相等，那么对这两个对象中的每一个调用`hashCode`方法必须产生不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同的整数结果可能会提高哈希表的性能。

第一个要点反映了`equals`的一致性属性，第二个要点是我们上面提出的要求。第三个国家的一个重要细节，我们将讨论一会儿。

![math](../Images/120cdc4a0bd81bacaf2761d4449c9eb1.png)

## 实施`hashCode`

下面是`Person.hashCode`的一个非常简单的实现:

```
@Override
public int hashCode() {
    return Objects.hash(firstName, lastName);
} 
```

通过计算相关字段的散列码并组合它们来计算该人的散列码。两者都留给`Objects`效用函数`hash`。

### 选择字段

但是哪些领域是相关的呢？这些需求有助于回答这个问题:如果相等的对象必须有相同的哈希代码，那么哈希代码计算不应该包括任何不用于相等性检查的字段。(否则，仅在这些字段不同的两个对象将是相等的，但具有不同的散列码。)

所以用于散列的字段集应该是用于相等的字段的子集。默认情况下，两者将使用相同的字段，但有几个细节需要考虑。

### 一致性

首先，有一致性的要求。应该相当严格地解释它。虽然它允许哈希代码在某些字段改变时改变(这对于可变类来说是不可避免的)，但是哈希数据结构并没有为这种情况做好准备。

正如我们在上面看到的，散列码用于确定一个元素的桶。但是，如果与哈希相关的字段发生变化，则不会重新计算哈希，也不会更新内部数组。

这意味着稍后使用同等对象甚至完全相同的实例的查询会失败！数据结构计算当前的散列码，不同于用于存储实例的散列码，并在错误的桶中查找。

结论:最好不要使用可变字段进行哈希代码计算！

### 表演

散列码可能会在调用`equals`的时候被计算。这很可能发生在代码的性能关键部分，因此考虑性能是有意义的。与`equals`不同的是，有更多的回旋余地来优化它。

除非使用复杂的算法或者涉及很多很多的字段，否则组合它们的散列码的算术成本是可以忽略的，因为它是不可避免的。但是要考虑是否所有的字段都需要纳入计算！尤其是收藏品，应该用怀疑的眼光看待。例如，列表和集合将为它们的每个元素计算散列。是否有必要给他们打电话应该根据具体情况来考虑。

如果性能很关键，使用`Objects.hash`可能也不是最佳选择，因为它需要为它的[变量](https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html)创建一个数组。

但是关于优化的一般规则是:不要过早地做！使用一个通用的哈希代码算法，可能会放弃包括集合，只有在分析显示有改进潜力后才进行优化。

### 碰撞

在性能上全力以赴，那么这个实现呢？

```
@Override
public int hashCode() {
    return 0;
} 
```

很快，这是肯定的。相等的对象会有相同的哈希码，所以我们也很擅长这个。额外的好处是，不涉及任何可变字段！

但是还记得我们说过的水桶吗？这样，所有实例都将以相同的方式结束！这通常会导致一个包含所有元素的链表，这对性能来说是很糟糕的。例如，每个`contains`触发列表的线性扫描。

所以我们想要的是同一个桶里的物品越少越好！一个返回变化很大的散列码的算法，即使是非常相似的对象，也是一个好的开始。

如何到达那里部分取决于所选择的领域。我们在计算中包含的细节越多，散列码就越有可能不同。请注意，这与我们对性能的想法完全相反。因此，有趣的是，使用太多的*或太少的*字段会导致糟糕的性能。

防止冲突的另一部分是用于实际计算散列的算法。

### 计算哈希值

计算一个字段的散列码最简单的方法是在它上面调用“hash code”。可以手动合并它们。一种常见的算法是从某个任意数字开始，并在添加字段的哈希之前反复将其与另一个数字(通常是一个小素数)相乘:

```
int prime = 31;
int result = 1;
result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
return result; 
```

这可能会导致溢出，但这并不是什么大问题，因为它们不会在 Java 中引起异常。

请注意，如果输入数据具有特定的模式，即使是优秀的哈希算法也可能导致异常频繁的冲突。作为一个简单的例子，假设我们将通过添加点的 x 和 y 坐标来计算点的散列。听起来可能不太坏，直到我们意识到我们经常处理线上的点`f(x) = -x`，这对它们都意味着`x + y == 0`。碰撞，伽罗！

但是，还是那句话:使用一个通用的算法，不要担心，直到分析显示有什么不对劲。

### 摘要

我们已经看到，计算散列码类似于将相等压缩为整数值:相等的对象必须具有相同的散列码，并且出于性能原因，最好是尽可能少的不相等的对象共享相同的散列。

这意味着如果`equals`为，则`hashCode`必须被覆盖。

执行`hashCode`时:

*   使用与`equals`中相同的字段(或其子集)。
*   最好不要包含可变字段。
*   考虑不要在集合上调用`hashCode`。
*   使用通用算法，除非输入数据中的模式抵消了它们。

记住`hashCode`是关于性能的，所以不要浪费太多的精力，除非分析表明有必要。

## 分享这篇文章