# 重新介绍 Composer，现代 PHP 应用程序的基石

> 原文:[https://www.sitepoint.com/re-introducing-composer/](https://www.sitepoint.com/re-introducing-composer/)

在本文中，我们将探讨 Composer 的基础知识，以及是什么让它成为如此强大而有用的工具。

在讨论细节之前，我们需要记住两件事:

*   What Composer is:

    正如我们在他们的[网站](https://getcomposer.org) : *上看到的，“Composer 是 PHP 中的依赖管理工具。它允许您声明项目所依赖的库，并为您管理(安装/更新)它们。”*

*   What Composer is not:

    Composer 不是包管理器。它处理包，但是以“每个项目”的方式。虽然它提供了一个全局安装选项，但默认情况下它不会全局安装任何东西。

本质上，Composer 允许您声明和管理 PHP 项目的每个依赖项。

现在让我们安装 Composer，这样我们就可以看到它的运行。

![Composer Logo](../Images/e016a500c1301055fe0c81d43f665a18.png)

## 装置

有两种安装 Composer 的方式:本地和全局。因为 Composer 是一个如此有用和广泛使用的工具，我总是建议在全球范围内安装它，因为您可能会同时处理多个项目。

*注意，如果你使用像 [Homestead Improved](https://www.sitepoint.com/quick-tip-get-homestead-vagrant-vm-running/) 这样的环境，默认情况下它是全局安装的。如果你对流浪汉和家园不熟悉，[这篇文章](https://www.sitepoint.com/re-introducing-vagrant-right-way-start-php/)会让你明白一些事情，如果你想深入了解，[这本书会向你揭示一些狂野的秘密](http://bit.ly/phpenv-sp)。*

要安装 Composer，请遵循针对您的操作系统的说明。

如果您在 Unix 系统上，安装之后您可以运行命令:

```
mv composer.phar /usr/local/bin/composer 
```

这将把`composer.phar`文件移动到您的路径上的一个目录中(默认情况下，操作系统在您的文件系统中查找可执行文件的位置)。这样，你可以只使用`composer`命令，而不是`composer.phar`。

运行`composer`命令显示信息页面:

![Composer main information](../Images/d28501ceef2ead2ed2b848d81410d3df.png)

Composer 的一些更有用的命令是:

*   `composer help <command>`–将显示给定命令的帮助页面。
*   `composer self update`–将 composer 更新至最新版本。
*   `composer search`–搜索包裹。
*   `composer status`–显示已在本地修改的依赖项列表。如果我们从源代码安装一些东西(使用`--prefer-source`选项)，我们将在`/vendor`文件夹中得到那个包的克隆。如果我们对这个包做了一些更改，`composer status`命令将显示这些更改的 git 状态。
*   `composer diagnose`–诊断系统的常见错误。这对于调试特别有用，因为它会检查与 Packagist 的连接、空闲磁盘空间和 git 设置等。

我们将注意力集中在`composer init`、`composer create-project`和`composer require`上。

## 使用作曲家

为了管理项目中的依赖关系，Composer 使用了一个`json`文件。这个文件描述了所有的依赖项，也保存了一些元数据。

在这个例子中，我们将创建一个新的 PHP 项目，在这个项目中，我们需要 PHPUnit 来进行单元测试。有几种方法可以使用 Composer 来管理这种依赖关系。

*   `composer init`将启动向导。向导将指导我们完成`composer.json`文件的生成。
*   `composer search phpunit`将搜索包含关键字`phpunit`的所有可用包。在我们选择了我们想要的包之后，我们可以使用`composer require <package>`。这个命令不仅会创建`composer.json`文件，还会下载所有指定的依赖项。
*   手动编写`composer.json`文件(不推荐——容易在语法上出错，并且没有明显的好处)。这里有一个例子:

```
{
    "require": {
        "phpunit/phpunit": "^4.8"
    }
} 
```

*   `require`键获取将包名(例如`phpunit/phpunit`)映射到版本约束(例如`4.8`)的对象。Composer 使用这些信息在您使用`repositories`键(更多信息[在这里](https://getcomposer.org/doc/05-repositories.md))注册的包“资源库”中或者在 [Packagist](http://packagist.org) 上搜索正确的文件集，默认的包资源库我们稍后将讨论。

如果您使用了`composer init`或手动方法，您需要运行`composer install`。这将下载`composer.json`文件中描述的包所需的所有依赖项。

注意手动写文件然后运行`composer install`和运行`composer require <package>`是一样的。

> 使用`composer require <package>`方法是推荐的[最佳实践](https://www.sitepoint.com/mastering-composer-tips-tricks/)。

第一次运行`composer install`命令时，会下载依赖项，并在`composer.lock`文件中注册它们的安装版本。下一次有人在项目上运行`composer install`时，它将不会获得最新的可用包版本，而是那些注册在`composer.lock`文件中的版本。这样，Composer 可以确保您的项目不会因为新版本包中的意外代码更改而中断。

### 更新您的包

`composer.lock`文件通过不允许下载新版本来确保项目中的每个人都使用相同版本的包。

如果出于某种原因，我们想坚持使用某个特定的版本，那么我们应该在`composer.json`文件中提到合适的版本。例如:

```
 {
      "require": {
          "phpunit/phpunit": "4.8"
      }
  } 
```

但是，如果我们想将我们的依赖项更新到最新版本，该怎么办呢？

为了更新依赖关系，Composer 提供了`composer update`命令。这个命令不仅会下载我们的依赖项的最新版本，还会将`composer.lock`文件更新到新版本。运行`composer update`实际上和删除`composer.lock`然后重新运行`composer install`是一样的。

> 一般建议在处理项目(app)时将`composer.lock`文件提交到版本控制系统中，在处理包时忽略它。一个包应该总是努力使用其依赖项的最新版本，而一个应用程序通常更脆弱。更多关于这个和替代方法的讨论[在这里](https://www.reddit.com/r/PHP/comments/2kt4cw/composer_its_all_about_the_lock_file/)。

## 供应商文件夹

Composer 将所有依赖项下载到`/vendor`文件夹中，如果该文件夹不存在，它将创建该文件夹。它还创建了一个类似下面的`vendor/autoload.php`文件:

```
<?php

// autoload.php @generated by Composer

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit7a731d2067108a4739c3dd65be722f17::getLoader(); 
```

一旦您在代码中`include`或`require`了这个文件，您就可以使用您的依赖项所提供的所有功能。这很简单，只需将以下代码片段添加到您的代码中:

```
require __DIR__ . '/vendor/autoload.php'; 
```

## 半自动的

Composer 提供的访问项目依赖项的自动加载非常有用，也可以用来访问我们自己的应用程序代码。为此，我们需要使用`autoload`键在`composer.json`文件中注册我们的代码。

```
{
    "autoload": {
        "psr-4": {"Foo\\": "src/"}
    }
} 
```

首先，Composer 将为`Foo`名称空间注册一个 [PSR-4 自动加载器](https://www.sitepoint.com/battle-autoloaders-psr-0-vs-psr-4/)。

然后，我们将`Foo`名称空间映射到`/src`文件夹。`/src`文件夹应该和`/vendor`文件夹(项目的根目录)在同一层。在这之后，我们需要重新生成`vendor/autoload.php`文件。Composer 为此提供了一个命令:`composer dump-autoload`。

*Pro-tip: `composer du`也可以工作，因为 composer 运行任何由其前几个字母唯一标识的命令。在`dump-autoload`的例子中，Composer 名称空间中没有其他以`du`开头的命令，所以 Composer 知道这是我们想要的命令。这适用于所有 Composer 命令。*

通过这种方式，我们可以将自己的代码添加到自动加载程序中。除了 PSR-4 自动加载之外，Composer 还支持 PSR-0、类别映射和文件自动加载。查看[文档](https://getcomposer.org/doc/04-schema.md#autoload)了解更多关于 Composer 自动加载的信息。

## 配置值和最低稳定性

有时候，你的项目会依赖于没有发布稳定版本的包。Composer 默认阻止安装不稳定的软件包。

在这些情况下，很容易将`minimum-stability`标志添加到`composer.json`文件中，Composer 将允许它们的安装。

```
composer config minimum-stability dev 
```

几乎所有的配置值都可以从命令行编辑，如文档的[这一节](https://getcomposer.org/doc/03-cli.md)中所述。

## 全球套餐

如果在全球范围内安装，有些软件包会派上用场。举个例子，像 [Spress](https://www.sitepoint.com/building-an-spress-svbtle-theme-responsive-static-blogs/) 和 [Laravel](https://www.sitepoint.com/premium/courses/laravel-5-2930?aref=bskvorc) 这样的工具可以有命令行工具来生成新的项目，重新运行一些常用命令等等。同样，像 PHPUnit 这样的测试套件可以从系统的任何部分运行中受益，并使它测试的项目更加轻便。

一般来说，可以使用`global`选项全局安装软件包，如下所示:

```
composer global require phpunit/phpunit 
```

然而，[根据一些](https://www.sitepoint.com/composer-global-require-considered-harmful/)的说法，这被认为是有害的。您的里程可能会有所不同——我们通常发现，当遵循在隔离环境中开发[的专业和现代方法时，`global require`是 100%安全的。](https://bit.ly/phpenv-sp)

## 包装学家

![Packagist](../Images/7467b297dc0679faddaa488aad44df83.png)

[包装商](https://packagist.org/)是作曲家的主要仓库。这是所有 Composer 包聚集的地方，这意味着当我们执行`composer search <package>`时，我们实际上是在搜索 Packagist。Packagist 网站也有所有包裹的信息和一个有用的搜索和分类引擎。这样 PHP 开发人员就不用花几天时间在 Github 上搜索包了。

Packagist 不仅聚合 PHP 包，它还鼓励 PHP 开发人员提交他们自己的包，从而加强了社区。

### 向包装商提交包装

让我们创建一个简单的 PHP 包，这样我们可以看到将它提交给 Packagist 是多么容易。我们将创建一个简单的类，将英寸转换成厘米，将厘米转换成英寸。让我们创建一个`/src/Converter/Converter.php`文件。在这个文件中，我们将有以下代码:

```
<?php 

namespace Converter;

class Converter
{
    public function convertToCm($value)
    {
        return $value * 0.3937;
    }

    public function convertToInch($value)
    {
        return $value * 2.54;
    }
} 
```

如你所见，这是一个非常简单的类。第二步是导航到我们项目的根目录，运行`composer init`命令来运行向导并生成`composer.json`文件。

![Run init on our package](../Images/2b827b995eef122effd761904f8c975f.png)

我们需要做的最后一件事是将自动加载键添加到我们的`composer.json`文件中。最终文件应该如下所示:

```
{
    "name": "dailymatters/inch-conv",
    "description": "Inch To Cm converter",
    "type": "library",
    "license": "creative commons",
    "authors": [
        {
            "name": "DailyMatters",
            "email": "email@gmail.com"
        }
    ],
    "minimum-stability": "dev",
    "require": {},
    "autoload": {
        "psr-0": {
            "Converter": "src/"
        }
    }
} 
```

现在让我们运行`composer install`，这样就可以创建我们的自动加载器了。然后，让我们测试我们的软件包。在我们项目的根目录下，让我们创建一个`index.php`文件。

```
<?php

require_once '/vendor/autoload.php';

use Converter\Converter;

$conv = new Converter;

$result = $conv->convertToCm(1);
echo $result;

$result = $conv->convertToInch(1);
echo $result; 
```

如你所见，我们使用`require_once '/vendor/autoload.php';`行来自动加载我们的类，然后用它来做一些转换。

在命令行上用`php index.php`测试它应该会产生想要的结果。

要将这个包提交给 Packagist，我们需要将其推送到 Github repo。然后，我们使用 Github 帐户登录 Packagist，点击`Submit`，并指向我们新创建的 Github repo。

> 每当你在 Github 中更新你的 repo 时，记得更新 Packagist！您可以将 Packagist 配置为自动完成，也可以在 Packagist 上访问您的包并单击`Update`按钮。这样，您在 Packagist 中的包将总是镜像您的包的 Github 状态。

## 结论

Composer 彻底改变了 PHP 开发人员的工作方式，并承诺将继续这样做。对于任何 PHP 开发人员来说，它都是一个强大而必要的工具，也是许多现代 PHP 应用程序的基石。

你在用 Composer 吗？有什么不清楚的吗？请在下面的评论中告诉我们。

## 分享这篇文章