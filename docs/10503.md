# 为触摸设备调整接口

> 原文:[https://www . site point . com/adapting-an-interface-for-touch-devices/](https://www.sitepoint.com/adapting-an-interface-for-touch-devices/)

我们设计的世界正在以相当快的速度变化。去年这个时候，移动网络是热门话题。我们都在为手持设备构建我们的网站和应用程序的优化版本，并惊叹我们可以让它们看起来像原生的 iPhone 应用程序。

在那之后不久，当 Android 平台变得流行时，我们意识到我们不应该将我们的界面如此紧密地绑定到一个特定的设备上。因为，不是每个人都有 iPhone。设计一个移动网站或应用程序，好像它是苹果军队的一部分，可能会降低我们大多数用户的整体体验。所以我们开始在移动设计中解放自己，就像我们在桌面上做的一样。

我们用于设备检测的技术已经成为标准，以至于很少受到质疑。我们要么检测服务器端，将用户发送到一个针对移动设备优化的不同网站，要么使用媒体查询来检测屏幕大小，并相应地调整设计。

但正如伯特兰·罗素(Bertrand Russell)所写的:“在所有事务中，时不时地对你长期以来认为理所当然的事情打上问号是一件有益的事情。”

我来这里是想让你知道，建立完美的用户体验至少还有一步:触摸检测。

## 检测的当前状态

检测用户是否在移动设备上的最佳实践场景主要有两种方式。第一种已经存在了一段时间，是服务器端的基于设备的检测。第二种是使用 CSS 媒体查询来检测屏幕大小。当然，这两种方法各有利弊。那么，让我们来看看，好吗？

### 检测设备

[检测设备](http://detectmobilebrowsers.mobi/)可以非常有效地锁定特定用户。这通常是通过拉入`User-Agent`字符串并通读其中的某些关键词(如“iphone”)来完成的。这样做，你可以知道哪个设备被用来查看你的网站或应用程序，并根据不同的场合修改你的设计。

#### 利益

在服务器上运行检测脚本肯定有它的好处。无论如何，100 次中有 99 次服务器会比客户机快，因此有明显的性能优势，并且您对返回的数据有更多的控制。一般来说，除非您有一个受控的或有针对性的环境，否则这很少应该留给有时不存在的技术，比如 JavaScript。另一个优势是，您可以专门针对用户群中的任意数量的设备。例如，如果你只想让 iPhones 和 Android 设备看到你的优化设计，使用这种方法很容易实现。

用 PHP 拉`User-Agent`非常容易。这里我们只是出于调试目的重复了一下:

```
<?php echo $_SERVER['HTTP_USER_AGENT']; ?>
```

#### 缺点

这种方法的缺点正是激发我寻找另一种方法的原因。当试图为移动设备设计时，理想的情况是，你希望把它们都作为目标，创建一个灵活一致的界面。这就是问题所在。当使用任何种类的设备检测时，将难以有效地扩展。过了一段时间，您发现自己试图管理一个 20-30 个受支持设备的列表，如果一个设备不在该列表中，它将不会被选中。

您可能遇到的另一个问题是部分`User-Agent`字符串匹配。我在创建一个移动网站时发现了这一点，并注意到 Opera 出于某种原因正在采用我的移动设计。仔细查看后，我发现 Opera `User-Agent`字符串包含单词“Presto”，这是它的渲染引擎。不幸的是，由于 p-r-e 的原因，这导致了“Palm Pre”`User-Agent`的问题。随着可用设备范围的扩大，我认为我们会看到更多关于服务器端设备检测的此类问题。

### 检测屏幕尺寸

目前，屏幕(或窗口)大小检测是通过 CSS 媒体查询完成的。这些查询通常嵌入在主样式表中(尽管它们可以是独立的)，并且可以根据需要分成任意多的屏幕大小。大多数人和两三个人一起工作。如果你想阅读更多关于媒体询问的内容，请查阅伊桑·马科特的[响应式网页设计](http://www.alistapart.com/articles/responsive-web-design/)文章，来自*的一份列表*。

#### 利益

使用媒体查询是在较小的屏幕上定位用户的一种非常快速和轻量级的方式。这些都很棒，因为它们不仅适用于移动设备，也适用于任何屏幕更小的设备，如上网本。它们在防止水平滚动方面帮助很大，更不用说用户在使用较小的浏览器窗口时可能会感到局促，同时仍然呈现可用的设计。

#### 缺点

正如我们所希望的那样，小屏幕不一定意味着触摸设备。即使是支持媒体查询的小屏幕也不一定是触控设备。因此，虽然这种方法对于一般的设计和布局可能非常有效，但它基本上不能应用到界面设计中。一些用户交互，比如拖放，在小屏幕设备上运行良好——只要还有指点设备。对于只有触摸功能的设备，拖放是远远不够的。给定设备也可能不支持媒体查询。根据您的受众，您可能想要探索另一种选择。

## 为什么我们需要另一种方式

我们已经确定，目前最流行的两种移动检测方法都有缺点:一种难以扩展，另一种不适合界面设计。

让我们退后一步，问问自己我们关心的是哪些设备。基本上，任何具有小屏幕尺寸、可触摸屏幕或两者兼有的设备都应该成为特别调整界面的目标。从技术上讲，这涵盖了相当多的设备，但实际上，我们谈论的是这些特定的类别:

*   触摸平板电脑(包括 iPad)

*   上网本

*   现代移动电话或设备

iPads(或其他触摸平板电脑)和上网本之间的差异是一个完美的例子，说明在界面设计方面，媒体查询本身是不够的。iPad 和典型的上网本的屏幕大小大致相同，因此媒体查询很适合布局考虑；然而，iPad 的触摸功能阻碍了许多我们认为理所当然的应用程序的正常界面元素。我们必须考虑到这一点，以创造最好的体验。

### 触摸界面让我们失去了什么

触控界面很牛逼吧？他们是未来的潮流。但是，我们与支持触摸的设备交互的方式与我们与非触摸设备交互的方式有很大不同。这远远超出了正常的补偿，比如在链接周围插入更多的填充，为一个人的手指创造更大的点击区域，或者解释为什么没有鼠标。

当在触摸环境中开发时，我们失去了一些我们已经喜欢上的更丰富的界面元素；例如，悬停状态、内部页面滑动和拖放。

如果我们关注功能而不是限制，我们就可以避免求助于不那么令人兴奋的界面来解释这些新设备。拖放在触摸设备上失败的原因不是因为它没有意义；这是因为将手指按向屏幕并移动它的动作已经有了一个默认行为:滚动。同样的原理也适用于在大多数现代触摸设备上手指捏放作为整页缩放。同样，我们可以用 return 语句`false`阻止一个链接触发，我们也可以阻止手指的滚动或缩放。

### 创造丰富的体验

所以我们有它。媒体查询允许我们使用特定版本的布局来确定设备屏幕的大小，但是当涉及到向触摸和非触摸设备提供专用界面时，它们就失败了。在我对 iPad 的挫折感达到临界点后，我决定做一些老式的研究，看看是否有办法判断一个设备是否具有触摸功能。在花了几个小时浏览 Safari 开发者文档后，我发现有一小部分概述了`Touch`对象以及如何处理某些事件。这是我的发现。

## 如何检测触摸

Safari 为我们提供了一个名为`Touch`的 JavaScript 事件对象，这个小家伙的唯一职责就是让你知道你正在使用的设备有一个响应的触摸屏界面。这是圣杯，正是我开始四处寻找的东西。不用说，我是极客了。

实现非常简单:

```
if(window.Touch) { /* JavaScript for your touch interface */ }
```

检测到触摸功能后，您可以进行各种调整来完善界面。坏处(你没想到会这么容易吧？)因为它目前只在苹果设备上运行。

当然，还有另一种方法:你可以在第一次触摸屏幕时进行触摸检测。这远非理想，但仍是检测设备触摸的有效方法。这种方法在大多数现代设备中也得到更广泛的支持。缺点是你不能依靠它来对你的设计进行重大修改；这将导致用户一接触屏幕，页面就突然变形。但是，正如我们所讨论的，如果您主要想要触摸检测来调整丰富的交互，如悬停状态或拖放，您应该能够做到这一点:

```
var touch_detect = {  handler: function(event){    /* JavaScript for your touch interface */  }};document.ontouchstart = touch_detect.handler;
```

通过以这种方式检测触摸，我们可以做任何事情:从切换特殊类别以补偿悬停控制的缺乏，到构建一个全新的界面，专注于利用设备固有的丰富功能。

我们还可以用相关的 JavaScript 事件来跟踪动作或行为:`ontouchmove`、`ontouchend`、`ontouchcancel`、`orientationchange`、`gesturestart`、`gesturechange`和`gestureend`。从 iPhone OS 2.0 开始，所有这些活动都可以在苹果设备上进行。目前只有一些动作支持 Android，比如`ontouchstart`，所以使用起来很安全。

当我们将这种检测方法与 CSS 媒体查询相结合时，我们可以制作一些非常快速、响应迅速且令人难忘的应用程序。这些不仅仅局限于手机，而且可以在任何地方一次性部署。构建一次，然后部署到各处。

### 默认行为

现在你已经知道了设备是否支持触摸，你可以开始为这个设备构建你的界面了。但在我们这样做之前，我们需要覆盖一些相对全局的触摸设备默认行为，就像前面提到的那样(没有双关语)。这些主要是手指滚动和缩放，它们会影响我们想要创建的任何拖放或特殊的手指移动动作。然而，我们希望避免全局禁用这些行为，因为它们仍然非常有用。相反，我们将使用事件侦听器逐个元素地禁用它们。

通过捕捉手指运动并劫持它，我们可以使用 jQuery 的`event.preventDefault()`方法阻止默认的滚动行为，并插入我们想要的任何内容。

下面是一个将触摸检测与事件监听器相结合来阻止默认操作的示例:

```
$(function(){  if(window.Touch) {    touch_detect.auto_detected();  } else {    document.ontouchstart = touch_detect.surface;  }}); // End loaded jQueryvar touch_detect = {  auto_detected: function(event){          /* add everything you want to do onLoad here (eg. activating hover controls) */        alert('this was auto detected');    activateTouchArea();  },  surface: function(event){       /* add everything you want to do ontouchstart here (eg. drag & drop) - you can fire this in both places */    alert('this was detected by touching');    activateTouchArea();  }}; // touch_detectfunction activateTouchArea(){  /* make sure our screen doesn't scroll when we move the "touchable area" */  var element = document.getElementById('*`element_id`*');  element.addEventListener("touchstart", touchStart, false);}function touchStart(event) {  /* modularize preventing the default behavior so we can use it again */  event.preventDefault();}
```

您可以看到我们正在为`touchstart`事件添加一个事件监听器。当这种情况发生时，我们调用函数`touchStart()`，该函数禁用侦听器所连接的任何元素的默认行为(滚动和缩放)。这个元素可以是一个`div`，一个链接，一个可拖动区域——任何你想要的东西。它将允许您与元素一起工作，而不用担心奇怪的行为。

## 支持触摸检测

目前，`Touch`对象仅在苹果产品(iPod、iPad、iPhone)中可用，但滑动检测和使用`ontouchstart`事件在许多现代设备中可用，包括 Android 设备。我没有机会全面测试新款黑莓手机。

如果要我猜的话，我会说`Touch`对象应该在不久的将来出现在大多数设备上。就是有意义，而且已经在 Safari 的 WebKit 里了；这是进入 Chrome、Android 和 WebOS 的捷径。

## 期待界面设计

每一项设计或开发技术都会有漏洞；没有完美的解决方案。最佳实践将会随着底层技术的发展而发展。如果我们能够采取一些渐进的步骤来为我们的用户创造最好的体验，我们将能够注入一层看起来如此自然以至于几乎看不见的交互。最终，最好的用户体验是我们从未听说过的。

## 为了进一步阅读

*   [阅读有关媒体查询的更多信息](https://www.w3.org/TR/css3-mediaqueries/)

*   [Safari 参考图书馆](http://developer.apple.com/library/safari/navigation/)

*   [为 Android 开发](http://developer.android.com/index.html)

*   [iOS 开发中心](http://developer.apple.com/devcenter/ios/index.action)

*   [移除 iPhone WebKit 上的 onClick 延迟](http://cubiq.org/remove-onclick-delay-on-webkit-for-iphone)

## 分享这篇文章