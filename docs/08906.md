# 。NET 到 Ruby:学习如何编写测试，第一部分

> 原文:[https://www . sitepoint . com/net-to-ruby-learning-how-to-write-tests/](https://www.sitepoint.com/net-to-ruby-learning-how-to-write-tests/)

如果你是一名. NET 开发人员，一直在编写测试，这篇文章可能会鼓励你在使用 Ruby 时继续这样做。相反，如果你没有写测试，我们必须改变它！我知道我以前提到过这一点，但我怎么强调它的重要性都不为过。

在我作为 C#开发人员的最初几年，我太依赖编译器了。我的想法是，如果编译器没有抱怨，那么我的代码就是正确的。那时，我是*“编写令编译器满意的代码”*，而不是*“构建令我的客户满意的应用程序”*。那么我是如何从一个过渡到另一个的呢？我可以向你保证，这不是一夜之间发生的，就像我可以向你保证的那样，每次我看到我的培根被我所做的测试拯救时，我都非常高兴。

我将分两部分发布这篇文章:第一部分介绍我在。第 2 部分讲述了我使用 Ruby 的经历。尽管第 1 部分中的所有代码都是用 C#编写的，但是某些部分看起来非常像 Ruby 风格，当您阅读第 2 部分时可能会意识到这一点。

## 从简单的断言开始

我对测试的第一次体验是写我认为是“单元测试”的东西。当时我只是写了一些断言，以确保对象上的某些方法返回我所期望的结果。大致是这样的:

```
[TestClass]
public class CalculatorTests
{
    [TestMethod]
    public void Test1()
    {
        var calculator = new Calculator();
        var result = calculator.Sum(1, 1);
        Assert.AreEqual(2, result);
    }

   [TestMethod]
   public void Test2()
   {
       var calculator = new Calculator();
       var result = calculator.Subtract(5, 3);
       Assert.AreEqual(2, result);
   }

}
```

我所知道的是，这些测试比运行应用程序好得多，等待登录屏幕出现，键入用户名和密码，等待验证完成，等待菜单出现，选择一些菜单项，在 UI 控件中跳转，直到我找到我想要手动测试的内容。要么这样，要么创建控制台应用程序(或其他类型的“测试平台”)来测试我的代码。

当时，我没有很好地组织我的测试代码:我曾经命名过像`Test1`和`Test2`这样的方法，它们并没有真正告诉我正在测试什么。测试代码中总是存在冗余，同一测试类被一次又一次地实例化。

## 更好地照顾我的测试代码

在花了一些时间写了很多这样的测试之后，我注意到代码很乱，当我需要维护它的时候，代码变得难以控制。我意识到我应该写更好的测试代码。我开始将重构技术应用到我的测试代码中:引入变量或常量并消除幻值，将冗余代码提取到单独的方法中，根据方法的意图命名方法，等等。

基于其他人正在做的工作，我开始以我的测试方法所测试的需求来命名它:

```
[TestMethod]
public void Sum_should_return_the_two_given_numbers_added_together()
{
     ...
}
```

我喜欢这样，因为如果测试失败，错误消息将包含失败的测试方法，我可以很快看到什么需求被破坏了。

当 C# 3.0 引入了*扩展方法*时，我跟随酷小子们创建了我的“测试扩展”，用断言使我的测试看起来像这样:

```
[TestMethod]
public void Sum_should_return_the_two_given_numbers_added_togeter()
{
    var calculator = new Calculator();
    var result = calculator.Sum(1, 1);
    result.ShouldBe(2);
}
```

你看，像许多其他人一样，在像 *Assert 这样的代码中阅读一些东西。AreEqual(2，result)* 似乎违反直觉；它几乎读起来像“断言等于结果”。当然，作为编码人员，我们倾向于这样解析代码，并从中获得一些意义。老实说，我宁愿不做那种心理分析，而只是读这样的代码:*结果。*应为②。伙计，让我用我的小脑袋做点别的吧。

顺便说一句，如果您还不了解扩展方法，这就是创建 ShouldBe 方法的方式:

```
public static class TestExtensions
{
    public static void ShouldBe(this object expected, object actual)
    {
        Assert.AreEqual(expected, actual);
    }
}
```

一旦测试代码看起来很干净，我的测试方法名称开始在某种程度上反映需求，并且我的测试代码不需要大量的心理分析就可以阅读，我开始用它来代替文档:如果我需要记住代码的某些部分应该如何使用，我会阅读测试。

## 跳到测试驱动的开发

几个月过去了，我听到人们谈论测试驱动开发(TDD)。在编写代码之前编写测试的想法对我来说完全陌生。我不得不强迫自己去尝试，即使有时它似乎没有意义。我越来越喜欢这种做法，我明白了人们为什么喜欢它。

编写代码很容易:我们可以使用代码生成器，或微型代码生成器(如 CodeRush 或 Resharper)，或代码片段，或 master Intellisense，或只是快速键入。然而，我最终编写了比实际需要多得多的代码。你知道，“我将把这段代码放在这里，因为用户可能在某个时候需要它，或者业务可能需要它，或者可能是这个，可能是那个，可能是另一个”。很多假设很多时候都不会成为现实，在应用程序中也不会出现。

实践 TDD 当我在写测试的时候，我开始考虑*“我想要的代码”*。我将学会更仔细地考虑如何使用我将要实现的对象，或者更重要的是，它对试图使用它的其他开发人员是否有意义。在我花时间实现这些类之前，我会让我的同事看一下测试并给我反馈。我会更仔细地考虑将参数传入方法:我应该传入一个小数或字符串，还是应该传入一个更明确的类型，如货币或 SSN？

知道了我的对象应该做什么，我开始更多地考虑只写足够的代码来通过测试。不多不少。“但是如果/如果/但是/也许会怎么样”。我不在乎。如果我的问题多于确定性，我就不会发挥创造力，写我能编出来的任何代码。这些代码肯定会被扔掉，或者更糟糕的是，当没有人需要它时，会污染代码库。

## 下一步:关注行为

我在行为驱动开发(BDD)中的第一步集中在我的应用程序的某些对象或组件的行为上。在“Given-When-Then”和“Context-Specification”测试框架之间来回切换之后，真正适合我的是 SubSpec，在这里我可以编写如下测试:

```
[Specification]
public void dynamic_properties()
{
    "Given additional dynamic data for a customer"
        .Context(() => make_data_for_a_customer());
    "When constructing a customer object"
        .Do(() => { _customer = GetCustomer(); });
    "Then the object should expose the additional data as properties"
        .Assert(properties_are_exposed);
    " And getters are available"
        .Assert(getters_are_exposed);
    " And setters are available"
        .Assert(setters_are_exposed);
}
```

那仍然只是 C#，但是我会从使用简单的英语句子开始写需求，形式是*“给定一些上下文，当某些事情发生时，那么一些期望应该被满足”*。这听起来可能是一件小事，但事实并非如此:我没有用 C#思考，而是用英语思考。一旦我对如何解释我的代码应该做什么有了一个清晰的想法，编写代码就容易多了。

## 值得这么麻烦吗？

麻烦？什么麻烦？我可以告诉你，经历所有这些改进我如何编写测试的迭代使我成为一个更好的开发人员:

*   我的 C#技能提高了:我学到了很多关于 lambdas、扩展方法、泛型和语言中的一大堆其他东西；
*   我的 OOP 技能提高了:我了解了[坚实的原则](http://en.wikipedia.org/wiki/SOLID_(object-oriented_design) "SOLID principles")，如何编写更好的对象、方法、抽象等等。；
*   我的英语技能提高了:如果我在代码中删除了英语句子，它们必须简短扼要。老实说，我认为如果我不能用英语清楚地交流，我的编码也会受到影响，我的代码会变得晦涩难懂。
*   我的沟通技巧提高了:如果我不能交流我的想法和对我需要做的工作的理解，我很可能会构建一个没有用户想要使用的应用程序。有了更好的沟通技巧，我就有更好的机会只花时间去构建客户真正需要的东西。

所以，没有麻烦？好吧，有些麻烦。从使用错误的工具(这使得编写测试成为一项艰巨的任务)到使用对测试不友好的框架或组件(我们不能测试我们的代码，因为它使用了一些不可测试的类；至少不是以一种容易的方式)。

还有一个文化问题:人们似乎很难理解为什么一个开发者要写一个测试。显然，花几个小时在调试器上是可以的，但是花时间写测试是不行的。客户真的关心开发人员是否写了一个 if 块、一个 switch 块、写了一个测试或者花了时间在调试器上吗？

好了，我跑题了……

回到你的问题:是的，就我而言，这不值得任何麻烦。在本系列的第 2 部分中，我回顾了使用测试如何帮助我相对快速地开始使用 Ruby，以及 Ruby 中的一些工具如何让我改进了开发软件的方式。在那里见…

## 分享这篇文章