# 了解 HTTP 摘要式访问认证

> 原文：<https://www.sitepoint.com/understanding-http-digest-access-authentication/>

摘要式访问身份验证是客户端和服务器可以用来通过 HTTP 交换凭据的一种方法。这种方法使用密码和其他信息位的组合来创建 MD5 哈希，然后将该哈希发送到服务器进行身份验证。发送散列避免了以明文发送密码的问题，这是基本访问认证的不足。

摘要访问最初是在 [RFC 2069](http://tools.ietf.org/html/rfc2069 "RFC 2069 - An Extension to HTTP: Digest Access Authentication") 中定义的，可选的安全性增强后来被添加到 [RFC 2617](http://tools.ietf.org/html/rfc2617 "RFC 2069 - HTTP Authentication: Basic and Digest Access Authentication") 中，如果您希望自己实现这种方法，应该将它视为当前的标准。我们将在本文中对这两者进行研究。

## 基本访问认证的问题是

首先，让我们看一个基本的访问认证。在您的浏览器中，您请求某种需要您进行身份验证的对象。如果浏览器没有缓存您已经提供的凭据，您将会看到一个“HTTP 401 未授权”响应，其中包含以下标题:

```
WWW-Authenticate: Basic realm="example.com"
```

然后，期望客户端/浏览器用适当的凭证来响应，以便被允许访问。

用户名和密码连接在一起，如“admin:p@ssw0rd”，然后这个字符串被 Base64 编码。编码字符串(YWRtaW46cEBzc3cwcmQ=)用于发送回服务器的授权头中。

```
Authorization: Basic YWRtaW46cEBzc3cwcmQ=
```

当服务器接收到这个请求时，它会注意到 Authorization 头，并应用相反的步骤(解码并拆分结果字符串)来获取原始的用户名和密码。然后，该过程可以对凭证进行任何必要的查找/验证。

这里的主要问题是 Base64 是一种数据传输方案；它不是散列或加密方案。也可以是明文。摘要式访问认证试图通过以散列值的形式发送密码来改进这一点，散列值更难(并非不可能)反向工程出明文值。

## 使用摘要式访问身份验证

使用摘要式访问身份验证时，当服务器发现客户端试图访问受限区域时，它必须首先采取行动。服务器需要提供一些值作为客户机所需的 WWW-Authenticate 头的一部分。

服务器生成一个值，称为 *nonce* ，该值对于每个请求应该是唯一的。
建议该值为 Base64 或十六进制，特别是因为它将被双引号括起来，我们希望确保字符串中没有双引号。客户端将使用 nonce 来生成一个哈希并发送回服务器。

在 PHP 中，对一个唯一的字符串应用`md5()`通常就足够了。

```
<?php
$nonce = md5(uniqid());
```

客户端需要的下一个值是 *opaque* 。这是由服务器生成的另一个唯一字符串，预计将由客户端不加修改地发送和返回。

```
<?php
$opaque = md5(uniqid());
```

最后一个值 *realm* ，只是一个显示给用户的字符串，这样他们就知道应该提供哪个用户名和密码。客户机也用它来生成一个散列并发送回服务器。

```
<?php
$realm = 'Authorized users of example.com';
```

所有这些值都用于组成 WWW-Authenticate 指令，并作为响应发送给客户端。

```
<?php
if (empty($_SERVER['PHP_AUTH_DIGEST']) {
    header('HTTP/1.1 401 Unauthorized');
    header(sprintf('WWW-Authenticate: Digest realm="%s", nonce="%s", opaque="%s"', $realm, $nonce, $opaque));
    header('Content-Type: text/html');
    echo '<p>You need to authenticate.</p>';
    exit;
}
```

当客户端收到这个响应时，它必须计算一个返回散列。它通过连接用户名、领域和密码并用 MD5 对结果进行哈希运算来实现这一点，如下所示:

1.  将`A1`计算为`MD5("*username*:*realm*:*password*")`。
2.  将`A2`计算为`MD5("*requestMethod*:*requestURI*")`。
3.  计算最后的散列，称为“响应”，称为`MD5("A1:*nonce*:A2")`。

客户端在授权头中将响应发送回服务器，包括用户名、领域、nonce、opaque、uri 和计算的响应。

```
Authorization: Digest username="%s", realm="%s", nonce="%s", opaque="%s", uri="%s", response="%s"'
```

请注意，realm、nonce 和 opaque 都原封不动地返回给服务器。

当服务器收到响应时，会采取相同的步骤来计算服务器的散列版本。如果计算出的散列值和接收到的响应散列值匹配，则该请求被认为是授权的。它看起来像这样:

```
<?php
$A1 = md5("$username:$realm:$password");
$A2 = md5($_SERVER['REQUEST_METHOD'] . ":$uri");
$response = md5("$A1:$nonce:$A2");
```

当然，用户的密码永远不会传递给服务器。然后，为了从数据库中执行认证查找，可以存储 A1 的值。但是请记住，如果你改变了你的领域，存储的散列将变得无效。

## 对原始摘要访问规范的改进

既然您已经熟悉了 RFC 2069 中的摘要式访问认证的工作原理，那么让我们将注意力转向 2617 中添加的一些增强功能:qop、nc 和 cnonce。

qop 或保护质量在 WWW-Authenticate 报头中指定，其值可以是“auth”或“auth-int”。当没有找到 qop 指令或者当它被设置为“auth”时，摘要式访问仅用于客户端身份验证——这是到目前为止您所看到的默认模式。当设置为“auth-int”时，会尝试为响应提供某种级别的完整性保护，并且客户端还必须将请求正文作为消息摘要的一部分。这允许服务器确定请求在缩进的客户机和目标服务器之间的传输中是否被掺杂。

客户端随机数，或 *cnonce* ，类似于随机数，但由客户端生成。cnonce 被计算到客户机计算的响应摘要中，它的原始值被传递给服务器，以便在那里可以用来比较摘要。这提供了一些响应完整性和相互身份验证，因为客户端和服务器都有办法证明它们知道一个共享的秘密。当服务器发送 qop 指令时，客户端必须包含 cnonce 值。

nonce count， *nc* ，是客户端用给定的 nonce 值发送的请求数的十六进制计数。这样，服务器可以防范重放攻击。

通过增强，A2 和响应的计算如下所示:

```
<?php
if ($qop == 'auth-int') {
    $A2 = md5($_SERVER['REQUEST_METHOD'] . ":$uri:" . md5($respBody));
}
else {
    $A2 = md5($_SERVER['REQUEST_METHOD'] . ":$uri");
}
$response = md5("$A1:$nonce:$nc:$cnonce:$qop:$A2");
```

## 摘要式接入认证的优势和劣势

摘要式访问比基本身份验证有一些优势，因为基本身份验证使用用户名和密码的明文交换，这几乎等同于告诉全世界您的密码是什么。摘要访问传递的是散列值而不是密码本身，因此它比基本身份验证安全得多。每个请求的服务器 nonce 应该是唯一的，它将极大地改变每个新请求的计算散列，RFC 2617 提供的 nc 值有助于防止重放攻击，从而恶意个人能够截取您的请求数据并“重放”或重复它作为自己的请求。

摘要式身份验证也有一些缺点。当 RFC 2617 取代了原来的规范时，为在客户机和服务器之间提供额外的安全措施而添加的增强功能变成了完全可选的，当没有实现时，摘要式身份验证将以其原来的 RFC 2069 形式进行。

另一个问题是 MD5 不是一个强大的哈希算法。所需要的只是时间和 CPU 来强力恢复原来的价值。Bcrypt 更可取，因为它对暴力攻击更有弹性。当使用摘要访问认证时，服务器也没有办法验证请求客户端的身份。这就为中间人攻击打开了方便之门，在这种攻击中，客户端可能会被引导去相信某个给定的服务器确实是他所认为的那个人，但最终会将他的登录凭证发送给一个未知的实体。

处理身份验证时，最好的办法是使用 SSL，并使用 Bcrypt 加密密码。您可以在 SSL 上使用基本身份验证或自制的身份验证机制，但是对于由于某种原因无法使用 SSL 的情况，摘要式访问比简单的基本身份验证和在公共互联网上以纯文本形式发送密码要好。

GitHub 上有一个关于 RFC-2069 HTTP 摘要访问的简单例子。如果你是那种喜欢探索和修补的人，请随意克隆它。开始练习的一个好地方是进行必要的修改，以使用存储在数据库中的帐户，而不是脚本中的硬编码凭据(记住，您需要计算并存储 A1 作为用户的密码哈希，以便以后登录时查找)，然后用 RFC-2617 特性增强它。之后，您将对 HTTP 摘要式访问认证有一个相当扎实的理解。

## 摘要

到目前为止，您应该对可用的 HTTP 身份验证方法有所了解。

基本身份验证是最容易实现的，也是最不安全的。用户名和密码以 Base64 编码，但实际上是以纯文本的形式发送到服务器。

摘要式身份验证通过 MD5 发送身份验证数据，对基本方法进行了改进。虽然 MD5 仍然不是一种强大的密码加密算法，但它比基本身份验证的纯文本/Base64 方法更难解码。在最初的形式中，仍然存在中间人攻击和无法确认服务器身份的问题，但是这些弱点在 RFC 的后续版本中已经得到了改进。

SSL 是通过公共互联网发送用户身份验证数据的最现代、最安全的方法。但是当 SSL 不可用时，请在基本身份验证上使用摘要。

<small>图片 via[Fotolia](http://us.fotolia.com/?utm_source=sitepoint&utm_medium=website_link&utm=campaign=sitepoint "Royalty Free Stock Photos at Fotolia.com")</small>

## 分享这篇文章