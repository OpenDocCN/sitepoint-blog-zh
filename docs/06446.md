# 用可移植的 UTF-8 将 Unicode 引入 PHP

> 原文:[https://www . site point . com/bring-unicode-to-PHP-with-portable-utf8/](https://www.sitepoint.com/bringing-unicode-to-php-with-portable-utf8/)

PHP 允许多字节变量名，如`$a∩b`、`$Ʃxy`和`$Δx`，mbstring 和其他扩展使用 Unicode 字符串，并且`utf8_encode()`和`utf8_decode()`函数在 UTF-8 和 ISO-8859-1 编码之间转换字符串。然而，人们普遍认为 PHP 缺乏 Unicode 支持。

本文介绍了缺少 Unicode 支持意味着什么，并演示了如何使用一个库来为 PHP 应用程序 Portable UTF-8 提供 Unicode 支持。

## PHP 中的 Unicode 支持

PHP 缺乏 Unicode/多字节支持，这意味着标准的字符串处理函数将字符串视为单字节字符序列。事实上，官方手册将 PHP 中的字符串定义为“一系列字符，其中一个字符与一个字节相同。”PHP 只支持 8 位字符，而 Unicode(和许多其他字符集)可能需要不止一个字节来表示一个字符。PHP 的这一限制影响了字符串操作的几乎所有方面，包括(但不限于)子串提取、确定字符串长度、字符串拆分、重排等。

解决这个问题的努力始于 2005 年初，但是将原生 Unicode 支持引入 PHP 的工作在 2010 年被停止并搁置，原因有几个。由于 PHP 中的原生 Unicode 支持可能需要数年才能实现，因此开发人员必须依赖 mbstring 和 iconv 等扩展来填补这一空白，但它们只能提供有限的 Unicode 支持。这些库不是以 Unicode 为中心的，也能够在非 Unicode 编码之间进行转换。它们为简化 Unicode 字符串的使用做出了积极的贡献。

但是前面提到的扩展也有它们的缺点。它们只为 Unicode 字符串处理提供了有限的功能，并且在默认情况下都没有启用。服务器管理员必须显式地启用任何或所有的扩展，以便可以通过 PHP 应用程序访问它们。共享主机提供商通常通过安装一两个扩展使情况变得更糟，使得开发人员很难依赖一致可用的 API 来满足他们的 Unicode 需求。

尽管如此，好的一面是 PHP 可以输出 Unicode 文本。这是因为 PHP 并不真正关心我们发送的是以 ASCII 编码的英文文本还是属于以多个字节编码的语言的其他文本。了解了这一点，PHP 开发人员现在需要的只是一个提供舒适的基于 Unicode 的字符串操作的 API。

## 便携式 UTF-8

最近的一个解决方案是创建用 PHP 编写的用户空间库。这些库可以很容易地与应用程序捆绑在一起，以确保 Unicode 支持的存在，即使缺少服务器/语言级别的支持。许多开源应用程序已经包含了它们自己的库，更多的应用程序使用免费的第三方库；一个这样的库是便携式 UTF-8。

Portable UTF-8 是一个免费的轻量级库，基于 mbstring 和 iconv 构建。它扩展了这两个扩展的功能，为基于 Unicode 的字符串操作、测试和验证提供了大约 60 个函数；它为几乎所有 PHP 常见的字符串处理函数提供了 UTF-8 感知的对应物。顾名思义，便携式 UTF-8 使用 UTF-8 作为其主要的字符编码方案。

出于速度原因，该库使用可用的扩展(mbstring 和 iconv ),并消除了直接使用它们的一些不一致之处，但是如果服务器上没有可用的扩展，就退回到用纯 PHP 编写的 UTF-8 例程。可移植性——UT8 是完全可移植的，适用于 PHP 4.2 或更高版本的任何安装。

## 使用便携式 UTF-8 处理管柱

不支持 Unicode 的文本编辑器在读取文本时可能会损坏文本，从这样的编辑器中复制并发布到 web 表单中的文本可能会导致应用程序使用无效的 UTF-8。当处理用户提交的输入时，重要的是我们要确保输入正是应用程序所期望的。为了检测文本是否是有效的 UTF-8，我们可以使用库的`is_utf8()`函数。

```
if (is_utf8($_POST['title'])) {
    // do something...
}
```

从无效字节中恢复字符是一项不可能的工作，因此去除不能被识别为有效 UTF-8 字符的字节可能是您唯一的选择。我们可以用`utf8_clean()`函数剥离无效字节。

```
$title = utf8_clean($_POST['title']);
```

每个 Unicode 字符都可以编码为相应的 HTML 实体，您可能希望在将文本输出到浏览器之前，用这种方式对文本进行编码，以帮助防止 XSS 攻击。

```
echo utf8_html_encode($title);
```

在字符串的开头和结尾修剪空白是很常见的。Unicode 列出了大约 20 个空白字符，还有一些基于 ASCII 的控制字符也应该考虑进行这种修整。

```
$title = utf8_trim($title);
```

另一方面，字符串中间可能有重复的空白，应该删除。以下显示了如何一起使用`utf8_remove_duplicates()`和`utf8_ws()`:

```
$title = utf8_remove_duplicates($title, utf8_ws());
```

出于 SEO 原因创建 URL slugs 的传统解决方案使用音译，并从 slug 中去除所有非 ASCII 字符。这使得一个网址没有它应有的价值。虽然 URL 可以支持 UTF-8 编码的字符，但不需要这样的剥离或音译，我们可以创建包含任何语言字符的丰富 slugs:

```
$slug = utf8_url_slug($title, 30); // char length 30
```

从输入验证开始，直到我们将数据保存到某个数据库，支持 Unicode 的应用程序关注的是字符和字符长度，而不是字节和字节长度。这种焦点的转移需要一个新的界面来理解这种差异。对输入字符长度进行限制是很常见的，所以如果输入超过 60 个字符，我们在这里创建一个子字符串。

```
if (utf8_strlen($title) > 60) {
    $title  = utf8_substr($title, 0, 60);
}
```

或者:

```
if (!utf8_fits_inside($title , 60)) {
    $title  = utf8_substr($title, 0 ,60);
}
```

使用 Portable-UT8 库有三种不同的方法来访问单个字符。我们可以使用`utf8_access()`来达到一个单独的字符。

```
echo 'The sixth character is: ' . utf8_access($string, 5);
```

`utf8_chr_map()`允许使用回调函数反复访问单个字符。

```
utf8_chr_map('some_callback', $string);
```

我们可以使用`utf8_split()`将一个字符串分割成一个字符数组，并将数组元素作为单独的字符来处理。

```
array_map('some_callback', utf8_split($string));
```

使用 Unicode 可能还需要我们找到字符串中的最小/最大代码点、拆分字符串、使用字节顺序标记、字符串大小写转换、随机化/混排、替换等。Portable-UT8 支持所有这些。

## 结论

PHP 6 的开发已经停止，导致开发多语言应用程序所急需的原生 Unicode 支持的延迟。因此，与此同时，服务器端扩展和用户空间库(如便携式 UTF-8)在帮助开发人员创建满足本地需求的更好的标准化网站方面发挥着重要作用。

## 分享这篇文章