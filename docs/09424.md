# ruby Devs–你太容易相信人了。宝石会毁了你。

> 原文:[https://www . site point . com/ruby-devs-your-gems-could-screw-you/](https://www.sitepoint.com/ruby-devs-your-gems-could-screw-you/)

你见过你正在使用的所有宝石的开发者吗？你知道他们对安全的个人立场吗？他们是否使用强密码或在每个网站上重复使用他们宠物的名字？

![Artists Rendition: Me deploying](../Images/f92465e86b16a3fb9231331164d1feae.png)

艺术家表演:我正在部署

我不知道我是否是唯一的一个，但是当我的宝石有更新时，我通常会很高兴地更新它们——运行我的测试——然后快乐地上路。我举起我的剑，大喊“部署！”对我的许多下属来说(嗯，我敲几个命令，然后部署——但这听起来一点也不令人印象深刻)。

***注**:如果你是一个仔细审查你更新的每一个 gem 中的每一个代码变更，以及它们所有的依赖关系的人，那么这篇文章不适合你……混蛋*。

## 我们是不是太信任了？

我担心更新 Gems 的工作流程不够透明——尤其是对新开发人员而言。我担心我们正在把我们的信任放在一个有一个主要弱点的系统上:个体宝石开发者的安全。我担心有人会获得一个开发者账户的访问权，并对我使用的一个 gem 进行恶意修改。而且，最重要的是，*我担心我会在不知不觉中使用这块宝石，然后被骗*。

问题是我们天真地相信其他开发者的代码，这只会变得更糟。去数一数你正在使用的其他开发者宝石的数量。害怕了吗？没有吗？继续读。

## 概念证明

为了证明这个概念，我创造了一个名为`innocent`的新宝石。它只有一个`Something::Innocent#perform_action`方法，接受一个字符串，然后返回它…通常是这样。这在 2.0 版本中运行良好，但是有人访问了我的笔记本电脑；或者我的 GitHub 回购；或者挟持我的女朋友，要求我交出我的私人钥匙；并推出了 3.0 版本，该版本也调用了`Something::Evil#do_evil`方法。

如果您检查下面的代码，您会看到所有这些都是读取您的 database.yml，然后将其作为一个异常。但是你所需要做的就是把它用电子邮件发送出去，你手头就有了一个严重的问题——而你甚至没有意识到它。

这显然是假设您在这里运行的是 Rails 堆栈，但是找出常见的配置文件并发送它们也同样容易。

这里是`Something::Innocent`在工作，被`Something::Evil`玷污。

```
module Something
    class Innocent
    def self.perform_action(string)
      Something::Evil.do_evil
      string
    end
  end
  class Evil
    def self.do_evil
      file = File.open("./config/database.yml", "r")
      raise file.read.inspect
      # I could just as easily email this information
        # Or I could browse directories for API Keys
        # Or I could email your wife and tell her about the other girl
    end
  end
end
```

如果你想检查一下，在[https://github.com/snikch/innocent-project](https://github.com/snikch/innocent-project)有一个使用无辜宝石的示例项目，无辜宝石本身在[https://github.com/snikch/innocent](https://github.com/snikch/innocent)。

提交 *d3cff993b62e05d7e1cc* 是“之前”点。
提交 *ba1db02e4405b4fc614b* 在包更新之后。

## 不要激怒我

我知道我们才是应该检查我们在项目中使用的代码的人，当然最终责任在于我们自己。我不想否认这一点，但我想说的是，我们是人，很容易犯节省时间的错误，而不是在工作的某些方面花费我们应该花的时间。每周/每月/每十年花几个小时观察代码更新不是我们想要或者应该需要花时间去做的事情。

## 我的工作流程——朝着正确方向迈出的一步

我们在 [Learnable](https://learnable.com) 采用的工作流程并不一定是为了解决这个问题，但*是为了*降低风险。我们不再包括不在我们自己的库中的 git Gems。这意味着我们要更新一个 Gem，我们需要将 owners 分支合并到我们自己 fork 的 master 分支中。当我们这样做时，我们可以看到正在发生的变化，并有机会发现任何有趣的事情。

这并没有解决问题，但它*确实*向更透明的更新过程迈进了一步，在那里我们可以看到正在进行的更改，并且通过这一点，任何人都很难跳过代码审查过程。我们的大多数 gem 都不是从 git 回购中提取的，所以这实际上只为我们使用的少数 gem 提供了一个级别的保护。

这是一个繁琐的步骤吗？**是的**。
这会让我们的代码更安全吗？**也许是**。如果这能让我们在某个时候免受攻击，我会高兴吗？**地狱是的**。
值得吗？**我不确定**。

我很想听听人们在这方面的意见，以及他们在降低这种风险方面的任何想法。

## 人们不会注意到吗？

对大多数人来说，这显然不会成为广受欢迎、贡献良多的 Gems 的问题。让代码如此卑鄙地通过强大的用户和贡献者社区几乎是不可能的。一个拥有 100，000 名用户的 Gem 不可能在恶意提交时不被抓住。

一个拥有数百或数千用户、经常提交但只有一个核心贡献者的 Gem 将是一个更有可能的候选——特别是如果它只是一个小的 Gem，实际上只是在你的项目的外围。

谁想对 Gem 进行代码审查，为您的营销人员想要的管理报告提供稍快的 csv 解析？或者，更恰当地说，谁想关注营销人员“需要”的依赖于 csv 解析 Gem 的 Gem！

## 所以…

我们是不是太信任了？*我是这么认为的*。
我们能做点什么吗？*你告诉我*。

***认真地。我想知道人们对此的看法，所以请在评论*** 中投稿。

## 发布脚本。

有一天，我花了一些时间思考这个问题，并起草了一封电子邮件给我的同事，然后决定这不是一个问题。就在第二天，我一直在思考的攻击媒介出现在一些流行的 WordPress 插件上。

## Post Post 脚本。

如果有人提到代码签名，我会踢他们的小腿。

## 分享这篇文章