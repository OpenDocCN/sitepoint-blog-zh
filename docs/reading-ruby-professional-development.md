# 阅读 Ruby 促进职业发展

> 原文：<https://www.sitepoint.com/reading-ruby-professional-development/>

![Female Software Engineer](img/0fffd2ceb88bf507bfc5a98584c1d3f5.png)

Peter Seibel 最近在博客上挑战了“为了阅读而阅读代码”的观点。“代码不是文学，我们也不是读者，”他总结道。"相反，有趣的代码片段是标本，我们是博物学家."

那是部分真实的。有趣的代码片段是样本。将代码行从程序或框架的上下文中抽离出来，代码行就像盒子里大头针上的死虫子。

坐在一起喝一杯白兰地，讨论十几行代码，就好像它们是一些奇异的昆虫，甚至是诗歌，这可能很好，但很少有开发人员能负担得起这种奢侈。开发人员有工作要做，有问题要解决，这些都嵌入在成千上万行支持代码中。通常，这些行是由许多开发人员构建的，他们试图解决一系列随着时间的推移而不可预测地演变的问题。

但这并不是说开发者不看源代码。阅读实际上是解决大多数问题的第一步。第一步通常是通过手头可能有的任何日志文件来挑选堆栈跟踪或 grep。但是，接下来它会读取源代码中可疑的部分，于是侦探工作就开始了。

阅读并不迷人。日复一日的源代码阅读实践通常是一种生存问题:仅仅够修补或拼凑代码，也许还有一些单元测试，以活到明天。

为了将阅读源代码提升到专业开发活动的水平，我提出了一个模型来更好地理解阅读源代码的行为。目标？展示如何将其应用到持续的嵌入式专业开发中。不需要阅读小组或白兰地窃听器。

## 阅读不是一项简单的活动

大多数人谈论阅读时，就好像这是一项简单而无聊的活动，就像呼吸或坐着一样。但是阅读其实是一个非常复杂的活动。甚至通读源代码的行为也需要许多不同类型的理解。当这些不同类型的理解发生时，识别它们是将阅读源从生存技能转化为使我们成为更好的开发者的关键。

阅读理解有许多分类。我发现一个有用且相对简单的方法是由 Richard R. Day 和 Jeong-suk Park 在在线学术期刊*上发表的一篇文章*。

Day 和 Park 确定了六种理解类型——字面理解、重组理解、推理理解、预测理解、评价理解和个人反应理解——我将把它们映射到阅读源代码中。我还将描述每一个层次，并建议开发人员如何利用从每种类型的阅读中获得的洞察力，从生存转向专业发展。

## 字面理解:代码行

字面理解可能是人们在谈论“阅读源代码”时最常想象的:实际的眼球扫描实际的源代码行。从字面上看，阅读就是理解 Ruby 的语法:一个类被实例化；数组的成员被传递给一个块。这种水平的阅读对于初学者学习语言是必不可少的，但它也是纠正错误的阅读模式，如拼错的变量或方法。

但是作为一种服务于正在进行的专业发展的阅读实践，即使对于非初学者来说，这也是我们遇到不熟悉的模式和 Ruby 特有的习惯用法的理解水平。我记得我第一次遇到遵循这种模式的条件赋值:

```
x = if condition
      true
    else
      false
    end
```

这个例子强调了，是的，Ruby 中的所有表达式都返回值:`x`没有被赋予`if`语句。`x`被赋值语句返回的值。但是我超越了我自己:这些是从理解的推理层面得出的观察结果，用一点点来描述。在文字层次上重要的是整个 Ruby 语句可以位于`=`的右边。

在文字理解的层面上，识别新的模式是一个巨大的职业发展机会。我为自己保留了写作老师所说的令人敬畏的源代码模式的*普通书*:个人收集的野外发现的例子(如 Seibel 的标本),作为未来编程工作的指导或灵感。

一本普通的书是对反模式书的一个有用的反击，它们有一系列不要让这种事情发生在你身上的警告和错误。专注于糟糕例子的字面理解可能会无意中重复我们最常看到的内容(例如，这可能就是为什么来自 PHP 的 Ruby 开发人员倾向于从编写看起来非常像 PHP 的 Ruby 开始)。平衡反模式或只是简单的旧的糟糕代码与闪亮的、聪明的例子是一项重要的专业实践。这对于构建 Ruby 习语库也是必不可少的。

## 重组理解:部分形成整体

代码不是文学，部分原因是它不像小说，而更像一本分成许多卷的大字典。在 Ruby 中尤其如此，它非常灵活地将模块和类分割到多个文件中，定义单例方法等等。在**重组理解**中，开发人员为源代码的组成部分——字面理解中遇到的实际源代码行——建立一个心智模型，而不管代码是如何组织的。

对于职业发展来说，重组理解是有意义重构的核心。例如，Rails 4 中的模型和控制器随着关注点的引入进行了广泛的重构，它抽象和提取了模型和/或控制器逻辑的可重用部分。

在更小的范围内，阅读中涉及到重新组织理解的专业课程可以帮助开发人员重新思考 Ruby 模块、类和方法以及包含它们的文件的组织。重组理解建立了程序的心智模型。重构的目标是将模型与程序的实际组件结合起来。

## 推理理解:填补空白

字面理解和重组理解依赖于阅读特定的代码行。然而，在**推理**层面，开发人员利用现有的知识来阅读特定的代码行。

例如，像`#each`这样的方法暗示了一个集合类的实例，比如`Array`或者一个继承了`Enumerable`类的定制类。刚接触 Rails 这样的框架的初学者常常难以推断哪些方法或类是 Rails 提供的，哪些是 Ruby 标准库的一部分。

推理理解鼓励开发人员阅读和交叉引用文档，并在书籍和博客帖子中进行其他类型的研究。推理理解，尤其是对新开发人员来说，是一个巨大的挑战。但是，就像上面关于赋值和表达式返回值的简短反思一样，它也成为一种专业发展的方法，用于衡量你在自己理解中的位置。

## 预测理解:你头脑中的解释者

如果推理涉及填充特定代码行的细节，那么**预测理解**更多的是关于一个程序可能做什么(或者，更严格地说，它可能如何失败)的整体画面。预测理解是你头脑中的 Ruby 解释器:它是重组理解的运行时间。

在理想的世界中，开发人员都应该有完美的预测理解能力。这将意味着消除所有的错误，因为这将意味着对整个代码库的完整理解，甚至是它的非预期的、错误的副作用。

但如果做不到这一点，预测性理解会在一个非常重要的领域引导专业发展:单元测试。就像阅读本身一样，开发一个测试套件可能不会成为晋升或获得全球声誉的理由。但是如果不是预测理解的结果，测试套件什么都不是。知道测试什么和程序中哪里会失败是构建有用测试的第一步。更高级的方法，比如测试驱动开发，需要一种不同的预测理解:预测一个甚至还没有写出来的程序的行为。

## 评价性理解:选择与修正

评价性理解是最复杂的阅读类型。它采取的形式是比较，例如，许多不同的宝石处理降价。但它也是组织和开源项目中正式代码评审所需的读物。

职业发展在这一点上向外转移。达到评估他人代码的水平，特别是在评论中，职业发展转向教学和指导。挑战在于更加明确地说明评估标准。反过来，这将帮助你指导和指导团队或项目中的新开发人员，同时也帮助你自己在评估自己的工作和他人的工作时变得更加一致。

## 个人回应:风格的根源

评估的一个更棘手的表亲是**个人回应**。在不太光彩的时候，这个级别是围绕编程风格问题的宗教辩论的温床。Day 和 Park 观察到“虽然没有个人反应是不正确的，但它们不可能是没有根据的。”

这成为这个层次的职业发展要点:超越风格，个人反应超越知识，走向智慧。你个人可能会反对使用三元运算符(`x = condition ? 'foo' : 'bar'`)，因为它是 C 语言遗留下来的遗物。但是能够表达你个人反应的原因，以及出现问题的具体上下文/用例，会让你更同情那些最近来到 Ruby 的 Java 或 C#开发人员，他们还不知道像`||=`这样的条件运算符以及其他通常没有三元运算符笨拙的 Ruby 特性。

## 综合理解水平

正如你可能已经注意到的，在日常工作中，没有一种理解水平是完全独立的。有时，某种程度的理解根本不存在。有多少代码库因为预测理解能力差而无意中引入了 bug(或者没有打补丁)？糟糕的预测理解有多少是糟糕的重组理解的结果，而重组理解本身可能是糟糕的组织代码库的产物？

但这最终是任何一种职业发展的挑战。无论您是参加会议还是拿起一本书来学习新的 Ruby 方法或框架，任何有意义的职业发展活动都需要超越默认的、根深蒂固的技能，并对每天编写的每一行源代码的复杂性建立深思熟虑的意识。

以阅读这样无聊而平凡的活动为例，探索其组成部分——比如阅读理解水平——可以让我们每个人以新的方式重新组合活动，并获得否则不可能获得的专业收益。

## 分享这篇文章