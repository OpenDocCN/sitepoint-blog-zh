# HTML5 的基本音频和视频事件

> 原文:[https://www . site point . com/essential-audio-and-video-events-for-html 5/](https://www.sitepoint.com/essential-audio-and-video-events-for-html5/)

`<video>`和`<audio>`元素提供了全面的事件范围。虽然有些事件非常简单，如不言自明的`"play"`事件，但其他事件可能更难理解，尤其是`"progress"`事件。

因此，让我们来研究一些最重要的媒体事件，看看它们何时、如何爆发，以及哪些属性与它们相关。我们还将尝试在当前的浏览器中导航他们行为的怪癖(好吧，你不会认为他们都是一样的，是吗？).

(为了进行参考测试，我将使用最常见浏览器的最新公开版本——Opera 12、Chrome 28、IE10、Firefox 22、Safari 5(桌面)和 Mobile Safari 6 (iOS)。因此，只要提到浏览器的名字(如 <q>Opera</q> )，它就意味着这个最新版本。)

## 回放事件

回放事件是那些为响应播放或暂停媒体而触发的事件。这些事件非常简单。

`"play"`和`"pause"`事件分别在媒体播放或暂停时触发，但还有一个`"ended"`事件会在媒体到达结尾时触发——要么是因为普通播放已经结束，要么是因为用户手动“搜索”了那么远。

存在与前两个事件相对应的媒体功能——不出所料地被称为`play()`和`pause()`。还有两个媒体属性与最后两个事件相对应——`.paused`属性默认为`true`,或者每当媒体暂停时，而`.ended`属性默认为`false`,但是当回放结束时(即在`"ended"`事件触发的同时)变为`true`。

然而，在 Opera、Safari 和 IE10 中有一个明显的异常，即当媒体已经结束时，**`.paused`标志*仍然保持* `false`(然而从逻辑上讲，它应该是`true`，因为媒体不再播放)。这样做的实际结果是，像这样的简单播放/暂停按钮处理程序在这种情况下会失败(即，按钮根本不做任何事情):**

```
button.addEventListener('click', function(e)
{
  if(media.paused)
  {
    media.play();
  }
  else
  {
    media.pause();
  }

}, false);
```

但是您可以很容易地解决这个问题，通过手动触发`pause()`方法来响应`"ended"`事件:

```
media.addEventListener('ended', function(e)
{
  media.pause();

}, false);
```

Firefox 和 Chrome 已经用完全相同的方式在内部解决了这个问题——在`"ended"`事件之前触发一个`"pause"`事件。

## 加载事件

加载事件是关于加载(或未能加载)媒体数据而触发的事件。这些事件的普遍性取决于媒体的加载状态，即是否使用了`preload`属性和/或媒体是否已经被缓存。

在所有情况下首先触发的是`"loadstart"`事件，这意味着浏览器已经开始寻找数据。但这就是它的全部含义——它*并不*意味着任何数据实际上已经加载，或者媒体资源甚至存在。

如果`preload`属性的值为`"none"`，那么`"loadstart"`事件是唯一一个在回放开始前触发的事件。然而，如果`preload`属性的值为`"metadata"`或`"auto"`，那么很快就会触发另外两个事件，它们是`"progress"`和`"loadedmetadata"`。(如果没有预加载，这些事件仍然会触发，但在回放开始之前不会触发。)

`"progress"`事件相当复杂，所以我们将在下一节中单独讨论，但是`"loadedmetadata"`事件很简单，因为它仅仅意味着浏览器已经加载了足够的元数据来知道媒体的`.duration`(作为浮点数，而不是它的默认值`NaN`)。

当然，`"loadedmetadata"`事件只有在媒体能够加载的情况下才会被触发——如果它失败了(例如，如果`src`返回一个`404`，那么媒体将会产生一个`"error"`事件，并且不可能进行进一步的回放。

这里我们再次遇到一些重要的浏览器变体。在 Mobile Safari **中，`preload`设置没有被有意实现**，因此该属性的所有值的行为都与`"none"`相同。相比之下，在 IE10 中，**媒体元数据在默认情况下*总是*被加载**，因此`"none"`的`preload`值表现得就像是`"metadata"`一样。

在`"loadedmetadata"`触发后，下一个重要事件是`"canplay"`，浏览器将触发该事件，以指示何时加载了足够的数据，从而知道回放将会工作(即<q>可以播放</q>)。如果`preload`是`"auto"`，那么`"canplay"`事件将在数据加载几秒钟后触发；如果`preload`为`"metadata"`或`"none"`，则在回放开始前不会触发。这个规则的一个例外是 Chrome，它总是在初始预加载期间触发`"canplay"`，即使它只是元数据。

还有一个名为`"canplaythrough"`的二级事件，当浏览器估计已经加载了足够的媒体数据以供回放*不被中断*时，应该触发该事件。这应该是基于对你的连接速度的估计，所以它应该在至少几秒钟的数据被预加载后才启动。

然而在实践中，**`"canplaythrough"`事件基本上是无用的**——因为 Safari 根本不触发它，而 Opera 和 Chrome 在事件之后立即触发*`"canplay"`事件，即使它还没有预加载四分之一秒！只有 Firefox 和 IE10 似乎正确地实现了这个事件。*

但是无论如何，您并不真正需要*这个事件，因为您可以监视`"progress"`事件来确定已经预加载了多少数据(如果需要，您可以自己计算下载速度):*

### 进度事件

当(且仅当)数据被下载时,`"progress"`事件持续触发。所以当`preload`被设置为`"none"`时，它根本不会触发，直到回放已经开始；当`preload`设置为`"metadata"`时，它将在最初的几秒钟内启动，然后停止，直到回放开始；当`preload`设置为`"auto"`时，它将继续启动，直到下载完整个媒体文件。

但是对于所有的`preload`设置，*一旦回放开始*，浏览器将继续下载整个媒体文件，触发连续的`"progress"`事件，直到没有剩余的内容要加载，即使视频随后暂停，这也将在后台继续。

数据本身是由一组时间范围(即离散的时间部分)表示的，在我们可以利用`"progress"`事件之前，理解这些是如何工作的是至关重要的。

当媒体首次开始加载时，它将创建一个代表初始部分的时间范围。例如，一旦加载了前 10 秒的数据，时间范围就可以表示为开始和结束时间的数组:

```
[0,10]
```

然而，创建多个时间范围是可能的(事实上非常可能)。例如，如果用户手动查找已经预加载的时间以外的时间，浏览器将放弃其当前的时间范围，并从该点开始创建一个新的时间范围(而不是像基本的 Flash 播放器那样必须加载中间的所有内容)。

假设用户向前跳两分钟，并从那里继续回放，然后再预加载 10 秒钟，我们将有*两个*范围，我们可以这样表示:

```
[
  [0,10],
  [120,130]
]
```

如果用户然后再次跳回到两个范围中间的时间，那么将创建另一个(第三个)范围:

```
[
  [0,10],
  [60,70],
  [120,130]
]
```

然后，一旦该范围的终点到达最后一个范围的起点，这些范围将被合并在一起:

```
[
  [0,10],
  [60,130]
]
```

这些例子中的数组仅仅是*的表示*，以帮助解释这个概念——它们并不是时间范围数据实际出现的方式；要获得这种格式的数据，我们必须手动编译。

媒体有一个代表时间范围的`.buffered`对象。`.buffered`对象有一个`.length`属性来表示有多少个范围，还有一对名为`start()`和`end()`的方法来检索单个范围的时间。

因此，要将缓冲的数据转换成二维数组，我们可以这样编译它:

```
var ranges = [];
for(var i = 0; i < media.buffered.length; i ++)
{
  ranges.push([
    media.buffered.start(i),
    media.buffered.end(i)
    ]);
}
```

这就是我们对`"progress"`事件所做的:

```
media.addEventListener('progress', function()
{
  var ranges = [];
  for(var i = 0; i < media.buffered.length; i ++)
  {
    ranges.push([
      media.buffered.start(i),
      media.buffered.end(i)
      ]);
  }
}, false);
```

最终，我们可以使用这些数据来创建更加用户友好的东西——比如可视化的进度条，如下面的演示所示。它只是包含`<div>`的一组定位的`<span>`(我们不能使用`<progress>`元素，因为它不支持多个范围):

*   **[媒体进度-仪表演示](http://jspro.brothercake.com/media-events/progress.html)**

对于`"progress"`事件和缓冲数据，有一些值得注意的浏览器怪癖。第一个是从开始加载时`.buffered`数据的不同——大多数浏览器创建一个单一的时间范围(如本节开始时所述)，而 **Opera 将创建*两个*范围**，第一个是预期的，第二个是正好在最后的一小段时间(大约是最后的`200ms`)。因此，如果媒体长度为两分钟，前 10 秒已加载，则范围将如下所示:

```
[
  [0,10],
  [119.8,120]
]
```

另一个警告是 **Mobile Safari 不会保留多个范围**的数据——它会丢弃除活跃范围以外的所有范围(即包含当前回放位置的范围)。这显然是有意的行为，旨在最小化媒体元素消耗的总内存量。再次使用前面的例子，用户向前跳转两分钟，得到的缓冲数据仍然只包含一个范围:

```
[
  [120,130]
]
```

这两种怪癖都值得了解，但是就开发而言，它们通常不会有太大的不同。然而，另一个更重要的怪癖是，在整个媒体文件已经被预加载的情况下浏览器的行为*。在这种情况下，大多数浏览器将触发单个`"progress"`事件，包含代表整个持续时间的单个时间范围。然而 **Opera 和 IE10 不提供这个进度数据** — Opera 触发一个单一事件，其中缓冲区没有范围(即`.buffered.length`为零)，而 IE10 根本不触发任何`"progress"`事件。*

 *在可视进度指示器的情况下，这意味着指示器保持为空，而不是被填满。不过还是很容易修复的，使用一个额外的`"loadedmetadata"`事件——因为一旦该事件在这些浏览器中触发，那么`.buffered`数据*现在就代表整个媒体持续时间。*

## 定时事件

我们最后要简单看一下的是媒体`"timeupdate"`事件，它在媒体播放时不断触发。您可以使用该事件来同步媒体播放的其他内容，例如创建手动字幕，突出显示脚本中的活动行，甚至同步多个媒体源——这是我在以前的一篇文章中看到的内容:**[html 5 视频的可访问音频描述](https://www.sitepoint.com/accessible-audio-descriptions-for-html5-video/)** 。

事件触发的频率没有规定，实际上在不同的浏览器中会有很大的不同。但是总的来说，平均每秒 3-5 次，对于大多数同步目的来说已经足够精确了。

据我所知，这个事件没有浏览器错误或怪癖。做了一个很好的改变，嘿！

## 编后记

本文没有包括所有可能的媒体事件，还有其他回放和搜索事件、高级网络状态事件，甚至还有一个在音量改变时触发的事件。但是我已经讨论了我认为最重要的内容——对于您可能想对视频和音频进行的大多数简单脚本编写来说足够了，对于构建一个基本的定制界面来说也足够了。

这是最后一个参考演示，可以帮助您了解这些媒体活动。它为我们讨论过的回放和进度事件创建一个动态日志，显示每个事件的计时和相关属性数据:

*   **[媒体事件演示](http://jspro.brothercake.com/media-events/events.html)**

## 分享这篇文章*