# 使用 ColdFusion 8 轻松实现丰富的互联网应用

> 原文:[https://www.sitepoint.com/applications-coldfusion-8/](https://www.sitepoint.com/applications-coldfusion-8/)

Rich Internet Application (RIA)这个术语是 Macromedia(现在的 Adobe)在 2002 年创造的。RIA 是一个 web 应用程序——它运行在 web 浏览器中，但是看起来和感觉上更像一个桌面应用程序。Gartner 分析师 Mark Driver、Ray Valdes 和 Gene Phifer 将 RIAs 描述为“Web 的下一次发展”。

RIA 区别于传统 web 应用程序的一些特性是:

*   更丰富的用户体验
*   跨浏览器一致性
*   无需刷新页面即可加载数据的能力

可以使用几种不同的技术来创建 RIA，包括 Adobe Flash、Adobe Flex 和 Ajax。借助 ColdFusion 8，Adobe 为开发人员提供了新的工具来快速轻松地创建 RIA，这些 RIA 要么基于 Flash 平台，要么使用普通的旧 HTML 并依赖于 Ajax。本文将关注新的 Ajax 系列标签和函数；我将逐步指导您使用 Adobe ColdFusion 8 构建您的第一个 RIA(一个简单的用户管理器应用程序)。

##### 要求

如果你想在家独自玩，这里是你需要的:

*   ColdFusion 8 ( [试用](http://www.adobe.com/go/devcenter_cf_try)或[购买](http://www.adobe.com/go/devcenter_cf_buy)
*   [本文的代码档案](https://www.sitepoint.com/examples/ria/ria_demo.zip) (zip，72Kb)

要在家里继续学习，下载代码档案并将其解压缩到本地开发环境的 web 根目录下(文件存在于 RIA 文件夹中)。

##### 入门指南

在开始之前，我们需要设置一个 ColdFusion 数据源。我们的应用程序将利用 ColdFusion 8 的另一个特性 Apache Derby 数据库。Apache Derby 是一个 Java 关系数据库管理系统，可以嵌入到应用程序中。通过将 Derby 用于我们的数据库，我们最小化了安装任何额外软件的需求，从而确保了跨多个操作系统的兼容性。

我们的第一步是建立一个数据源，ColdFusion 将使用该数据源从数据库中读取和检索信息。下面是我们设置数据源的方法:

1.  登录 ColdFusion 管理员。

3.  导航到**数据&服务**并点击**数据源**。

5.  在页面顶部的表单中，在标记为**数据源名称**的字段中输入文本“RIA”(不带引号)。

7.  在标签为**驱动**的字段中，选择 **Apache Derby 嵌入式**。

9.  点击**添加**按钮。

11.  在下一个屏幕上，您将被要求输入数据库文件夹的绝对路径。将您的路径设置为:`{path to web root}/RIA/database/RIA`。

13.  添加简短描述(这一步是可选的)。

15.  最后，点击**提交**按钮创建数据源。

##### 查看演示应用程序

我们现在准备好测试我们的演示应用程序了。将您的 web 浏览器指向`http://{web root}/RIA`，您应该会看到一个类似于图 1 的页面。

![Figure 1: A grid, automatically generated by ColdFusion, displays a list of users](../Images/24191d265d2d7dda284567e628519f52.png)

您会注意到我们的网格格式很好——它为数据行显示交替的颜色(称为斑马条纹),分页控件，甚至允许列排序(您可以通过单击想要排序的列的标题来测试这一点)。

要启动 user detail 窗口，单击 New User 按钮，或者双击网格中的任何一行——将会启动一个用户信息对话框，如图 2 所示。

![Figure 2\. A User Information window launches from the data grid](../Images/e87695ab14a30e027954b9db91175c02.png)

您会注意到表单出现在模式窗口中，该窗口阻止用户与底层页面进行交互。输入或更改一些用户数据，然后单击**保存用户** —这样做将关闭窗口，数据网格将更新以反映您的更改。

让我们把创建这个页面的代码分成几个小块。我们将从显示网格的代码开始，它位于文件`index.cfm`中。

##### 用`<cfgrid>`显示网格

通常，显示包含可排序列和分页的网格或表格需要大量代码(即使是其他框架)。但是使用 ColdFusion 8，就像使用以下 ColdFusion 标签一样简单:

```
 <cfgrid  

name="userGrid"  

  format="html"  

  pagesize="5" 

preservePageOnSort="true"            bind="cfc:com.user.UserService.getAllUsers( {cfgridpage}, {cfgridpagesize}, {cfgridsortcolumn}, {cfgridsortdirection})" 

sort="true" 

stripeRows="true"> 

  <cfgridcolumn name="USERID" header="ID" display="false" /> 

  <cfgridcolumn name="FIRSTNAME" header="First Name" width="200" /> 

  <cfgridcolumn name="LASTNAME" header="Last Name" width="300" /> 

  <cfgridcolumn name="EMAILADDRESS" header="Email" width="220" /> 

  <cfgridcolumn name="PHONE" header="Phone" /> 

</cfgrid>
```

这就是我们需要做的！没有 JavaScript——甚至没有 HTML。我们只需要几行 ColdFusion 代码。让我们看看`cfgrid`标签中的每个属性代表什么。

*   `name`–该属性指定网格的名称。这也是在 JavaScript 中引用网格的方式。
*   `format`–该属性决定 ColdFusion 构建网格时应使用的格式。要创建一个 AJAX 网格，正如我们在上面的例子中所做的，指定“HTML”。
*   `pageSize`–该属性定义每页显示的项目数。
*   `bind`–该属性告诉 ColdFusion 从何处检索填充网格的数据。在上面的例子中，我们告诉 ColdFusion 使用名为`com/user/`目录中名为`UserService`的 ColdFusion 组件(CFC)中名为`getAllUsers`的方法。请注意，当我们在 ColdFusion 中调用 CFC 时，我们使用点符号来指定 CFC 的路径。还要注意，我们正在向`getAllUsers`方法传递一些参数，即`{cfgridpage}`、`{cfgridpagesize}`、`{cfgridsortcolumn}`和`{cfgridsortdirection}`。这些变量描述了网格的当前状态，以及我们需要如何检索信息来对网格进行排序或分页。
*   `sort`–该属性告诉 ColdFusion 列是可排序的。
*   `preservePageOnSort`–该属性控制当用户对数据进行排序时，是否应该重新绘制当前页面(例如，当用户正在查看第 2 页，并且他们重新排序数据时，显示新数据集的第 2 页)。如果不设置该值，每当网格被排序时，网格将被重置为第 1 页。
*   `stripeRows`–该属性告诉 ColdFusion 改变行颜色。

还有许多其他属性可以用来决定网格的外观和行为。要了解更多信息，请查看关于`cfgrid`元素的 LiveDocs。

下一组标签`<cfgridcolumn>`，为 ColdFusion 提供了关于我们希望显示的列的信息。

*   `name`–该属性包含将用于填充该列的元素(查询列)的名称作为值。
*   `header`–该属性是显示在列标题中的文本。
*   `width`–该属性指定列的宽度。

***注意:`userID`没有显示***
*您可能会注意到我们的数据源检索了一个`userId`列，但是用属性`display="false"`隐藏了它。`userId`的值用于在我们的数据库中唯一地标识这个用户——我们需要这个值用于一个选定的行，以便我们可以在用户信息窗口中检索和显示所有用户的信息。*

可以设置许多其他属性来决定网格列的外观和行为。有关更多信息，请查看`<cfgridcolumn>`的 LiveDocs 帮助。

现在让我们看看在我们的`<cfgrid>`的 bind 属性中引用的 CFC。这里有几种方法可以用来检索和保存单个用户。还有一种方法检索我们所有的用户，以便填充`<cfgrid>`，接下来我们将剖析的就是这段代码。

##### 使用`queryConvertForGrid`检索所有用户

下面是我们的`queryConvertForGrid`方法的代码:

```
<cffunction name="getAllUsers" output="false" access="remote" returntype="struct">  

<cfargument name="cfgridpage">  

<cfargument name="cfgridpageSize">  

<cfargument name="cfgridsortcolumn"  />  

<cfargument name="cfgridsortdirection"  />  

<cfset var qRead="">  

<cfquery name="qRead" datasource="ria">  

SELECT userId,firstName,lastName,emailAddress,phone  

FROM  users  

<cfif len(arguments.cfgridsortcolumn) and len(arguments.cfgridsortdirection)>  

ORDER BY #arguments.cfgridsortcolumn# #arguments.cfgridsortdirection#  

<cfelse>  

ORDER BY lastName ASC  

</cfif>  

</cfquery>  

<cfreturn queryConvertForGrid(qRead, cfgridpage, cfgridpageSize) />  

</cffunction>
```

这是一个非常基本的函数，接受四个参数:

*   `cfgridpage`
*   `cfgridpagesize`
*   `cfgridsortcolumn`
*   `cfgridsortdirection`

这些参数与我们在`<cfgrid>`的`bind`属性中指定的参数相匹配。

关于`<cffunction>`标签值得注意的一点是访问属性。任何时候使用 Ajax 从 CFC 中检索数据，您调用的函数必须将`access`属性设置为`"remote"`。

该函数对数据库中的 users 表运行一个非常简单的查询，并使用参数`cfgridsortcolumn`和`cfgridsortdirection`对结果进行相应的排序。如果这两个值都是空字符串，则结果按姓氏排序。

最后，我们使用`<cfreturn>`返回从`queryConvertForGrid`函数返回的值。`queryConvertForGrid`是一个本地 ColdFusion 函数，其存在的唯一目的是获取查询结果，并以一种可以用来自动填充`<cfgrid>`的方式对它们进行格式化。该函数有三个参数:

*   查询结果
*   请求的页码
*   页面大小

它返回一个 ColdFusion 结构，该结构的格式使得`<cfgrid>`可以很容易地解释和显示数据。

##### 向网格中添加侦听器

现在我们将探索打开细节窗口的任务。在我们深入研究细节之前，让我们看一下`index.cfm`中的这两行代码:

```
<cfset ajaxOnLoad("initGrid") />  

<cfajaximport tags="cfform" />
```

第一行只是告诉 ColdFusion，第一次进行 Ajax 调用时，它应该运行`initGrid` JavaScript 函数。第二行告诉 ColdFusion，我们将使用的 ColdFusion 元素将要求我们在主页中加载一些库。

JavaScript 函数只是在网格中添加了一个监听器。有了这个监听器，当双击一行时，就会调用`showUser` JavaScript 函数。`initGrid`的代码看起来像这样:

```
function initGrid(){  

  var grid = ColdFusion.Grid.getGridObject("userGrid");  

  grid.on("rowdblclick", showUserForm);  

  }

The first line in the initGrid method provides us with an instance of the grid named userGrid, which is the value we specified in the name attribute of the <cfgrid>.

第二行设置了`rowdblclick`事件的监听器，并指定当该事件发生时应该调用`showUserForm`函数。ColdFusion 实际上使用 Ext JS JavaScript 库来创建网格，因此`rowdblclick`是网格对象固有的事件。关于 Ext JS grid 对象的更多信息可以在 Ext JS 站点上找到。

现在我们已经告诉网格在双击一行时运行`showUserForm`，让我们看看显示细节窗口的代码。

显示详细信息窗口

首先，这里是组成`showUserForm`方法的代码:

```

```
function showUserForm(){  

    var userId = ColdFusion.getElementValue("userGrid", "userGridForm", "userId");  

    var url = "userForm.cfm?UserId="+userId ;  

    ColdFusion.navigate(url, "userWin");      

    ColdFusion.Window.show("userWin");  

  }
```

上面方法中的第一行检索所选行的`userId`。`ColdFusion.getElementValue`接受三个参数:

*   我们要查看的控件的名称
*   项目所属的表单的名称
*   我们正在寻找的属性

在这种情况下，我们告诉 ColdFusion 从`userGridForm`表单中的`userGrid`控件中检索`userId`属性。

然后我们设置一个名为`url`的变量，它将存储我们将用户带到的 URL。我们将`userId`作为参数添加到 URL 中。这个 URL 用于下一行，它向 URL 发出 http 请求，并在名为`userWin`的`<cfwindow>`元素中显示结果。您可以使用`ColdFusion.navigate`方法来填充页面上的任何 HTML 元素，比如`div`。最后一行将显示`<cfwindow>`。

接下来是使用`<cfwindow>`标签创建基于 JavaScript 的弹出窗口的代码:

```
<cfwindow name="userWin" title="User Information" initShow="false" modal="true" center="true"></cfwindow>
```

很简单，是吧？让我们看看这些属性分别代表什么:

*   `title`–该属性指定将出现在窗口顶部的文本。
*   `initShow`–该属性可用于控制窗口最初是否可见。
*   `modal`–该属性指定弹出窗口是否是模态的。记住，模式窗口阻止用户与底层页面交互。
*   `center`–如果该属性设置为`true`，弹出窗口将位于屏幕中央。

还有许多其他属性可以用来决定网格的外观和行为。有关更多信息，请查看`<cfwindow>`的 LiveDocs。

我们应用程序的下一部分是表单。

##### 创建表单

下面是我们创建用户表单的代码:

```
<cfparam name="url.userId" default="" />   

<cfset user = createObject("component","com.user.UserService").getUser(url.userid) />   

<cfform name="userForm">   

  <cfinput type="hidden" name="userId"  value="#url.userId#" />   

  <div class="formElement">   

  <label for="firstName">First Name</label>   

  <cfinput id="firstName" name="firstName"  value="#user.firstName#" />   

  <div id="firstNameError" class="error"></div>   

  </div>   

  <div class="formElement">   

  <label for="lastName">Last Name</label>   

  <cfinput id="lastName" name="lastName" value="#user.lastName#" />   

  <div id="lastNameError" class="error"></div>   

  </div>   

  <div class="formElement">   

  <label for="emailAddress">Email Address</label>   

  <cfinput id="emailAddress" name="emailAddress" value="#user.emailAddress#"  />   

  <div id="emailAddressError" class="error"></div>   

  </div>   

  <div class="formElement">   

  <label for="phone">Phone</label>   

  <cfinput id="phone" name="phone"  value="#user.phone#"  />   

  <div id="phoneError" class="error"></div>   

  </div>   

  <div><cfinput name="submit" type="button" value="Save User" onclick="submitForm()"><cfinput type="button" name="cancel" value="Cancel" onclick="ColdFusion.Window.hide('userWin')"></div>   

</cfform>
```

这里没有什么非常复杂的事情。

首先，我们使用`<cfparam>`将 URL 变量初始化为一个空字符串。在接下来的代码行中，我们创建了一个`UserService`对象的实例，并调用了`getUser`方法，传入了名为`userId`的 URL 变量。

剩下的代码只是用从数据库中检索到的信息填充表单。如果这是一个新用户，从数据库中检索的结果将包含空字符串，因此我们的表单将是空的。

另一点值得一提的是**提交**和**取消**按钮是如何操作的。**提交**按钮调用一个名为`submitForm`的 JavaScript 函数，而**取消**按钮只是调用了`ColdFusion.Window.hide("userWin")`，隐藏了`<cfwindow>`。在每个表单字段下，有一个空的`div`，带有类似于`"{formFieldName}Error"`的`id`。该 id 将用于显示验证表单时返回的任何错误消息。

关于这个页面，值得注意的最后一点是，它不包含 JavaScript。因为这个表单将存在于我们的主页中，所以我们可以在那里存储所有的 JavaScript 引用。

##### 处理表单

我们来看看`index.cfm`中的`submitForm`函数:

```
function submitForm() {   

clearErrors();   

ColdFusion.Ajax.submitForm("userForm", "userForm_submit.cfm", submitCallback, errorHandler);   

    }
```

上面的函数执行的第一个任务是调用`clearErrors`方法，这将清除以前使用的表单中可能存在的任何表单验证错误。上面的第二行代码执行 post——`ColdFusion.Ajax.submitForm`方法获取名为`userForm`的表单中所有条目的值，并将它们发送到 URL `userForm_Submit.cfm`。当服务器发回响应时，调用`submitCallback`函数，如果有任何错误，执行`errorHandler`方法。

接下来我们来看看`userForm_submit.cfm`文件。这是我们用来验证表单和保存用户详细信息的文件:

```
<cfsetting enablecfoutputonly="true" />   

<cfset errors = StructNew() />   

<cfif form.firstName EQ "">   

  <cfset errors["firstName"] = "You must enter a first name." />   

</cfif>   

<cfif form.lastName EQ "">   

  <cfset errors["lastName"] = "You must enter a last name." />   

</cfif>   

<cfif NOT isValid("email", form.emailAddress)>   

  <cfset errors["emailAddress"]= "You must enter a valid email address" />   

</cfif>   

<cfif NOT isValid("telephone",form.phone)>   

  <cfset errors["phone"] = "You must enter a valid phone number" />   

</cfif>   

<cfif structIsEmpty(errors)>   

  <cfset createObject("component","com.user.UserService").saveUser(argumentCollection = form) />   

<cfelse>   

  <cfoutput><cfoutput>#serializeJSON(errors)#</cfoutput></cfoutput>   

</cfif>   

<cfsetting enablecfoutputonly="false" />
```

在这个页面中，我们创建了一个名为 errors 的变量，它将保存与失败的验证相关的任何信息。我们在这个例子中应用的验证非常简单——它检查以确保`firstName`和`lastName`不是空字符串，并且`emailAddress`和 phone 分别包含有效的电子邮件地址和电话号码。

一旦我们的数据得到验证(假设我们的 errors 变量为空)，我们就可以安全地将其保存到数据库中。我们再次创建了一个`UserService`的实例，并调用了`save`方法，将表单范围作为`argumentCollection`传入。我们的`save`方法包含确定我们是在处理新用户(需要插入)还是现有用户(需要更新)的逻辑。

如果我们的`errors`变量不为空，就意味着我们的数据包含错误。我们需要以一种方式传递它们，这种方式将向主页表明我们遇到了问题。这最好使用 JSON (JavaScript 对象符号)来完成，幸运的是，ColdFusion 8 有一个本机函数`serializeJSON`，可以将 ColdFusion 对象序列化为 JSON 字符串。

通过将对该函数的调用包装在`<cfoutput>`标签中，我们返回了一个表示错误变量的序列化字符串。还有一个名为`deserializeJSON`的 ColdFusion 函数，它接受 JSON 字符串并返回一个类似的 ColdFusion 数据结构。

为了查看我们如何使用该页面的结果，让我们重新访问`index.cfm`并查看我们的`submitCallback`方法中的代码:

```
function submitCallback(response){   

      var errors = ColdFusion.JSON.decode(response);   

      var valid = true;   

      for(i in errors){   

    document.getElementById(i+"Error").innerHTML = errors[i];   

    valid = false;   

      }   

  if(valid){   

    ColdFusion.Window.hide("userWin");   

        ColdFusion.Grid.refresh("userGrid", true);   

  }   

    }
```

如您所见，`submitCallback`函数有一个参数，这是提交表单时从服务器返回的响应。我们的第一个任务是解码使用`ColdFusion.JSON.decode`返回的 JSON 字符串——这将把 JSON 字符串转换成 JavaScript 对象。正如您可能已经猜到的，还有一个名为`ColdFusion.JSON.encode`的函数，它接受一个 JavaScript 对象，并返回一个 JSON 字符串。

如果 errors JavaScript 对象中有任何错误，我们将遍历对象中的元素，并为表单字段设置相应的`div`的 innerHTML。(这些与调用`clearErrors`方法时清除的`div`相同。)如果返回任何错误，我们将变量`valid`设置为`false`。

如果没有返回错误，并且表单有效，我们可以愉快地用方法`ColdFusion.Window.hide("show")`关闭`<cfwindow>`。最后，我们使用`ColdFusion.Grid.refresh`刷新网格，这样所做的任何更改都会反映在网格中。

我们唯一没有涉及的是如何显示表单来创建新用户。

##### 创建新用户

我们的用户可以通过单击“新建用户”按钮来创建新用户。该按钮调用`newUser` JavaScript 函数:

```
function newUser(){   

  var url = "userForm.cfm" ;   

  ColdFusion.navigate(url, "userWin");       

  ColdFusion.Window.show("userWin");   

}
```

从上面的代码中可以看出，这个函数类似于`showUserForm`函数，只有一个例外——我们没有在 URL 中传递一个`userId`。这种方法将确保`<cfwindow>`在打开时显示一个空表单。

您可能已经注意到了我们代码中 JavaScript 的最小量；如果你看看源代码，你会看到更多。无论何时使用任何 ColdFusion Ajax 组件，ColdFusion 都会自动获取组件运行所需的 JavaScript。

##### 摘要

这个例子似乎涉及了很多东西，但是考虑到我们已经完成的工作——一个跨浏览器兼容的、用于查看和管理用户列表的丰富界面——实际上并没有太多东西。请记住，我们的网格包含可排序的列和分页，我们调用 Ajax 来刷新网格以及显示和处理表单。

所有这些都是用四个相对较小的 ColdFusion 文件和大约 30 行 JavaScript 代码实现的。我认为这充分说明了 ColdFusion 的能力，它可以帮助您创建 RIA，而不会陷入 JavaScript、Ajax 和浏览器兼容性问题的错综复杂之中。

这个例子仅仅触及了 ColdFusion 的 Ajax 功能的皮毛。有关使用 ColdFusion 8 创建 Ajax 应用程序的更多信息，请查看 ColdFusion 开发人员指南。

## 分享这篇文章