# C 语言第 3 部分中的运算符

> 原文：<https://www.sitepoint.com/operators-in-c-part-3/>

这篇文章是 C 第二部分中的教程[操作符的延续。它将讨论下一个一元运算符、转换运算符、乘法和加法运算符、按位移位运算符和关系运算符。](https://www.sitepoint.com/operators-in-c-part-2/ "Operators in C Part 2")

## 一元算术运算符

有四种一元算术运算符:

1.一元减号(-)

2.一元加号(+)

3.按位补码(~)

4.逻辑否定运算符(！)

### 一元减运算符

一元减号运算符位于数值常量、变量或表达式之前，并对其值求反。它不同于减法运算符(-)需要两个独立的操作数。

一元减运算符的操作数必须属于**算术数据类型域**。算术类型域由整数数据类型和浮点数据类型组成。**整数数据类型**由`char`、`signed` 、`unsigned integer types` 和`enumerated types`组成。**浮点类型**是`float and double`类型。这些算术类型都属于一个类型域—实数类型(存储实数的值)或复数类型(存储复数的值)。

### 一元加运算符

一元加号运算符也位于数值常量、变量或表达式之前。一元(+)运算符的结果是其操作数的值。一元(+)运算符的操作数也应该属于算术类型域。

### 按位补码运算符

按位补码运算符(~)使位反转；即 1 变成 0，0 变成 1。操作数必须是整数类型数量(字符、有符号和无符号整数类型以及枚举类型)。

### 逻辑否定运算符

逻辑否定运算符(！)对逻辑表达式的值求反；也就是说，它会导致原本为真的表达式变成假的，反之亦然。逻辑非运算符的结果类型为`int`。**的结果！**如果作为逻辑表达式的操作数的值不等于 0，则为 0，如果操作数的值等于 0，则结果为 1。

逻辑否定运算符的操作数必须属于标量类型。**标量类型域**由算术类型(整数和浮点类型)和指针类型组成。

例如:假设 I 和 f 是整数变量，其中`i=7`和`f=5`，那么当逻辑求反运算符应用于逻辑表达式`(i>f)`时，其为真；ie！(i > f)计算结果为 0(假)。

## sizeof 和 alignof 运算符

**sizeof** 运算符产生其操作数占用的内存，以字节为单位。操作数可以是表达式或数据类型名称。

语法: `sizeof(operand);`

数据类型可以是整数类型、指针类型，甚至是结构或联合类型。当 sizeof 应用于类型为`char`、`signed char`或`unsigned char`的操作数时，结果为 1。如果将其应用于数组，则结果是数组元素所需的总字节数。如果将其应用于结构/联合，则结果是该结构/联合的每个成员所需的字节数之和。结果的值是实现定义的，其类型(无符号整数类型)是在`stddef.h `(和其他头文件)中定义的`size_t`。

运算符的**对齐产生其操作数类型所需的对齐。**对齐**是实现定义的整数值，表示给定对象可以被分配的连续地址之间的字节数。对象的数据类型对该类型的每个对象都有对齐要求。可以使用 `_Alignas`关键字请求更严格的对齐。**

**基本校准**小于或等于器械(目标机器/平台)支持的最大校准，等于 `alignof(max_align_t)`。

一个**延伸对准**大于`alignof(max_align_t)`。是否支持扩展对齐由实现定义。

对齐被表示为类型`size_t`的值。有效的对齐只包括那些由基本类型的`alignof`表达式返回的值，加上一组额外的实现定义的值，这些值可以是空的。每个有效校准值应为 2 的整数次幂。

sizeof 和 alignof 运算符不能应用于具有函数类型或不完整数据类型(如 void 类型或可变长度数组)的表达式、此类类型的括号名称或指定位字段成员的表达式。

## 演职人员

如果需要，表达式的值可以转换为不同的数据类型。为此，表达式前面必须加上所需数据类型的名称，用括号括起来，即:

`(data type) expression`

这种结构被称为**铸件**。

举例:假设 `i`是一个值为 7 的整型变量，`f`是一个值为 8.5 的浮点型变量。表达式 `(i+f)%4`无效，因为第一个操作数是浮点，而`%`运算符仅适用于整数操作数。然而，` ((int) (i+f))%4 `表达式强制第一个操作数为整数，因此是有效的。因此，这个表达式的输出是 3，因为%运算符给出了整数除法之后的余数。请注意，显式类型规范仅适用于第一个操作数，而不适用于整个表达式。

与表达式本身相关联的数据类型不会因强制转换而改变。相反，无论强制转换出现在哪里，都是表达式的*值进行类型转换。当表达式只包含一个变量时，这一点尤其重要。*

## 乘法运算符

有三种乘法运算符:

### 乘法运算符(*)

*运算符给出两个操作数的乘积。操作数必须是算术数据类型。

### 除法运算符(/)

/运算符将第一个操作数除以第二个操作数，得出商。两个操作数必须是算术类型，第二个操作数必须非零。

### 模数运算符(%)

%运算符产生除法运算后的余数。%运算符的操作数必须是整数，第二个操作数必须是非零的。

## 加法运算符

C #中有两个加法运算符:

### 加法运算符(+)

+运算符执行二进制加法，并产生两个操作数的和。+运算符的两个操作数都应该是算术类型，否则一个操作数应该是指针类型，另一个应该是整数类型。

### 减法运算符(-)

–运算符从第一个操作数中减去第二个操作数，并给出差值。对于减法，操作数的数据类型必须满足以下组合之一:

1.两个操作数都应该是算术类型。
2。两个操作数都应该是指向完整对象类型的指针。
3。左操作数应该是指向完整对象类型的指针，右操作数应该是整数类型。

当我们在后面的文章中讨论指针时，我们将讨论指针上的操作。

## 按位移位运算符

这两个按位运算符分别是**左移(< < )** 和**右移(> > )** 。每个运算符需要两个操作数。第一个是整数类型操作数，表示要移位的位模式。第二个是无符号整数，指示位移的数量(即，第一个操作数中的位是否将被移位 1 位位置、2 位位置、3 位位置等)。该值不能超过与第一个操作数的字长相关的位数。

*左移运算符*使第一个操作数中的所有位左移第二个操作数指定的位数。原始位模式中最左边的*位*(即溢出位)将会丢失。空出来的最右边的位位置将用 0 填充。

举例:假设` a`是一个无符号整数变量，其值为`0110 1101 1011 0111`。该表达式

`b = a<<6`

将把` a`的所有位左移六位，并将结果位模式赋给无符号整数变量 `b`。因此，`b`的结果值将是`0110 1101 1100 0000`。最初分配给`a`的所有位都向左移动六位。最左边的 6 位，即`0110 11,`丢失，最右边的 6 位用 0 填充。

*右移运算符*使第一个操作数中的所有位向右移动第二个操作数指示的位数。原始位模式中最右边的*位*(即下溢位)将会丢失。如果被移位的位模式表示无符号整数，则最左边的空位将用 0 填充。

举例:假设`a`是一个无符号整数变量，其值为`0110 1101 1011 0111`。该表达式

`b= a>>6`

将把`a`的所有位右移六位，并将结果位模式赋给无符号整数变量`b`。因此， `b`的结果值将是`0000 0001 1011 0110`。a 最右边的 6 位，即 `11 0111,`丢失。最左边的 6 位用 0 填充。

## 关系运算符

C 语言中有四种关系运算符:

1.小于(

2.大于(>)

3.小于或等于(< =)

4.大于或等于(> =)

关系运算符用于形成逻辑表达式，表示或真或假的条件。得到的表达式将是整数类型，因为*真*由整数值 1 表示，而*假*由 0 表示。

在使用关系运算符的逻辑表达式中，要么两个操作数都是实数据类型，要么都是指针类型。

当比较两个指针时，结果取决于所指向的对象在地址空间中的相对位置。如果两个指针指向同一个对象，或者都指向同一个数组的最后一个元素，那么它们的比较结果是相等的。如果指向的对象是同一结构/联合的成员，则指向后来声明的结构成员的指针比指向结构中早先声明的成员的指针的比较大，指向具有较大下标值的数组元素的指针比指向同一数组中具有较小下标值的元素的指针的比较大。指向同一联合对象成员的所有指针比较起来都是相等的。

举例:假设`i`和 `j`是整数变量，其中`i=3`和`j=5`。然后逻辑表达式`i>j`将计算为假，即 0，表达式`(i+5)>=j`将计算为真，即 1。

关于 C 的下一篇文章将继续讨论其余的操作符:相等操作符、按位 AND、按位 OR、逻辑 AND、逻辑 OR、条件操作符、赋值操作符和逗号操作符。

## 分享这篇文章