# 高级 PHPUnit 测试:注释和模仿

> 原文：<https://www.sitepoint.com/advanced-phpunit-testing-annotations-and-mocking/>

在本系列的前两部分([用 PHPUnit 进行 PHP 单元测试简介](https://www.sitepoint.com/tutorial-introduction-to-unit-testing-in-php-with-phpunit/)和[了解 PHPUnit 的断言](https://www.sitepoint.com/be-more-asssertive-getting-to-know-phpunits-assertions/))中，我已经向您介绍了测试应用程序的一些步骤。我向您展示了如何在 PHPUnit 的帮助下，根据您的需要编写简单或复杂的测试来确保质量。

到目前为止，我希望您理解拥有一套好的单元测试的重要性。您知道，有了这些，您可以随意更改应用程序的大部分内容，并确保结果 100%匹配。在本系列的第三部分中，我将探索两个更高级的特性，因此它们可能不会出现在您的日常单元测试实践中。

PHPUnit 有许多高级特性，当特殊情况出现时，这些特性会非常有用。这包括扩展框架本身，制作测试套件，构建静态数据集，也是本文的重点:**注解**和**嘲讽**。如果你不确定这些是什么，不要担心；我是来帮忙的。我相信到最后，您会看到这两个特性对您和您的测试是如何有用的。

## 释文

如果你读过一本书或做过笔记，你会对注释的概念很熟悉。从最严格的意义上来说，甚至您在测试中添加的注释也可以被认为是注释。例如:

```
<?php

class MyTestClass extends PHPUnit_Framework_TestCase

{

/**

* Testing the answer to “do you love unit tests?”

*/

public function testDoYouLoveUnitTests()

{

$love = true;

$this->assertTrue($love);

}

}

?>
```

在上面的例子中，您可以看到函数定义上方的简单注释块。如果你接触 PHP 有一段时间了，你肯定见过各种各样的注释风格。这个例子是一些流行的 ide 在插入注释时使用的“最佳实践”。

这没有什么神奇的，如果你真的想要，一个普通的`/* */`或`//`就可以了。当 PHPUnit 出现时，问题就来了。使用我们示例中的注释样式，可以让 PHPUnit 自动为您执行一些有趣的操作。

PHPUnit 有一组**注释**您可以在实际测试和测试生成中使用——没错，它可以为您做一些困难的工作。

PHP 没有直接解析注释的方法，所以 PHPUnit 有自己的工具来寻找匹配的短语和字符。我们将从一个更方便的特性开始——帮助测试生成的注释。让我们从一个做一些基本数学的示例类开始:

```
<?php

class MyMathClass

{

/**

* Add two given values together and return sum

*/

public function addValues($a,$b)

{

return $a+$b;

}

}

?>
```

很简单，对吧？我将它保持在一个基本的单一方法类中，因为我希望你能确保捕捉到所有正在发生的事情。

有了这个基础类，我们希望确保物理定律和数论永远不会改变。所以我们想写一个测试。当然，我们可以编写一些代码并快速完成测试，但是当我们可以偷懒并让 PHPUnit 为我们做时，为什么要这样做呢？

感谢**骨架生成器**，我们可以将它指向班级，它会尽最大努力对我们进行测试。

因为它只是普通 PHPUnit 功能的一部分，我们只是调用了`phpunit`，但是使用了一个特殊的标志。让我们将上面的简单类保存在名为`MyMathClass.php`的本地目录文件中。要使用骨架生成器，只需将它指向类文件:

```
./phpunit –skeleton-test MyMathClass
```

另一边将会显示一个测试文件——mymathclasstest . PHP——包含:

```
<?php

require_once '/path/to/MyMathClass.php';

/**

* Test class for MyMathClass.

* Generated by PHPUnit on 2011-02-07 at 12:22:07.

*/

class MyMathClassTest extends PHPUnit_Framework_TestCase

{

/**

* @var MyMathClass

*/

protected $object;

/**

* Sets up the fixture, for example, opens a network connection.

* This method is called before a test is executed.

*/

protected function setUp()

{

$this->object = new MyMathClass;

}

/**

* Tears down the fixture, for example, closes a network connection.

* This method is called after a test is executed.

*/

protected function tearDown()

{

}

/**

* @todo Implement testAddValues().

*/

public function testAddValues()

{

// Remove the following lines when you implement this test.

$this->markTestIncomplete(

'This test has not been implemented yet.'

);

}

}

?>
```

如您所见，它生成了许多您可能需要的基本方法和属性。

然而，它也有一些局限性。生成器看到你在里面有一个自定义方法(`addValues`)，但是它不知道它是做什么的。当然，我们的测试非常简单，它可能能够解析它并弄清楚它，但是您的应用程序中的其他一些非常复杂的方法呢？

我知道我不希望一个自动化工具试图猜测功能，并在此过程中意外删除我的整个数据库。不，PHPUnit 比这更聪明，走的是容易的路:它让你定义它，并标记它不完整。

对于一个大的类，这可以节省您键入每个方法和一般测试和类相关细节的大量时间。不过，在注释功能内部，有一个隐藏的亮点可以让这一切变得更加容易。

借助于`@assert`注释，您可以告诉 PHPUnit 一些关于方法内部的内容。让我们再来看看我们的`addValues`方法:

```
<?php

class MyMathClass

{

/**

* Add two given values together and return sum

* @assert (1,2) == 3

*/

public function addValues($a,$b)

{

return $a+$b;

}

}

?>
```

如果我们再次运行我们的`phpunit –skeleton-test`命令，您会注意到它为测试创建的文件有所不同。看看最后一种方法:

```
<?php

/**

* Generated from @assert (1,2) == 3.

*/

public function testAddValues()

{

$this->assertEquals(

3,

$this->object->addValues(1,2)

);

}

?>
```

突然间，PHPUnit 拥有了 X 射线视觉，可以看到你的方法内部！嗯，算是吧。

显然，它可以生成这样的测试，因为我们告诉了它测试应该做什么。您可以对大多数逻辑类型的求值使用`@assert`注释:等于、大于、相同、小于或等于等等。

您甚至可以将它们堆叠起来，在您的测试中拥有多个断言。不过，它仅限于值和常量——您不能用它在生成的测试中神奇地创建对象。

另一个方便的注释是`@dataProvider`，这是一种将一组标准数据推入测试的简单方法，这样您就可以始终知道自己在做什么。

清澈如泥？我给你举个例子。

我们将用只依赖输入的方法来测试应用程序的功能。也就是说，没有外部 XML 文件或数据库可以从中提取样本数据。相反，我们需要一种方法来定义所有测试都可以使用的数据集。

一种选择是用一些样本数据定义一个测试属性，每次都使用它，但是`@dataProvider`注释使它更加简单。

让我们在`MyMathClass`类中继续使用简单的 addValues 方法。不过，这一次，我们将引入一个新项目—一个简单的数据集，取代我们的硬编码值:

```
<?php

/**

* Data provider for test methods below

*/

public static function provider()

{

return array(

array(1,2,3),

array(4,2,6),

array(1,5,7)

);

}

/**

* Testing addValues returns sum of two values

* @dataProvider provider

*/

public function testAddValues($a,$b,$sum)

{

$this->assertEquals(

$sum,

$this->object->addValues($a,$b)

);

}

?>
```

我们测试的主要补充是`provider`方法。再加上`@dataProvider`注释，会有一些有趣的事情发生。

对于 provider 返回的数组中的每个值，将执行测试方法。这让您可以很容易地针对一个测试检查多组数据。这些值被返回到`testAddValues`方法中它们对应的参数中:数组索引`0`到`$a`，数组索引`1`到`$b`，等等。

我的返回数组中的前两组数据会很好地通过，但似乎我有时在加法上有问题，并且我的最后一组数据是错误的:1 + 5 不等于 7。这表明数据并不总是必须通过测试。

有时，在提供程序中包含“坏”数据更有意义。当您知道它应该正确响应的数据时，这在测试驱动的开发中可能是有用的，但是还没有对它的支持。

这只是您可以在测试中使用的两个方便的注释。有相当多的其他人(你可以在 [PHPUnit 手册](http://www.phpunit.de/manual/current/en/appendixes.annotations.html)中找到他们)做了一些非常酷的事情:

*   `@expectedException`注释监视将要抛出的异常。如果不是，测试就失败了。
*   对于那些担心代码覆盖率并试图确保每一位代码都被表示出来的人来说,`@covers`注释可能是有用的——即使一个测试有效地覆盖了三种不同的方法。
*   如果您要求方法所依赖的测试已经通过，您也可以使用`@depends`来定义测试之间的关系。如果没有，下面的测试将被跳过。

## 嘲弄的

从这里，我们转移到第二个更高级的话题:**嘲讽**。

此功能也称为存根或测试双打。这个比注释稍微复杂一点，所以需要更多的解释。

和以前一样，我们将设置一个简单的场景来感受一下嘲讽所提供的功能。不过，首先，我要解释一下什么是嘲讽。对于那些不熟悉这个术语的人来说，它来自于“模拟”一个项目的测试或样本版本的实践。

使用 PHPUnit 的模仿功能，您可以创建看起来像完整对象的东西，但是当您执行特定操作时，它只会产生一个结果。

如果我们只看一个示例类并进行测试，会更有意义。对于我们的例子，我们将使用数据库连接。

通常，数据库是无忧无虑的，查询在一秒钟内返回。不过，有一个查询占用了太多的资源，不值得每次都运行。它因使脚本运行时间过长而臭名昭著，并且会延迟单元测试的执行(可能导致部署延迟)。

幸运的是，mock 可以解决这个问题，并为该方法设置一个“模拟对象”。课堂是这样的:

```
<?php

class Database

{

/**

* This query always takes a really long time

*/

public function reallyLongTime()

{

// database query would return into $results

$results = array(

array(1,'test','foo value')

);

sleep(100);

return $results;

}

}

?>
```

很简单，真的——这是一个基本的类，用来定义运行查询的方法，这可能需要一段时间。

为了举例，我将其缩写为 return 语句。看到我扔在那里的那个电话了吗？这使得我们可以更容易地分辨出我们使用的是模拟对象而不是真实对象。它模拟执行中的延迟。现在，到了有趣的部分——测试。

我将在代码后解释各个部分:

```
<?php

require_once '/path/to/Database.php';

class DatabaseTest extends PHPUnit_Framework_TestCase

{

private $db = null;

public function setUp()

{

$this->db = new Database();

}

public function tearDown()

{

unset($this->db);

}

/**

* Test that the "really long query" always returns values

*/

public function testReallyLongReturn()

{

$mock = $this->getMock('Database');

$result = array(

array(1,'foo','bar test')

);

$mock->expects($this->any())

->method('reallyLongTime')

->will($this->returnValue($result));

$return = $mock->reallyLongTime();

$this->assertGreaterThan(0,count($return));

}

}

?>
```

这里有几个新的电话。最容易发现的是 PHPUnit 测试用例对象包含的`getMock`方法。该方法调用创建所讨论对象的伪版本。在本例中，它创建了一个我们可以在测试中使用的模拟`Database`对象。

从技术上讲，这个对象可以像其他任何对象一样使用。你可以调用它的其他方法，让它们像平常一样返回。不过，模仿功能使得覆盖它变得更加容易。

对于我们的长时间运行的查询示例，我们正在创建一个模拟对象，并为自己的目的覆盖了`reallyLongTime`方法。这几行是真正的关键:

```
<?php

$mock->expects($this->any())

->method('reallyLongTime')

->will($this->returnValue($result));

?>
```

这三行代码告诉模拟对象，无论何时对它调用`reallyLongTime`方法，它都应该返回`$result`中的值。这绕过了超长的等待时间，您仍然能够测试并确保内容被正确返回。

然后，如果有一天你发现了索引和缓存的魔力，你想切换到实际的对象，这是小菜一碟。然后可以调用模拟对象上的`reallyLongTime`方法，并检索预定义的结果集。

嘲讽功能有很多高级的乐趣，包括使用方便的 **MockBuilder** 。它允许您进行一些基本模拟所不能进行的调用。在下面的例子中，你可以看到如何创建一个不使用类的构造函数的新的模拟对象，以及关闭任何可能正在进行的自动加载:

```
<?php

public function testReallyLongRunBuilder()

{

$stub = $this->getMockBuilder('Database')

->setMethods(array(

'reallyLongTime'

))

->disableAutoload()

->disableOriginalConstructor()

->getMock();

$result = array(array(1,'foo','bar test'));

$stub->expects($this->any())

->method('reallyLongTime')

->will($this->returnValue($result));

$this->assertGreaterThan(0,count($return));

}

?>
```

这与我们之前的例子类似，除了那两个新方法:`disableAutoload`和`disableOriginalConstructor`。谢天谢地，他们对自己的工作描述得相当清楚。

除了`returnValue`技术，还有其他几种返回类型。您可以从回调(PHP 函数或自定义函数)中返回值，在连续调用模拟对象时返回一系列结果，甚至抛出一个异常。

with 方法可以用来定义被模仿的方法可以接受什么类型的输入(也可以包括一些类型检查)。例如:

```
<?php

/**

* Testing enforcing the type to "array" like the "enforceTypes"

* method does via type hinting

*/

public function ttestReallyLongRunBuilderConstraint()

{

$stub = $this->getMock('Database',array('reallyLongTime'));

$stub->expects($this->any())

->method('reallyLongTime')

->with($this->isType('array'));

$arr = array('test');

$this->assertTrue($stub->reallyLongRun($arr));

}

?>
```

在这种情况下，测试会通过，因为我用一个数组调用`reallyLongRun`(用`isTyp` e 调用检查)。如果我用字符串在存根上调用它，PHPUnit 会抛出一个错误。

如果您发现自己需要模拟一个处理本地文件系统上的文件的类，PHPUnit 将无法为您做到；然而，他们确实推荐了可以充当中间人并模拟文件系统的 [vfsStream](http://code.google.com/p/bovigo/wiki/vfsStream) 流包装器。

## 摘要

我已经向您展示了 PHPUnit 除了正常的日常测试例程之外必须提供的两个更强大的特性。

**注释**给你更多的控制你的测试是如何运行和生成的，并且**嘲讽**给你一个强大的方法来测试代码应该如何工作，没有麻烦。

PHPUnit 手册中还隐藏着各种各样的其他酷功能，等待着人们去发现。您可以使用 **TestDox** 从您的测试中生成文档，使用 **Selenium** 集成您的测试，并为您的应用程序生成代码覆盖率数字，以准确地指出您需要测试的地方。

从那里你可以转移到像测试驱动设计(在以前的文章中提到过)这样的概念，它可以从根本上改变你写应用程序的方式。

单元测试是一个非常强大的工具，拥有像 PHPUnit 这样的软件使它成为一种轻松愉快的体验。

## 分享这篇文章