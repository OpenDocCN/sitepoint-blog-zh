# 单身有什么不好？

> 原文：<https://www.sitepoint.com/whats-so-bad-about-the-singleton/>

> 我不断遇到一些人，他们警告不要使用 Singleton，并建议像躲避瘟疫一样避免使用它。它有什么可怕的？
> ——[凯拉什·巴度](https://www.sitepoint.com/forums/showthread.php?t=530917)

这是一个很好的问题，因为全局变量确实经常被妖魔化，最近,[的单变量也遭遇了同样的命运。也许有点令人惊讶，很难找到好的论据来支持这个](http://www.picocontainer.org/singleton-antipattern.html)[常识](http://en.wikipedia.org/wiki/Argumentum_ad_populum)——谷歌搜索会出现很多困惑。

由于我自己经常采取这种立场，我发现我应该能够为它辩护是合理的，所以我将尝试给出一个解释。这在一定程度上也是对我上周的文章的跟进，在这篇文章中，我提出了一种避免全局符号的方法，而没有花太多时间在*为什么*上。

## 单身人士的剖析

关于单例的一些困惑来自于这样一个事实，即它是两个不同概念的表现，每个概念都对应用程序架构有负面影响。这使情况变得混乱，因为人们倾向于只处理这两者中的一个或另一个。

这些概念中最明显的是，单例是全局状态的一种形式。它与*全局变量*有共同之处，还有其他一些不太明显的表现形式。

Singleton 包含的另一个概念是[静态绑定](http://en.wikipedia.org/wiki/Binding_(computer_science))。这两者都与范围密切相关，而范围又与在程序的子部分之间画出清晰的界限有关。

但是我想得太多了。

## 程序状态

也许理解一个程序最简单的方法，就是用数据*和代码*来描述。这两者存在于不同的世界，有着不同的规则。当代码执行时，它操纵数据，产生某种结果。程序中的数据称为状态。**

因为程序的基本单位是函数，所以状态通常指的是与函数相关的数据。如果一个函数在运行时改变了它的上下文，或者上下文对函数的结果有任何影响，那么这个函数就是有状态的。有时候，副作用这个术语被用来描述同样的事情。给定相同的输入，如果一个函数总是产生相同的输出，那么这个函数就被称为*纯*。例如，下面是一个纯函数:

```
 function add($a, $b) {
  return $a + $b;
} 
```

在同样的术语中，一个非纯函数被称为*过程*。这就是术语*过程化编程*的来源。以下是一个过程示例:

```
 function add($a, $b) {
  echo ($a + $b);
} 
```

## 不同层次的国家

全局变量是程序状态的一种特殊类型，但不是唯一的一种。上面的例子(2)有一个副作用，没有使用全局变量——它写出了标准输出。另一种常见的状态是可变对象。例如，一个具有改变对象名称的`setName()`-方法的对象有副作用(但是副作用的范围比全局变量小)。在函数体内，即使局部变量也是有状态的。虽然这些都是国家的例子，但它们代表了不同的程度。

## 又有什么问题？

您可能已经从术语(纯= >好，副作用= >坏)中猜到了，这意味着，那个状态是坏的。

副作用的后果是双重的。一方面，它们导致了复杂性。问题是，i/o 并不明确。仅仅通过查看接口，没有办法知道调用一个函数时会发生什么。这可能是一个小问题，但随着程序的增长，它会越积越多。

另一个问题是耦合。由于状态可以在不同的功能之间共享，因此可能会在这些功能之间引入依赖关系。例如，如果类`A`和`B`都访问全局变量`G`，那么不可能改变`A`的`G`，而不改变`B`的`G`。这种依赖被称为*耦合*。

程序中过多的状态有补救方法:全局变量可以用局部变量代替。局部变量可以用函数调用代替([用查询](http://www.refactoring.com/catalog/replaceTempWithQuery.html)代替 temp)。被传递的对象可以变成不可变的——这对与多方交互的[长寿命对象来说尤其重要。](http://c2.com/cgi/wiki?GodClass)

## 静态绑定

一个程序有两种不同的存在；编译时和运行时。解释语言在这两者之间交替，而编译语言有更严格的分离。在任何情况下，程序的[符号](http://www.youtube.com/watch?v=bhp0m_WYPhk)在编译时有意义，在运行时不能改变它的意义。这种符号的例子有常量、文字、类名和静态方法(在 PHP 中，[浮动函数](http://framework.zend.com/manual/en/coding-standard.naming-conventions.html#coding-standard.naming-conventions.functions-and-methods))。另一方面，运行时符号(变量)可以改变它们的含义。

即使静态符号不能改变，它们仍然可以影响一个函数的结果，所以在非常一般的意义上，它们是状态的一种形式。避免静态符号的状态通常没有那么重要，但在某些情况下，它们可能会导致与运行时状态相同的问题。例如，静态方法调用会导致静态(编译时)耦合。单例是这种耦合的主要例子；如果 A 类使用 singleton S，那么 A 和 S 之间存在强耦合。

### 连接

耦合当然是不可避免的，在某种程度上甚至是可取的。然而，就像运行时状态一样，限制它是一个好主意。静态耦合的问题在于，它很难(甚至不可能)将一个组件与它所耦合的其他组件隔离开来重用。这通常不是一个直接的问题，但会对维护产生影响。这也使得单元测试和调试代码变得困难，因为不可能隔离程序的一部分。

## 就这样

我只是触及了这个话题的表面，但我希望这能解释为什么全球化如此令人不快。我将引用下面的话来结束我的演讲:

> 原谅我，父亲，因为我已经单身了

一如既往，欢迎评论，但请不要咬人(我的或其他人的)。

## 分享这篇文章