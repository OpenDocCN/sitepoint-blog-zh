# 用 Greasemonkey 将任何网站打造成形状

> 原文：<https://www.sitepoint.com/beat-website-greasemonkey/>

**[Greasemonkey](http://greasemonkey.mozdev.org/) 是由 [Aaron Boodman](http://youngpup.net/) 开发的 Firefox 扩展，它允许你在任何网站上运行个人 DHTML 脚本(被称为“用户脚本”)。用户脚本本质上是自动运行的小书签，但是因为它们是自动运行的，所以它们更加有用。**

你曾经使用过一个在 Firefox 中无法运行的网站吗，即使只做了一些小的改动就可以了？除了一件令人讨厌的事情之外，你真的很喜欢一个网站，你有没有为这个网站感到沮丧，或者想要定制你经常访问的网站？正如用户 CSS 允许你改变网站的显示方式一样，用户 JS 也允许你改变网站的行为方式。

本文着眼于一般的用户脚本，特别是 Greasemonkey，探索一些可能的应用程序，并讨论出现的任何问题。我们将从简单的例子到越来越复杂的例子，我假设你已经熟悉 JavaScript 和 DOM 但是除了一个以外，所有的都是工作用户脚本，所以无论您的 JavaScript 技能如何，您都可以安装和使用它们。你当然需要 Firefox 和 Greasemonkey 扩展；如果您还没有，可以从以下链接下载:

*   [获取火狐浏览器](http://www.mozilla.org/products/firefox/)
*   [得到油猴](http://greasemonkey.mozdev.org/)

您可能还想[下载本文](https://www.sitepoint.com/examples/greasemonkey/greasemonkeyscripts.zip)的代码档案——它包含了我们将在这里使用的所有脚本。

在我们开始之前，我想简单介绍一下如何为 Greasemonkey 安装和编写用户脚本；如果您已经熟悉这个扩展，您可能想直接跳到标题为使用它的部分。

##### 安装用户脚本

Greasemonkey 用户脚本是。名称约定为“scriptname.user.js”的 js 文件。您可以通过几种方式安装脚本:

*   右键单击链接并从上下文菜单中选择安装用户脚本…。
*   在 Firefox 中查看脚本，并从工具菜单中选择安装用户脚本…。

Greasemonkey 没有允许您直接编辑用户脚本源的界面，所以如果它有任何可选设置或者您想更改它，您将需要在正常安装之前下载并本地编辑脚本。

##### 编写用户脚本

一旦 DOM 准备好，Greasemonkey 用户脚本就在文档上运行，但是在 onload 事件之前。它们没有特殊的规则，但是将它们包装在匿名函数中被认为是最佳实践，因此它们不会干扰其他脚本:

```
(function() 

{ 

  ... scripting ... 

})();
```

除此之外，我对编写用户脚本有一个建议:尽可能只使用支持良好的 DOM 脚本技术。

具体来说，我尽量避免 XPath 之类的技术，这些技术没有得到广泛的支持，同样，还有像`document.body`和`innerHTML`之类的非标准属性，它们在 XHTML 模式中可能不存在(在作为 application/xhtml+xml 或等效物的页面上)。

这些指导方针可能看起来毫无意义，因为我们只为 Firefox 编写，但我们将通过这种方式提高更广泛的兼容性(Firefox 不是唯一一个可以使用用户脚本的浏览器；但我们稍后会详细讨论这一点)。

##### 元数据注释

Greasemonkey 有一个简单的注释语法，用于定义脚本应该或不应该运行的站点、脚本的名称、描述和名称空间(与 XML 一样的 URI 名称空间，其中脚本的名称必须是唯一的)。这里有一个总结:

```
// ==UserScript== 

// @name            Script name 

// @namespace       https://www.sitepoint.com/userscripts/ 

// @description     Brief description of script 

// @include         http://google.com/* 

// @exclude         http://msn.com/* 

// ==/UserScript==
```

语法非常简单明了，但是 [Greasemonkey 创作指南](http://greasemonkey.mozdev.org/authoring.html)更加详细。

##### 将它投入使用

Greasemonkey 的开发在很大程度上受到了 Adrian Holovaty 为 [All Music Guide](http://www.allmusic.com/) 提供的站点特定扩展的启发，该扩展旨在解决许多人认为的新站点设计的严重问题。开发者的目标是让编写特定于站点的扩展像编写 DHTML 一样简单。他确实做到了。

西蒙·威廉森的[用 Greasemonkey](http://simon.incutio.com/archive/2005/01/08/greasemonkey) 修复 MSDN 是第一批广泛使用 Greasemonkey 的软件之一，它展示了一个脚本，揭示了只有 IE 才能看到的信息，而米哈伊·帕帕里塔的[将持久搜索添加到 Gmail](http://persistent.info/archives/2005/03/01/gmail-searches) 是迄今为止我见过的最复杂的例子。

但是我们将深入一些简单的站点增强，介绍用户脚本的可能性和实用性。我为 Greasemonkey 脚本做了一个空白模板，你可能会觉得有用；它还包括一些简便的方法。

***定制您经常访问的网站***

*自动完成表格*

我们的第一个示例自动完成特定页面上的单个表单元素。在本例中，页面是 SitePoint 论坛主页，值是我的用户名:

从代码归档中查看或安装脚本 auto-complete.user.js。

即使论坛记得我有一个 cookie，我也可能没有，因为我经常清理我所有的 cookie。还有很多其他时候，这可以派上用场:一个 cookie 可能已经过期，或者一个网站可能有更多的基本功能，不记得人。

让我们通过添加另一个站点来扩展这个原则:Yahoo！邮件登录页面。首先，我们将@include 路径添加到注释部分的顶部:

```
// @include         http://mail.yahoo.com/
```

然后我们添加适当的脚本；在这种情况下，登录字段没有 id，所以我们必须通过`document.forms`找到它:

```
//look for the yahoo mail login form 

var yahoo = typeof document.forms['login_form'] != 'undefined' 

  ? document.forms['login_form']['login'] : null; 

if(yahoo != null) 

{ 

  //write your username to the field 

  yahoo.value = 'brothercake'; 

}
```

您可以随意添加更多的站点，为每个站点定义一个@include 域，以及一段代码来查找并完成它的表单域(显然，将用户名改为您的！).

*改变布局*

用户脚本可以做的不仅仅是编写单个元素:它可以重写任何页面的整个 DOM，使它的外观和行为完全符合您的要求。在下一个例子中，我将修改默认的 [Slashdot](http://slashdot.org/) 首页。我将从顶部移除广告框架，并替换为站点搜索表单的副本，否则它将只显示在底部:

从代码归档中查看或安装脚本 slashdot-restructure.user.js。

对于自动完成示例，或者任何修改特定页面的用户脚本，我只知道要更改哪些元素，因为我查看了源代码。但我不能控制它，而且在未来某个时候它可能会改变。

这是一个显而易见的观点，但尽管如此，它仍然很重要:我们写的任何对 DOM 做出假设的东西总有一天会停止工作，对此我们无能为力。

然而，我们至少可以做好准备，确保在修改之前测试某些东西的存在。无论如何，这是一个好的实践，但是在这里它变得加倍重要。事实上，这是在 Slashdot 示例脚本中测试 null 的目的；事情是这样的:

```
//the first center element contains an ad frame 

var adframe = document.getElementsByTagName('center')[0]; 

//remove it 

if(adframe != null) { adframe.parentNode.removeChild(adframe); }
```

现在，如果脚本确实失败了，至少它不会抛出任何错误。

*定制搜索结果*

我经常想，如果搜索结果能以树形菜单的形式出现，并带有+/-图标，允许用户显示和隐藏摘要，那该多好。令人欣慰的是， [Google](http://www.google.com) 的结果有一个可预测的(虽然有点糊)结构，很容易迭代，因此提取相关信息并将其重新格式化为动态列表是一项相当简单的任务:

从代码归档中查看或安装脚本 google-tree.user.js。

我们在解析 HTML 时将面临的唯一严重的复杂情况是，当结果包含翻译链接时，格式会发生变化(它有一个额外的 containing `<table>`)。但是，如果我们考虑到这一点，我们可以可靠地识别每个结果的摘要，然后为其添加由动态创建的图标触发的显示/隐藏行为。

这些行为来自图标上的一个 onclick 处理程序，它同时支持鼠标和键盘导航。在链接 href 中使用 javascript:void(null)只是提供了一个 href 值；否则链接就不能用键盘导航(因为 Mozilla 不能在没有 href 的链接上设置焦点)。它本质上和使用`href="#"`的技巧是一样的，但是这个方法更干净:它不做任何其他事情，所以你不必用同样的方式控制它的返回值。

***提高网站可用性***

到目前为止，我们看到的所有例子都是为特定的网站设计的。但是用户脚本可以在每个网站上运行，这也许是这个想法变得不同寻常的地方:你可以编写用户脚本来改变整个网络的行为。实际上，你可以通过写一些简单的 JS 来定制你的浏览器。

这里的实际考虑略有不同，因为，一般来说，我们不会寻找特定的结构:我们将制作一些新的东西，或者修改广泛使用的属性。因此，这个例子中的脚本通常比前面的例子更向前兼容。

*改变链接目标*

一个显而易见的应用程序，这个脚本识别具有`"_blank"`目标属性的链接，并将它们重定向到`"_self"`:

从代码档案中查看或安装脚本 target-changer.user.js。

这个脚本使用单个文档 onclick 处理程序来动态地更改链接目标，而不是遍历所有链接并预先更改它们。我们这样做部分是因为这样更有效，但主要是因为如果目标已经由其他脚本设置，脚本仍然可以工作(记住 Greasemonkey 用户脚本在`window.onload`事件之前运行)。

使用更复杂的脚本，您可以走得更远:更改或删除 onclick 事件，重写 javascript: URIs，甚至完全覆盖`open()`方法。但是这种激进的措施带来了阻塞您确实想要的功能的风险:如果覆盖了`open()`方法，一些链接可能最终什么都不做。这种事情你可能只想在特定的网站上做，而不是在一般的网站上。

*移除广告*

移除广告的困难在于，并非所有的广告都是不需要的。有些人根本不喜欢任何广告，而对许多人来说，简单的基于文本的广告是可以接受的，只有大型或动画图形广告被认为是侵扰性的。广告的来源也可能是相关的:也许特定的公司或网站更有可能刊登你感兴趣或倾向于信任的广告。

任何广告拦截程序都不可避免地会对其定制的精确度有所限制，但有了用户脚本，就没有这样的限制:你可以完全按照你喜欢的方式定制脚本，并避免任何不必要的干扰。

在这个例子中，我根据广告的类型将脚本划分为不同的方法——无论是图像、iframe 还是 flash 广告；进一步测试每个对象，看它是否来自已知的广告服务器:

从代码归档中查看或安装脚本 remove-ads.user.js。

如果您不想删除某个类型的对象，只需在脚本底部注释掉它的方法调用:

```
//instantiate and run   

var rem = new removers();  

rem.banners();  

rem.iframes();  

rem.flash();
```

如果要扩展 ad 服务器的列表，可以向对象构造函数顶部的 domains 数组中添加任意数量的服务器:

```
//list the domains or subdomains from which ads might be coming  

this.domains = ['doubleclick.net','servedby.advertising.com'];
```

此外，如果你想让某些网站展示它们的广告，无论是什么广告，你都可以将这些网站添加为`@exclude`评论:

```
// @exclude         https://www.sitepoint.com/*
```

这个原理可以更进一步，控制一个元素是否被删除——你可以通过大小来区分，例如，468 x 60 像素的图像。或者你可以只允许 Flash 使用`<object>`嵌入，而不允许它使用`<embed>`。这将过滤掉大多数广告，而不去管合规的网站！

*正确的语言和拼写*

Cornell Kimball 做的一项关于常见拼写错误的研究分析了互联网(新闻组)新闻组，以发现最常见的拼写错误。该脚本使用其中的一些数据来构造正则表达式，进行文本替换以纠正常见错误:

从代码档案中查看或安装脚本 language-corrector.user.js。

您可以通过在列表中添加亵渎性过滤器来扩展这个想法:将不可接受的语言转换成“***”或任何空字符串。但是一定要小心那些可能是其他单词的子串的单词，比如“ham”是“gingham”。(有这样一个故事，英国斯肯索普镇的一个地方当局因为邮件过滤规则中的一个重要疏漏，一整天都没有邮件。)您可能需要测试一个单词，加上前导和尾随空格或标点符号，以确保不会出现这种问题。

一个更复杂的例子可以扫描单个页面，寻找复杂的术语，或者网站上没有正确解释的技术短语，在需要的地方添加`<abbr>`或`<dfn>`。你甚至可以直接建立到在线词典或其他参考资料的链接。

*谷歌网站搜索*

一个缺乏搜索功能的网站使用起来可能会令人沮丧，但谷歌允许你在单个网站内搜索，只需将 site:domain.com 附加到查询中。该脚本使用该语法在每个页面上创建特定于站点的搜索框。

或者，至少……计划是这样的:

从代码归档中查看或安装脚本 site-search.user.js。

脚本是可靠的，想法听起来不错，但是它有一个非常严重的问题:它不工作。

如果我不能让它工作，我通常不会发表一个脚本，但我认为这是一个如此好的想法，如果不包括它将是一种耻辱，无论如何，我想看看它带来的问题。

如果您尝试一下，就会发现核心脚本可以工作，但是您不能在文本框中键入内容，尽管您可以复制并粘贴到文本框中，然后按 Enter 键提交。进一步的调查显示，`"-moz-user-modify"`属性的值为`"read-only"`(尽管将其显式设置为`"read-write"`没有帮助)。

现在我确实想到了两个丑陋的方法来解决这个问题，它们都有效，但是我很不情愿使用它们，因为我认为它们挑战了安全限制。该脚本创建了一个用户界面元素，也许 Firefox 扩展不允许在您正在查看的页面的 DOM 中启动用户输入。我在这里进行猜测，因为我还没有找到事实，但如果是这样，或者类似的情况，我怀疑这也将适用于任何基于表单的用户脚本，使这种事情基本上站不住脚。如果有人能对此有所说明，我洗耳恭听！

*焦点工具提示*

我经常因为标题属性工具提示没有在键盘导航中显示出来而感到沮丧——它们只有在你使用鼠标时才起作用。该脚本通过创建由焦点事件触发的工具提示对此进行了补偿:

从代码档案中查看或安装脚本 onfocus-tooltips.user.js。

脚本非常简单；它创建一个元素并写入标题文本(如果有的话)。复杂之处在于工具提示的定位:它必须相对于触发元素定位自己，然后补偿可能位于窗口之外或文件夹之下的位置。它处理链接、iframes、对象和表单元素——那些可以接收焦点的元素——并创建使用 [CSS2 系统颜色](https://www.w3.org/TR/CSS21/ui.html#system-colors)设计的工具提示。

*标题-导航栏*

大多数串行浏览器(像 JAWS 这样的屏幕阅读器，和 Lynx 这样的纯文本浏览器)都有一个“标题模式”或类似的东西，它们列出并链接页面上的所有标题。它提供了更大程度的随机访问(在使用适当标题的页面上)。

该脚本模拟了该功能，在页面的右上角创建了一个小的“H”图标，从该图标可以下拉一个菜单，其中包含指向每个标题的链接:

从代码归档中查看或安装脚本标题-navigation.user.js。

菜单构建为一个列表，其中的每一项都是一个链接，由原始标题中的文本或其他 HTML 填充。如果标题包含图像，它将与其余部分一起再现，但是，由于这可能并不理想，另一种方法是提取并使用替代文本，或者可能完全删除无关的标记。

*保留备用样式表*

本节中的最后一个例子以一个善意的脚本开始，但是在这个过程中打开了一个蠕虫的罐子…

“替代”样式表的一个问题是，使用大多数浏览器的内置切换器所做的更改不会在页面之间持续，这使得它几乎只是一个新奇的功能，除非作者使用 cookies 进行干预。也许，在未来，更多的浏览器会实现这种行为，但在那之前，我们可以写一个用户脚本来为我们做这件事。

这个例子寻找通过`<link>`元素包含的样式表，并在它改变时将它们的禁用状态保存到 cookie 中；然后，该脚本将最后一个状态重新应用于后续的页面视图。这有效地为使用本地样式表切换的站点增加了特定于域的持久性:

从代码归档中查看或安装脚本 persist-stylesheets.user.js。

它之所以有效，是因为 Firefox 用本地切换机制的变化来更新样式表的 disabled 属性，所以我们可以简单地通过不断获取数据并将其保存到 cookie 中来实现持久性。

这给我们带来了第一个重要的点，也是我们的蠕虫罐的盖子:我们正在使用的 cookie 是在一个我们无法控制的域中。从实践的角度来看，这意味着如果网站已经大量使用 cookies，我们将冒填满数据限制(4K)的风险，从而覆盖网站需要的数据。我们无法避免这种可能性(除了完全不使用 cookies 之外)，但是我们可以通过保持数据尽可能小来降低风险。您还可以通过列出特定的`@include`域来减少影响，在这些域中您知道需要这个特性，而不是在每个使用替代样式表的站点上运行它。

但是突然之间，这里也出现了安全隐患:很容易编写一个用户脚本，从它遇到的每个站点窃取 cookie 和其他数据，然后将它们发送到其他地方。用户可能将自己暴露在一个全新的剥削角度；cnet 最近的一篇文章已经将这个问题提到了前台。它还询问了更多关于网站所有者是否会反对以这种方式修改他们的页面的一般性问题。

狄恩·爱德华兹提出了一个类似的观点，他有趣地讲述了 [Greasemonkey 如何破坏了他的网站](http://dean.edwards.name/weblog/2005/03/ungreased/)；接下来是一场激烈的辩论。如果随着越来越多的人使用 Greasemonkey，我们不再能够预测我们网站的 DOM，这看起来当然很不幸；但这个问题真的没有实际意义，因为事实已经如此。任何人都可以在自己的浏览器中以任何方式显示任何页面；在运行任何客户端脚本之前，许多浏览器插件、屏幕阅读器和其他用户代理将改变、重写或添加到页面的 DOM 中。

Greasemonkey 给我们的功能没有什么不同，除了可能会有更多的人使用它，我想这真的是一个问题——特别是当涉及到对广告收入的影响时。就像 TiVo(一种可以从录像中过滤广告插播的数字电视系统)一样，只有当很多“普通”人使用它时，这才会成为一种威胁。

但是安全问题非常严重，Greasemonkey 博客提出浏览器不应该在没有用户提示的情况下在当前域外发出 http 请求。这当然可以减少数据窃取的问题，尽管也有不必要的副作用(对合法的远程联合的影响呢？).正如作者所承认的那样，它并没有完全根除问题:没有什么能阻止用户脚本通过另一个服务器重写页面链接，并在此过程中添加查询字符串数据。

我认为其中的含义是:非技术用户必须能够信任他们安装的用户脚本的来源。一个可能的解决方案是从一个验证源获得用户脚本的存档，就像 Firefox 扩展一样。这不会阻止开发人员直接提供脚本，或者用户下载脚本，但是它会给非技术用户一个地方，让他们可以确保他们安装的任何东西都是安全的。事实上，一直活跃的通用汽车开发团队正在寻找这样做的方法，userscript.org 网站计划管理一个可用脚本的目录。

***开发者工具***

用户脚本可能也代表了开发人员工具创建的利基——您可以为特定项目编写和定制脚本，或者保存为根据需要启用或禁用的通用工具的集合。与 bookmarklet 的明显对比再次浮现在脑海中，因为用户脚本是自动运行的，所以我们可以做一些运行一次、手动启动的 bookmarklet 不可能做的事情。

*字数*

单词计数器是有用的工具，但它不是你在浏览工具集中所期望的那种东西，而且它对一般的网上冲浪没有多大用处。但是对于开发来说——尤其是像我经常做的那样直接用 HTML 写文章——在你写的时候有一个计数器是很方便的。

从代码归档中查看或安装脚本 word-count.user.js。

这个脚本使用了与我们之前看到的语言修正器类似的技术，通过遍历元素并寻找它们的子文本节点来从页面中提取文本。然后，它分割并处理文本以计算字数，并在`<title>`属性中显示结果(添加而不是覆盖它)。

*Viewport Size*

这个简短的脚本使用 Mozilla 属性读取视窗(内部窗口)尺寸，并在`<title>`中显示该数据:

从代码归档中查看或安装脚本 viewport-size.user.js。

***跟油猴一起玩***

我很高兴意识到用户脚本的喜剧角度…这让我想起了我曾经的一份工作，我们曾经通过编写书签来娱乐自己，对公司网站进行细微和不那么细微的更改。它让我们发笑……而且这一切最终都是无害的，所以如果你想让严肃的网站看起来很傻，我完全支持你怎么做。这里有几个简单的脚本，让网络变得更加有趣！

说出那个名人的名字

政治家、行业领袖和其他知名人士的名字已经成熟，可以转换成滑稽的短语了……我将通过对一些你肯定知道的名字进行一些调整，向你展示基本的脚本:

从代码归档中查看或安装脚本 name-that-celebrity.user.js。

这个示例类似于语言修正器脚本，因为它从页面中提取文本，并在半随机的基础上对列出的单词进行更改。

*蓝精灵*

这个最终剧本又可爱又傻。它分析文本以寻找特定模式的单词，并将其中一些单词更改为“smurf”:

从代码归档中查看或安装脚本 smurfify.user.js。

##### Opera 中的用户 JS 及其他

Opera 计划用户 JavaScript 已经有一段时间了，该功能现在在 Opera 8 中可用，已经被引入到测试版，并由 Hallvord Steen 在最近的日志条目中宣布。(尽管有趣的是，这并不是第一个公开的实现——[Opera 7“博克”版](http://www.opera.com/pressreleases/en/2003/02/14/)将一个 JS 文件加载到 MSN 页面中，将它们转换成布偶的瑞典厨师的语言！)

用户脚本类似于 Opera 中的 Greasemonkey。该浏览器确实实现了直接兼容模式，但它也以来自`window.opera`对象的特殊目的事件的形式提供了额外的功能，并且实际上只面向高级用户，因为需要一些手动配置。Rijk van Geijtenbeek 拥有 Opera 中最全面的用户脚本资源，转换本文的示例在很大程度上并不困难，特别是因为我们从一开始就计划这样做。

鉴于人们使用用户脚本的方式，用户脚本的工作方式和权限可能必须改变，或者导致浏览器改变。但是，不管发生什么，很明显用户脚本已经存在了。类似的功能在 Safari 中可以通过一个名为[pith 头盔](http://culater.net/software/PithHelmet/PithHelmet.php)的浏览器插件获得，甚至无处不在的 Internet Explorer 也将很快加入这一行动，这要归功于托德·奥斯特梅尔(Todd Ostermeier)和有着诗意标题的 [GreasemonkIE](http://www.daishar.com/blog/archives/2005/03/greasemonkey_fo.html) 。

我认为像这样的技术对网络是有益的，因为它们让用户对网络的行为有更多的控制，这改善了对信息的整体访问。但是在几个方面有强烈的分歧，也许用不了多久，我们就会被反 greasemonkey 编码技术淹没，然后是反技术！

我将以极大的兴趣关注此事的发展。

##### 更多资源

*   [Greasemonkey 开发者网站](http://greasemonkey.mozdev.org/)
*   [Greasemonkey 博客](http://greaseblog.blogspot.com/)
*   [Greasemonkey 脚本库](http://dunck.us/collab/GreaseMonkeyUserScripts)

## 分享这篇文章