# 在 JS 中借鉴强类型语言的技术

> 原文：<https://www.sitepoint.com/borrowing-techniques-strongly-typed-languages-javascript/>

在本文中，我们将讨论如何在 JavaScript 代码中使用强类型语言的技术。介绍的技术将减少代码中的错误，并允许您减少需要编写的代码总量。尽管本文使用 JavaScript 作为示例，但是您也可以将这些技术应用于大多数弱类型的其他语言。

## JavaScript 类型系统

让我们首先快速回顾一下 JavaScript [数据类型](https://www.sitepoint.com/typing-versus-dynamic-typing/)系统是如何工作的。JavaScript 将其值分为两类:

*   原始类型，如`String`、`Number`和`Boolean`。当你把一个基本类型赋给一个变量时，你总是创建一个新值，它是你所赋值的副本。
*   引用类型，如`Object`和`Array`。分配引用类型总是复制同一引用。为了澄清这一点，让我们看下面的代码示例:

```
var a = [];
var b = a;

a.push('Hello');
```

当我们改变`a`时，变量`b`也会改变，因为它们都是对同一个数组的引用。这就是所有引用类型的工作方式。

JavaScript 不以任何方式强制类型，这意味着任何变量可以在任何时间点保存任何数据类型。本文的其余部分将讨论这样做的缺点，以及如何应用强制类型语言的简单技术来编写更好的 JavaScript。

## 引入一致类型的规则

一致类型的规则在理论上很简单:所有的值应该只有一种类型。强类型语言在编译器级别强制执行这一点，它们不会让你任意混合和匹配类型。

弱打字给了我们很大的自由度。一个常见的例子是将数字连接成字符串。你不需要做任何繁琐的类型转换，例如，在 c 语言中。

别担心，我不会让你丢掉所有的便利。一致类型的规则只要求你注意你的变量和函数的行为，结果，你的代码会得到改进。

### 变量中的类型

首先，让我们看看规则是如何应用于变量的。非常简单:你的变量应该总是只有一种类型。

```
var text = 'Hello types';

// This is wrong! Don't do it!
text = 1;
```

上面的例子说明了问题。这条规则要求我们假设这个例子中的最后一行代码会抛出一个错误，因为当我们第一次定义变量`text`时，我们给了它一个`string`类型的值，现在我们给它分配了一个`number`。一致类型的规则意味着我们不允许像那样改变变量的类型。

当变量一致时，对代码进行推理就更容易了。这在较长的函数中尤其有用，因为很容易忽略变量的来源。当我在不遵守这一规则的代码库中工作时，我曾多次意外地导致错误，因为我看到一个变量被声明，然后假设它将保持相同的类型——因为让我们面对它，这是有意义的，不是吗？通常没有理由将不同的类型赋给同一个变量。

### 函数参数中的类型

同样的规则也适用于此。函数的参数也应该一致。做错的一个例子:

```
function sum(a, b) {
if (typeof a === 'string') {
a = 1;
}

return a + b;
}
```

这有什么不好？基于类型检查来分支逻辑通常被认为是不好的做法。虽然也有例外，但是通常使用多态性会是一个更好的选择。

你应该确保你的函数参数也只有一种类型。如果您忘记考虑不同的类型，它会降低出现问题的可能性，并导致更简单的代码，因为您不必编写代码来处理所有不同类型的情况。编写`sum`函数的更好方法如下:

```
function sum(a, b) {
return a + b;
}
```

然后，在调用代码中而不是在函数中处理类型检查。从上面可以看出，现在功能简单多了。即使我们不得不将类型检查转移到其他地方，我们越早在代码中完成它们，我们的情况就越好。

我们将在本文的后面讨论类型检查和`typeof`的使用，包括如果使用不当，类型检查如何容易级联。

### 函数返回值中的类型

这和另外两个有关系:你的函数应该总是返回相同类型的值。

我们可以从 AngularJS 这里举个例子。AngularJS 为小写文本提供了一个函数，名为`angular.lowercase`。它还有一个标准函数，`String.prototype.toLowerCase`。我们可以比较他们的行为来更好地理解这部分规则:

```
var a = angular.lowercase('Hello Types');
var b = angular.lowercase(null);
```

变量`a`将包含您所期望的:`'hello types'`。然而，`b`将包含什么？会是空字符串吗？函数会抛出异常吗？或者可能只是去`null`？在这种情况下，`b`的值是`null`。请注意，猜测结果是多么的困难——我们立刻就有了三种可能的结果。对于 Angular 函数，对于非字符串值，它将始终返回输入。

现在，让我们看看内置的是如何工作的:

```
var a = String.prototype.toLowerCase.call('Hello Types');
var b = String.prototype.toLowerCase.call(null);
```

第一次调用的结果是一样的，但是第二次调用抛出了一个异常。内置函数遵循类型一致的规则，不允许不正确的参数类型。返回值也总是字符串。因此，我们可以说内置函数更好，但您可能想知道具体如何？

让我们考虑这样一个函数的典型用例。我们在代码中的某些地方使用它来将字符串转换成小写。正如 JavaScript 代码中经常出现的情况，我们不能 100%确定我们的输入总是字符串。没关系，因为我们是优秀的程序员，我们假设我们的代码没有任何错误。

如果我们使用 AngularJS 中不遵守这些规则的函数会发生什么？非字符串值可以顺利通过它。它可能会经过几个函数，也许我们甚至会通过一个`XMLHttpRequest`调用来发送它。现在错误的值在我们的服务器中，并最终出现在数据库中。你能明白我的意思，对吧？

如果我们使用了遵守规则的内置函数，我们会立即发现错误。

无论何时编写函数，都要确保它返回的类型是一致的。一个不好的例子如下所示:

```
function foo(a) {
if(a === 'foo') {
return 'bar';
}

return false;
}
```

同样，对于变量和参数，如果我们有一个这样的函数，我们不能对它的行为做出假设。我们需要使用一个`if`来检查返回值的类型。我们可能会在某个时候忘记它，然后我们又有了另一个 bug。我们可以用许多方法重写它，这里有一种方法可以解决这个问题:

```
function foo(a) {
if(a === 'foo') {
return 'bar';
}

return '';
}
```

这一次，我们确保所有的路径都返回一个字符串。现在推理函数的结果就容易多了。

## `null`和`undefined`比较特殊

到目前为止，我们真的只是谈论了原始类型。当涉及到对象和数组时，您应该遵循相同的规则，但是有两种特殊情况需要记住。

在处理引用类型时，有时需要指明没有值。一个很好的例子就是`document.getElementById`。如果没有找到匹配的元素，它将返回`null`。

这就是为什么我们会考虑让`null`与任何对象或数组共享类型，但仅仅是那些。你应该避免从一个函数中返回`null`，否则这个函数可能会返回一个原始值，比如`Number`。

`undefined`也可以认为是一个“没有价值”的参考文献。对于大多数目的，它可以被视为等于`null`，但是`null`是首选，因为它在其他面向对象语言中的语义。

### 数组和`null`

当使用数组时，您还应该考虑到空数组通常是比`null`更好的选择。尽管数组是引用类型，您可以对它们使用`null`,但返回一个空数组通常更有意义。让我们看看下面的例子:

```
var list = getListOfItems();

for(var i = 0; i < list.length; i++) {
//do something
}
```

这可能是数组最常见的用法之一。你从一个函数中得到一个数组，然后迭代它去做别的事情。如果在没有条目的情况下`getListOfItems`返回一个`null`，上面的代码会发生什么？它会抛出一个错误，因为`null`没有`length`(或者任何其他属性)。当您考虑像这样的数组的典型用法，甚至是`list.forEach`或`list.map`时，您可以看到当没有值时返回一个空数组通常是一个好主意。

## 类型检查和类型转换

让我们更详细地看看类型检查和类型转换。什么时候应该进行类型检查？什么时候应该进行类型转换？

### 类型变换

类型转换的第一个目标应该是确保您的值是正确的类型。数值应该是`Number` s 而不是`String` s 等等。第二个目标应该是只需要转换一次值。

进行类型转换的最好地方是在源代码中。例如，如果您从服务器获取数据，您应该在处理接收数据的函数中进行任何必要的类型转换。

解析 DOM 中的数据是一个很常见的例子，说明问题从哪里开始。假设你有一个包含数字的文本框，你想读它。或者，它可能只是某个 HTML 元素中的一个属性，甚至不一定是用户输入。

```
//This is always going to be a string
var num = numberInput.value;

//This is also always a string
var num2 = myElement.getAttribute('numericAttribute');
```

因为可以从 DOM 获得的值通常是字符串，所以在读取它们时进行类型转换很重要。在某种程度上，你可以把它看作是你的模块的“边缘”。数据通过读取它的函数进入 JavaScript 模块，因此它必须将数据转换成正确的格式。

通过在模块的边缘进行类型转换，我们确保了内部不需要处理它。这大大降低了隐式类型强制导致错误的可能性。它还允许我们编写更少的代码，因为我们不会让错误的值从边缘进入模块。

```
//We can parse ints and floats like so
var num = parseInt(numberInput.value, 10);
var num2 = parseFloat(myElement.getAttribute('numericAttribute'));

//But if you need to convert a string to a boolean, you need to do a string comparison
var bool = booleanString === 'true';
```

### `typeof`和类型检查

您应该只使用`typeof`进行验证，而不是基于类型的分支逻辑。虽然也有例外，但这是一个很好的经验法则。

让我们来看两个例子:

```
function good(a) {
if(typeof a !== 'number') {
throw new TypeError('a must be a number');
}

//do something
}
```

这是一个使用`typeof`进行验证的例子。我们正在确保给函数的参数是正确的类型。但是，下面的示例显示了按类型分支逻辑的含义。

```
function bad(a) {
if(typeof a === 'number') {
//do something
}
else if(typeof a === 'string') {
//do something
}
else if(typeof a === 'boolean') {
//do something
}
}
```

不要这样。尽管有时这是必要的，但这通常是糟糕设计的标志。如果您发现自己经常执行这种逻辑，您可能应该在代码中更早地将值转换为正确的类型。

如果您的代码中出现了大量的`typeof`,这可能是一个信号，表明您可能需要转换要比较的值。类型检查通常会分散开来，这通常是类型设计不佳的好迹象。

如前所述，您应该尝试在模块边缘进行类型转换，因为这样可以避免`typeof`级联。如果您在早期进行转换，那么在此之后调用的函数都不需要进行类型检查或类型转换。

这也适用于对象:如果您发现自己使用`instanceof`做了很多检查，或者检查对象上的属性是否存在，这是一个信号，也许您应该以不同的方式构造数据。

同样的规则也适用于`instanceof`和`typeof`:你应该尽量避免它，因为它可能是糟糕设计的标志。但是有一种情况是不可避免的:

```
try {
// some code that throws exceptions
} catch(ex) {
if (ex instanceof TypeError) {

} else if (ex instanceof OtherError) {

}
}
```

如果您的代码需要对异常类型进行特殊处理，`instanceof`通常是一个不错的选择，因为 JavaScript `catch`不允许像在其他语言中那样通过类型来区分。在大多数其他情况下，你应该尽量避免`instanceof`。

## 结论

正如我们所发现的，JavaScript 的弱类型给了我们很大的自由，但我们也必须三思而后行。否则，我们将陷入一大堆毫无意义的类型中。

通过确保我们的代码遵循一致类型的规则，我们为自己节省了很多麻烦。当我们知道代码的类型时，对代码进行推理就容易多了。我们不必仅仅为了防止错误而在代码中构建大量的类型检查。

如果您没有使用过强类型的语言，这可能看起来很困难，但是当您需要调试或维护代码时，它会有很大的回报。

关于这个主题的进一步阅读，我建议看一看 [TypeScript](http://www.typescriptlang.org/) 。这是一种类似于 JavaScript 的语言，但是它为这种语言增加了更强的类型语义。它还有一个编译器，当你试图做一些愚蠢的事情时，比如混合和匹配类型，它会吐出错误。

## 分享这篇文章