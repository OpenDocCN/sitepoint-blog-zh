# 比较 Ruby 后台处理库:延迟的作业

> 原文:[https://www . site point . com/comparing-ruby-background-processing-libraries-delayed-job/](https://www.sitepoint.com/comparing-ruby-background-processing-libraries-delayed-job/)

[![People and door blue](../Images/69d2421314be9713afee641580ee3d95.png)T2】](https://www.sitepoint.com/wp-content/uploads/2013/09/Fotolia_52657937_Subscription_XL.jpg)

一旦您开始在典型的“教程风格”博客之外的 Rails 应用程序上工作，除了响应用户请求之外，您可能还需要某种处理。

例如，如果您需要向您的一些用户发送电子邮件，让他们知道他们的试用计划即将到期，您实际上不能在控制器中处理这一点，因为没有特定用户需要发出的特定请求来取消这一点。您需要将这种逻辑与应用程序中直接响应 HTTP 请求的部分完全分离开来(因此，对于 Rails 来说，这些是您的控制器和其中的操作，在某种程度上，还有视图)。

另一个可能需要这种“东西”(让我们称之为后台处理或后台作业)的例子是一个需要大量时间的操作(根据经验，任何需要超过 400 毫秒的操作)，并且您不想让您的用户等待。假设你在运营一个视频网站。一旦用户上传了一个视频，你的应用程序必须对它进行编码，这可能需要 10 多分钟。显然，在对视频进行编码时，不能让用户一直挂在 HTTP 请求上(这可能会超时)。相反，您需要以某种方式告诉 Rails，“在这里，获取这些代码并在后台运行，同时我用一些 HTML 来响应用户”。

另一个真正常见的用例是当您的应用程序需要与其他服务器通信时。这可能会花费很多时间，并且也是一个非常容易出错的过程(例如，另一端的服务器可能会关闭。)这种情况下，委托给后台就很有意义了。

让我们深入了解一下*后台处理*是如何工作的，以及 Ruby 社区提供的在应用程序中实现它的替代方案。

## 理论

理解后台作业/处理背后的基本原理非常重要。有了这些知识，你就知道你在做什么，以防你不得不做一些调试。

现代操作系统允许许多进程在一台计算机上“同时”运行。注意“立刻”是用引号括起来的；通常，所有的进程不会在同一时刻运行(简单解释:如果你有四个内核，*通常*四个进程可以同时运行)。操作系统中的一个叫做*调度器*的部分给每个进程一点时间来运行，然后切换到另一个进程，为系统中的每个进程都这样做。通过这样做，调度程序提供了所有进程同时运行的假象，因为它在进程之间切换的速度非常快(类似于 LED 快速闪烁，就好像它一直在亮着)。

也许我们可以为我们希望在后台处理的每个作业创建一个新进程(除了响应 HTTP 请求的进程之外)。但是，事实证明，就所使用的计算资源而言，创建进程并不是一个轻量级的操作。如果我们要实施这一战略并拥有 100，000 个工作岗位，我们需要创建 100，000 个流程！相反，后台处理可以使用*队列*。

队列是一种定义良好的数据结构，它允许我们根据特定的规则向队列中添加内容或从中取出内容。它是一个 *FIFO(先进先出)结构*，这意味着如果你放入“a”然后你放入“b”，你在“b”之前检索“a”(有点像添加到一个列表的开头，然后从它的结尾读取)。要点是我们可以将“作业”添加到队列中，然后工人(在他们自己的进程中运行)将在以后处理它们。

事实证明，至少可以说，管理所有这些是很困难的。例如，如果一个工人或一项工作花费的时间太长，阻塞了队列的其余部分，系统会怎么做？您如何确保您的队列运行良好(请记住，队列本身必须保存在内存或磁盘中)？对我们来说幸运的是，Ruby 社区的人们已经想出了很多这种东西，并把它们放进了几个不同的库中，比如 **delayed_job** 、 **Resque** 和 **Sidekiq** ，它们都采用不同的方法来解决几乎相同的问题。

## 延迟::作业

Shopify 用 Delayed::Job 挠了挠自己的痒，他们很好地开放了源代码并编写了一些文档，以便 Ruby 社区的其他人可以利用它。

只考虑 Delayed::Job(以下简称 DJ)的稳定后端，使用 ActiveRecord，Mongoid 等。作为队列所基于的系统。这意味着您不需要运行任何其他东西(比如 Redis)来充当您的排队系统；Rails 应用程序中的 ActiveRecord 可以工作。

DJ 入门是这三者中最容易的，这就是为什么很多人更喜欢它。将以下内容添加到您的 gem 文件中:

```
gem 'delayed_job_active_record'
```

安装 gem，并通过在 shell 中键入以下命令来建立必要的数据库结构:

```
bundle install
rails generate delayed_job:active_record
rake db:migrate
```

DJ 代码是*真的*容易写和理解。你所要做的就是将`.delay.method(parameters)`添加到任何一个对象中来异步调用`method`(即在后台；您的代码将继续前进，而不是等待输出)。

例如，如果您有以下用户模型:

```
class User < ActiveRecord::Base
...
  def send_newsletter(email)
    #send the newsletter here, which will take some time and you
    puts 'From send newsletter: ' + email
  end
...
end
```

您可以在控制器中执行以下操作:

```
class IndexController < ApplicationController
  def index
    u = User.new
    #do some processing on the user object
    u.save

    #send the user a newsletter...delayed!
    u.delay.send_newsletter(params[:email])         
  end
end
```

或者，您可以更改模型，以确保无论发生什么情况都可以异步处理`send_newsletter`:

```
class User < ActiveRecord::Base
  ...
  handle_asynchronously :send_newsletter
  …
end
```

然后，您只需要在控制器中这样做(即没有`.delay`)，以便异步调用该方法(即将其作为作业放入队列中):

```
u.send_newsletter(params[:email])
```

要查看其运行情况，您可以按照说明设置控制器和模型，并运行 Rails 服务器。我们需要通过 shell 做一点额外的设置来让我们的队列运行起来:

```
rails generate delayed_job:active_record
rake db:migrate
```

现在，访问“/index/index”会将作业推到队列中(因为我们正在使用`.delay`)。要处理这个作业，我们所要做的就是在 shell 中键入:

```
rake jobs:work
```

您应该会看到一条“时事通讯:完成！”在输出中。太好了！

正如你所看到的，DJ 使得做一些相当复杂的事情变得非常容易(我们已经创建了一个队列，用 email 参数将一个作业放入其中并处理了该作业！).他们也有很好的文档和庞大的用户社区。特别是，DelayedJob 使得*真正*容易访问模型参数，因为方法就在你的模型中。不幸的是，它也有一些缺点。

DJ 并不是最快的选择。大多数人建议，如果你一天要做一大堆工作，你应该换个工作。DJ 性能低下的一个主要原因是用来支持队列的数据库的选择。

DJ 基本上需要在数据库上运行来支持它的队列。这意味着您实际上是在向磁盘写入数据，而实际上并不需要这样做(您可以在大部分时间将队列完全保存在内存中)。

这就是像 [Redis](http://redis.io/) 这样的东西出现的地方——它是一个 NoSQL 数据存储，允许在内存中保存数据(有点像 memcached)。Redis 被描述为“远程字典”，也就是说，它有点像 Ruby hash，但是在服务器上。如果 Redis 只保存在内存中(例如，当您重新启动服务器时，它就消失了)，它看起来似乎没有什么意义，但是，Redis 也可以保存到磁盘上！

DJ 正在走向支持 Redis。然而，目前的支持是不稳定的，所以，我不会在生产中使用它。另一方面，Resque 是在 Redis 上自下而上构建的。

## 示例应用程序

我构建了一个示例应用程序来展示一个可以在本地运行的简单的延迟*作业示例(它使用 filepicker 演示作为起点)。基本上，你上传一个附件，它将异步设置它的页数。但是，如果您对这些上传的附件之一(一个资源路由)执行“显示”操作，它会同步找出页面计数。重点是展示如何轻松地设置延迟的*作业代码，以及如何仅使用一种方法混合同步和异步代码(在我看来，这是 delayed_job 的一个缺点，因为它使得推理某些方法变得更加困难)。

点击查看

## 敬请期待！

本文的第二部分将介绍 Resque，并将其与 DelayedJob 进行比较！

## 分享这篇文章