# 对 XML 非常非常非常好的介绍

> 原文:[https://www.sitepoint.com/really-good-introduction-xml/](https://www.sitepoint.com/really-good-introduction-xml/)

我们将讲述 XML 的基础知识——为什么它会出现，XML 的用途是什么，XML 是如何构造的，以及一些常见的陷阱和注意事项。

如果在 90 年代末和 21 世纪初有一个“最被炒作的技术”的候选人，那就是 XML(尽管 Java 是这个头衔的有力竞争者)。在本文中，我将解释什么是 XML 以及它的用途。

## 什么是 XML？

XML 的精髓就在于它的名字:可扩展标记语言。

*   **可扩展:** XML 是可扩展的。它允许您定义自己的标签、标签出现的顺序以及标签的处理或显示方式。考虑可扩展性的另一种方式是认为 XML 允许我们所有人扩展文档的概念:它可以是位于文件服务器上的文件，也可以是在两个计算机系统之间流动的短暂数据(就像 Web 服务的情况一样)。
*   标记:XML 最容易识别的特征是它的标签，或者说元素(更准确地说)。事实上，您将在 XML 中创建的元素与您已经在 HTML 文档中创建的元素非常相似。但是，XML 允许您定义自己的标签集。
*   语言: XML 是一种非常类似于 HTML 的语言。它比 HTML 灵活得多，因为它允许你创建自己的定制标签。然而，重要的是要认识到 XML 不仅仅是一种语言。XML 是一种元语言:一种允许我们创建或定义其他语言的语言。例如，使用 XML 我们可以创建其他语言，如 RSS、MathML(一种数学标记语言)，甚至像 XSLT 这样的工具。稍后将详细介绍。

### XML 是用来做什么的？

XML 之所以被创造出来，是因为 HTML 是专门为描述在 Web 浏览器中显示的文档而设计的，除此之外别无他用。如果你想在移动设备上显示文档或者做一些稍微复杂的事情，比如把内容从德语翻译成英语，那就很麻烦了。HTML 的唯一目的是允许任何人快速创建可以与其他人共享的 Web 文档。另一方面，XML 不仅仅适用于 Web——它可以用在各种不同的上下文中，其中一些可能与人类与内容的交互无关(例如，Web 服务使用 XML 来回发送请求和响应)。

HTML 很少(如果有的话)提供关于文档是如何构造的或者它意味着什么的信息。通俗地说，HTML 是一种表示语言，而 XML 是一种数据描述语言。

例如，如果你去任何电子商务网站下载一个产品列表，你可能会得到类似这样的东西:

```
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
    "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
 <html > 
 <head> 
 <title>ABC Products</title> 
 <meta http-equiv="Content-Type" 
    content="text/html; charset=iso-8859-1" /> 
 </head> 
 <body> 
 <h1>ABC Products</h1> 
 <h2>Product One</h2> 
 <p>Product One is an exciting new widget that will simplify your 
  life.</p> 
 <p><b>Cost: $19.95</b></p> 
 <p><b>Shipping: $2.95</b></p> 
 <h2>Product Two</h2> 
 ... 
 <h3>Product Three</h3> 
 <p><i>Cost: $24.95</i></p> 
 <p>This is such a terrific widget that you will most certainly 
  want to buy one for your home and another one for your 
  office!</p> 
 ... 
 </body> 
 </html>
```

从计算机的角度好好看看这个公认简单的代码示例。人类当然可以阅读这份文件，并做出必要的语义跳跃来理解它，但计算机不能。

例如，人们可能会推断出上面文档中的`<h2>`标签已经被用来标记产品列表中的产品名称。此外，人们可能会猜测出`<h2>`后面的第一段包含描述，接下来的两段包含粗体的价格和运输信息。

然而，即使粗略地看一下文档的其余部分，也会发现一些非常人为的错误。例如，最后一个产品名封装在`<h3>`标签中，而不是`<h2>`标签中。最后一个产品列表也在描述前显示价格，价格是斜体而不是粗体。

试图破译这份文件的计算机程序(甚至一些人类)将无法做出理解这份文件所需的语义跳跃。计算机将只能用与每个标签相关联的样式将文档呈现给浏览器。HTML 主要是一组用于在网络浏览器中呈现文档的指令；它不是一种组织文档以揭示其含义的方法。

如果上面的文档是用 XML 创建的，看起来可能有点像这样:

```
<?xml version="1.0"?> 
 <productListing title="ABC Products"> 
  <product> 
    <name>Product One</name> 
    <description>Product One is an exciting new widget that will 
      simplify your life.</description> 
    <cost>$19.95</cost> 
    <shipping>$2.95</shipping> 
  </product> 
  <product> 
    <name>Product Two</name> 
    ... 
  </product> 
  <product> 
    <name>Product Three</name> 
    <description>This is such a terrific widget that you will 
      most certainly want to buy one for your home and another one 
      for your office!</p> 
    <cost>$24.95</cost> 
    <shipping>$0.00</shipping> 
  </product> 
  ... 
 </productListing>
```

请注意，这个新文档绝对不包含任何关于显示的信息。浏览器中的`<product>`标签是什么样子的？难倒我了——我们还没有定义它。稍后，我们将看到如何使用 CSS 和 XSLT 等技术将 XML 转换成您喜欢的任何格式。本质上，XML 允许你将信息从表示中分离出来，这只是它众多强大功能中的一个。

当我们专注于文档的结构时，正如我们在这里所做的，我们能够更好地确保我们的信息是正确的。理论上，我们应该能够查看任何 XML 文档并立即理解正在发生的事情。在上面的例子中，我们知道产品列表包含产品，每个产品都有名称、描述、价格和运费。你可以正确地说，每个 XML 文档都是*自描述的*，人和软件都可读。

现在，每个人都会犯错，XML 程序员也不例外。想象一下，您开始与另一个开发人员或公司共享您的 XML 文档，然后在某个地方，有人将产品的描述放在价格后面。通常情况下，这没什么大不了的，但是也许您的 Web 应用程序要求描述每次都出现在产品名称*之后。*

为了确保每个人都遵守规则，您需要一个 *DTD* (一个文档类型定义)，或者模式。基本上，DTD 提供了关于特定 XML 文档结构的说明。这很像一本规定哪些标签合法以及在哪里合法的规则书。一旦有了 DTD，任何为您的应用程序创建产品列表的人都必须遵守这些规则。稍后我们将讨论 dtd。但是现在，让我们继续从基础开始。

## **XML 结构**

从一般观察者的角度来看，给定的 XML 文档，比如我们在上一节中看到的，看起来只不过是一堆标签和字母。但是事情远不止如此！

让我们从结构的角度来考虑我们的 XML 例子。不，不是那种我们用 XML 标记给文档带来的结构；让我们从更细的角度来看这个例子。我想逐个字符地检查典型 XML 文件的内容。

最简单的 XML 元素包含开始标签、结束标签和一些内容。开始标记以左尖括号(`<`)开始，后跟包含字母和数字(但没有空格)的元素名称，并以右尖括号(`>`)结束。在 XML 中，内容通常是经过解析的字符数据。它可以由纯文本、其他 XML 元素和更奇特的东西组成，比如 XML 实体、注释和处理指令(所有这些我们将在后面看到)。内容之后是结束标记，它的拼写和大小写与开始标记相同，但是有一点小小的变化:一个`/`出现在元素名称的正前方。

以下是一些有效 XML 元素的示例:

```
<myElement>some content here</myElement> 
 <elements> 
  <myelement>one</myelement> 
  <myelement>two</myelement> 
 </elements>
```

### **元素、标签还是节点？**

我将在本文的不同地方提到 XML 元素、XML 标记和 XML 节点。怎么回事？对于外行人来说，这些术语是可以互换的，但是如果你想变得专业(谁会想这么做？)每个都有非常精确的含义:

*   元素由开始标签、其属性、任何内容和结束标签组成。
*   标签——开始或结束——用于标记元素的开始或结束。
*   节点是构成 XML 文档的层次结构的一部分。“节点”是一个通用术语，适用于任何类型的 XML 文档对象，包括元素、属性、注释、处理指令和纯文本。

如果您习惯于使用 HTML，您可能已经创建了许多缺少结束标记、在开始和结束标记中使用不同的大写字母以及包含不正确嵌套的标记的文档。

在 XML 中，你将无法摆脱这些！在这种语言中，`<myElement>`标签不同于`<MYELEMENT>`标签，两者都不同于`<myELEMENT>`标签。如果你的开始标签是`<myELEMENT>`，结束标签是`</Myelement>`，那么你的文档就无效。

如果在任何元素上使用属性，那么属性值必须用单引号或双引号引起来。您再也不能像在 HTML 中那样只使用属性值了！让我们看一个例子。以下内容在 HTML 中是可以的:

```
<h1 class=topHeader>
```

在 XML 中，您必须用引号(单引号或双引号)将属性值括起来，就像这样:

```
<h1 class="topHeader">
```

此外，如果您不正确地嵌套了您的元素(即，在关闭一个元素中的另一个元素之前关闭该元素)，您的文档将是无效的。(我知道我一直在提到有效性，我们很快就会详细讨论它！)例如，Web 浏览器通常不会抱怨以下内容:

```
<b>Some text that is bolded, some that is <i>italicized</b></i>.
```

在 XML 中，这种不恰当的元素嵌套会导致读取文档的程序产生错误。

由于 XML 允许您创建任何想要的语言，XML 的发明者不得不制定一个特殊的规则，这个规则恰好与适当的嵌套规则密切相关。该规则规定，每个 XML 文档必须包含一个根元素，文档的所有其他元素都包含在这个根元素中。正如我们将在后面看到的，几乎所有的 XML 开发都是由这条简单的规则促成的。

### **属性**

你注意到我们例子中的开始标签了吗？在标签内部，元素名称之后是数据`title="ABC Products"`。这叫做属性。

您可以将属性视为形容词——它们提供了关于元素的附加信息，这些信息作为内容可能没有任何意义。如果您曾经使用过 HTML，那么您应该熟悉诸如`<img>`标签上的`src`(文件源)这样的属性。

属性中应该包含什么信息？元素的标签之间应该出现什么？这是一个有很多争论的话题，但是不要担心，这里真的没有错误的答案。记住:你是定义自己语言的人。一些开发者(包括我！)应用这条经验法则:使用属性来存储不一定需要向信息用户显示的数据。另一个常见的经验法则是考虑数据的长度。潜在的大数据应该放在标记内；较短的数据可以放在一个属性中。通常，属性用于“修饰”标签中包含的数据。

让我们更仔细地研究一下这个问题。假设您想要创建一个 XML 文档来跟踪您的 DVD 收藏。下面是您可能会用到的一小段代码:

```
<dvdCollection> 
  <dvd> 
    <id>1</id> 
    <title>Raiders of the Lost Ark</title> 
    <release-year>1981</release-year> 
    <director>Steven Spielberg</director> 
    <actors> 
      <actor>Harrison Ford</actor> 
      <actor>Karen Allen</actor> 
      <actor>John Rhys-Davies</actor> 
    </actors> 
  </dvd> 
  .... 
 </dvdCollection>
```

阅读本文档的任何人都不太可能需要知道您收藏的任何 DVD 的 ID。因此，我们可以安全地将 ID 存储为`<dvd>`元素的属性，如下所示:

```
<dvd id="1">
```

在我们的 DVD 列表的其他部分，信息似乎有点裸露。例如，我们只在`<actor>`标签之间显示一个演员的名字——我们可以在这里包含更多的信息。一种方法是添加属性:

```
<actor type="superstar" gender="male" age="50">Harrison Ford
</actor> 
```

不过，在这种情况下，我可能会回到我们的经验法则——大多数用户可能希望至少知道一些这方面的信息。因此，让我们将其中一些属性转换为元素:

```
<actor type="superstar">
<name>Harrison Ford</name>
<gender>male</gender>
<age>50</age>
</actor> 
```

**当心冗余数据**

从一个完全不同的角度来看，有人可能会认为不应该在 XML 文件中包含所有这些重复的信息。例如，你的收藏肯定会包括至少一部由哈里森·福特主演的电影。从体系结构的角度来看，拥有一个单独的角色列表会更聪明，这些角色拥有惟一的 id，您可以链接到这些 id。

**空元素标签**

有些 XML 元素是空的——它们不包含任何内容。熟悉的例子是 HTML 中的`img`和`br`元素。例如，在`img`的例子中，所有元素的信息都包含在标签的属性中。另一方面，`<br>`标记通常不包含任何属性——它只是表示一个换行符。

请记住，在 XML 中，所有的开始标记都必须与结束标记相匹配。对于空元素，您可以使用单个空元素标记来替换它:

```
<myEmptyElement></myEmptyElement>
```

有了这个:

```
<myEmptyElement/>
```

这个标签末尾的`/`基本上告诉解析器元素在这里开始和结束。这是一种高效的速记方法，可以用来快速标记空元素。

**XML 声明**

在我们的例子的最上面的一行叫做 XML 声明:

```
<?xml version="1.0"?>
```

包含这一行并不是绝对必要的，但是这是确保任何读取文档的设备都知道这是一个 XML 文档，以及它符合哪个版本的 XML 的最好方法。

**实体**

我之前提到过实体。实体是一种方便的构造，最简单的是，它允许您定义插入到文档中的特殊字符。如果您使用过 HTML，您会知道`&lt;`实体将一个文字`<`字符插入到文档中。您不能使用实际的字符，因为它会被视为标签的开始，所以您要用适当的实体来替换它。

XML 符合其可扩展的本质，允许您创建自己的实体。假设您公司的版权声明必须出现在每一个文档上。您可以用适当的文本创建一个名为`copyright_notice`的实体引用，然后在 XML 文档中将其用作`&copyright_notice;`，而不是一遍又一遍地输入这个通知。多节省时间啊！

稍后我们将更详细地讨论实体。

**不止结构……**

XML 文档不仅仅是一系列元素。如果您再仔细看看我们的产品或 DVD 列表示例，您会注意到两件事:

*   正如我们已经讨论过的，文档是自描述的。
*   文档实际上是嵌套对象的层次结构。

让我们很快地阐述一下第一点。我们已经说过，大多数(如果不是全部)XML 文档都是自描述的。这个特性与封装在开始和结束标记中的所有内容相结合，使所有 XML 文档远远超越了单纯的数据领域，进入了备受尊崇的信息殿堂。

数据可以由一串字符或数字组成，如`5551238888`。这个字符串可以代表任何东西，从笔记本电脑的序列号，到药房的处方 ID，到美国的电话号码。但是，将这些数据转化为信息(并因此使其有用)的唯一方法是为其添加上下文——一旦有了上下文，就可以确定这些数据代表了什么。简而言之，`<phone country="us">5551238888</phone>`毫无疑问，这个看似任意的数字串实际上是一个美国电话号码。

当你考虑到第二点 XML 文档实际上是对象的层次结构——所有的可能性都展现出来了。还记得我们之前讨论过的吗——在 XML 文档中，一个元素包含所有其他元素？这个根元素成为了我们层次树的根。您可以将该树看作一个系谱树，根元素有多个子元素(在本例中是 product 元素)，每个子元素又有多个子元素(名称、描述等等)。反过来，每个产品元素又有不同的兄弟(其他产品元素)和一个父元素(根)，如图 1.1“XML 文档的逻辑结构”所示。

**图 1.1。XML 文档的逻辑结构。**
![1488_logicalstructure](../Images/741fa3dc3aee281da059f4f185a31769.png)

因为我们拥有的是一棵树，我们应该能够相对轻松地在树上上下移动，从一边到另一边。从编程的角度来看，使用 XML 的大部分工作将集中在正确创建和导航 XML 结构上。

关于层次树还有最后一点需要注意。之前，我们讨论了通过添加上下文将数据转换为信息。嗯，当我们开始建立表明自然关系的信息层次结构(被称为*分类法*)时，我们刚刚迈出了将信息转化为知识的第一大步。

### **样式和 XML**

在本文的前面，我提到了 XML 允许您将信息与表示分离。我还提到您可以使用其他技术，如 CSS(级联样式表)和 XSLT(可扩展样式表语言转换)，使信息在不同的上下文中显示。

**注意:**注意，在 XSLT 中是“样式表”，但在 CSS 中是“样式表”！

因为我们花时间创建了 XML 文档，所以我们的信息不再局限于专有格式，如文字处理器或电子表格。此外，每次想要创建该信息的替代显示时，不必再“重新创建”它:您所要做的就是创建一个样式表或转换，使您的 XML 可以在给定的介质中呈现。

例如，如果您将信息存储在一个字处理程序中，它将包含关于它在打印页面上的显示方式的所有类型的信息——大量的粗体、字体大小和表格。不幸的是，如果该文档也必须作为 HTML 文档发布到 Web 上，那么就必须有人转换它(手动或通过软件)，清理它，并测试它。然后，如果其他人对原始文档进行了更改，这些更改不会级联到 HTML 版本。如果另一个人想要获取相同的信息并在幻灯片演示中使用它，他们可能会冒使用 HTML 版本中过时信息的风险。即使他们在演示中获得了正确的信息，你仍然需要跟踪你的信息所在的三个位置。正如你所看到的，它会变得相当混乱！

现在，如果同样的信息存储在 XML 中，您可以创建三个不同的 XSLT 文件，将 XML 转换成 HTML、幻灯片演示和便于打印的文件格式，如 PostScript。如果您对 XML 文件进行了更改，那么一旦您将 XML 文件传递到这个过程中，其他文件也会自动更改。(顺便说一句，这个概念是单一来源的基本组成部分，即任何给定的信息都有一个“单一来源”，可以在另一个应用程序中重用。)

正如您所看到的，将信息从表示中分离出来使得 XML 文档可以重用，并且可以在需要存储、处理、操作和交换大量信息的环境中省去麻烦和麻烦。

### **格式良好和有效**

当然，XML 最强大的优势之一是它允许您定义自己的语言。

然而，这个最强大的特性也暴露了 XML 的一个很大的弱点。如果我们所有人都开始定义自己的语言，我们就有可能听不懂别人说的任何话。因此，XML 的创建者必须制定一些描述“合法”XML 文档的规则。

XML 中有两个层次的“合法性”:

*   格式良好
*   有效期

一个*格式良好的* XML 文档遵循这些规则(其中大部分我们已经讨论过了):

*   XML 文档必须包含一个包含所有其他元素的根元素。
*   所有元素必须正确嵌套。
*   所有元素必须以结束标签或“自结束”空元素标签结束(即`*<tag/>*`)。
*   所有属性值都必须用引号括起来。

一个*有效的* XML 文档不仅格式良好，而且遵循该文档的 DTD(文档类型定义)中设定的所有规则。那么，一个有效的文档只不过是一个符合其 DTD 的格式良好的文档。

那么问题就变成了，为什么要有两个层次的合法性？的确是个好问题！

在大多数情况下，您只会关心您的文档是否格式良好。事实上，大多数 XML 解析器(读取 XML 文档的软件)是非验证的(也就是说，它们不关心你的文档是否有效)——这包括在 Firefox 和 Internet Explorer 等 Web 浏览器中发现的那些。格式良好本身就允许您创建可以快速生成、添加到应用程序和测试的特定 XML 文档。

对于其他更关键的应用程序，您可能希望在 XML 文档中使用 DTD，然后通过验证解析器运行这些文档。

底线呢？格式良好是强制性的，但是有效性是一个额外的、可选的步骤。

## 实践中的 XML

现在，当我们讨论名称空间、XHTML、XSLT 和 CSS 时，我们将更深入地研究 XML。我想缩小一点，向您介绍组成 XML“技术家族”的一些古怪的兄弟姐妹。尽管我将在这里列出许多工具和技术，但在本文中我们只涉及其中的一些。

### XSLT

XSLT 代表可扩展样式表语言转换。它既是一种样式表规范，也是一种编程语言，允许您将 XML 文档转换成自己选择的格式:剥离的 ASCII 文本、HTML、RTF，甚至其他 XML 方言。

### **XPath**

XPath 是一种在 XML 文档中定位和处理节点的语言。因为根据定义，每个 XML 文档都是一个层次结构，所以可以用一种逻辑的、正式的方式(即通过一条路径)来导航这个结构。

### DTD 和 XML 模式

文档类型定义(DTD)是一组规则，用于控制元素的使用顺序以及每个元素可以包含的信息种类。XML Schema 是一个较新的标准，其功能远远超出了 dtd。虽然 DTD 只能提供对元素排序和包含的一般控制，但是模式要具体得多。例如，它们可以允许元素只出现一定的次数，或者要求元素包含特定类型的数据，如日期和数字。

这两种技术都允许您为 XML 文档的内容设置规则。如果您需要与另一个组共享 XML 文档，或者您必须依赖于从其他人那里接收格式良好的 XML，这些技术可以帮助确保您的特定规则集得到正确遵循。

### XML 名称空间

XML 允许您定义自己的元素的能力提供了灵活性和范围。但是这也产生了一种很大的可能性，即当组合来自不同来源的 XML 内容时，您将会遇到代码之间的冲突，在这些代码中，相同的元素名称服务于非常不同的目的。例如，如果您在经营一家书店，那么您在 XML 中使用的`<title>`标签可能会被用来跟踪书名。抵押贷款经纪人会以不同的方式使用`<title>`——也许是追踪契约的所有权。牙医或医生可能会使用`<title>`来追踪病人病历上的正式头衔(先生、女士、夫人或医生)。尝试将所有三种类型的信息合并到一个系统中(或者甚至一个文档)，您将很快看到问题是如何出现的。

XML 名称空间试图将相同 XML 元素的不同语义用法保持分离和明确。在我们的例子中，每个人都可以定义自己的名称空间，然后将名称空间的名称添加到特定的标签中:`<book:title>`不同于`<broker:title>`和`<medrec:title>`。顺便说一下，名称空间是使 XSLT 和 XSD 工作的技术之一。

### 可扩展的超文本标记语言

XHTML 代表可扩展超文本标记语言。从技术上来说，它是 HTML 4.01 作为 XML 应用程序的重新表述，并不是 XML 技术家族的一部分。为了避免您的大脑完全崩溃，最简单的方法可能是将 XHTML 视为 HTML 标记的标准，它遵循我们前面讨论过的 XML 的所有格式良好规则。

你可能会问，这有什么意义？嗯，现在有成千上万的网站已经在使用 HTML 了。没有一个头脑正常的人能够合理地期望他们一夜之间全部转向 XML。但是我们*可以*期待这些页面中的一些——以及在你阅读本文时正在编码的大部分新页面——将会由于 XHTML 而实现转变。

正如您所看到的，XML 技术家族是一个相当大的群体——这些 XML 家族的重聚无疑是有趣的！同样重要的是要注意，这些技术是基于开放标准的，这意味着任何新的 XML 技术(或对现有技术提出的更改)都必须遵循 W3C(万维网联盟)制定的公共流程，以便在社区中获得认可。

尽管这意味着一些想法需要相当长的时间才能实现，而且往往是由委员会建立的，但这也意味着没有一个供应商能完全控制 XML。正如玛莎·斯图尔特所说，这是一件好事。

#### 近距离观察 XHTML

XHTML 可以由以下语句定义:

*   XHTML 代表可扩展超文本标记语言。
*   XHTML 旨在取代 HTML。
*   XHTML 使用 HTML 4.01 标记集，但使用 XML 语法规则编写。
*   XHTML 是一个更严格、更简洁的 HTML 版本。

为什么我们需要 XHTML？好吧，坦率地说，当涉及到 HTML 文档时，Web 已经达到了几乎任何东西都会飞起来的地步。看看下面的片段:

```
<html><title>My example</title>  
 <h1>Hello</h1>
```

信不信由你，这段代码可以在大多数浏览器中正常显示。这也是:

```
<p><b><i>Hello</b>
```

这个也是:

```
Hello
```

我不想开始对 HTML 结构进行某种形式的讨伐，但是嘿，够了！网页代表结构化的信息，所以请让我们至少保持一些结构的外观！在最基本的层面上，XHTML 的设计是为了在 HTML 的浮华世界和 XML 的僵化结构之间架起一座桥梁。

还记得我们刚才看到的关于 XHTML 的声明列表吗？嗯，这是考虑 XHTML 的另一种方式:

XHTML 由所有 HTML 4.01 元素和 XML 语法组成。

简单！但是，这到底意味着什么呢？好吧，如果您还记得我们前面谈到的关于格式良好的 XML 文档，您可以做出一些非常好的猜测:

1.  XHTML 文档必须包含一个包含所有其他元素的根元素。(大多数情况下，`html`元素！)
2.  XHTML 元素必须正确嵌套。

```
<p>This is a <b>sentence.</b></p>
```

*   所有 XHTML 元素都必须有结束标记(即使是空的)。

```
<br />   
 <td></td>
```

有三种 XHTML 文档类型:

**严格**

将它与 CSS 一起使用，以最大限度地减少表示混乱。事实上，严格的 DOCTYPE 明确禁止使用 HTML 的表示标签。

```
<!DOCTYPE html  
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"   
    "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

**过渡性**

当你支持非 CSS 浏览器时，使用这个来利用 HTML 的表现特性。

```
<!DOCTYPE html  
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"  
    "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

**框架集**

当您想要使用框架来分割屏幕时，请使用此选项。

```
<!DOCTYPE html  
    PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"  
    "https://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

***极简 XHTML 示例***

这里有一个非常简单的文档来说明上面的规则:

```
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"  
    "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
 <html >  
 <head>  
 <title>A very simple XHTML document</title>  
 <meta http-equiv="content-type"  
    content="text/html; charset=iso-8859-1" />  
 </head>  
 <body>  
 <p>a simple paragraph that contains a properly formatted<br />  
 break and some <b><i>properly nested</i></b> formatting.</p>  
 <div><img src="myphoto.jpg" alt="notice that all my quotes are in  
 place for attribute values" /></div>  
 </body>  
 </html>
```

目前关于 XHTML 的信息已经够多了。让我们继续讨论名称空间和 XSLT。

### XML 名称空间

发明 XML 名称空间是为了解决一个常见的问题:对不同的数据使用相同的元素名称会造成文档冲突。

让我们回顾一下引言中的名称空间示例。假设您正在经营一家书店，有一个库存文件(自然称为`inventory.xml`)，其中使用了一个`title`元素来存储书名。我们还假设——尽管听起来不太可能——您的 XML 文档与抵押贷款经纪人的主记录文件混合在一起。在这个文件中，抵押贷款经纪人使用了`title`来存储一处房产的合法产权信息。

一个人可能会发现一个`title`与另一个没有关系，但是一个试图解决这个问题的应用程序会发疯。我们需要有一种方法来区分这些相同术语存在的两个不同的语义世界。

让我们变得更加模糊:假设您的书店中有一个使用`title`元素存储书名的`inventory.xml`文件，和一个使用`title`元素存储相同信息的单独的`sales.xml`文件，但是在完全不同的上下文中。库存文件存储书架上书籍的信息，但销售文件存储客户已经购买的书籍的信息。

在这两种情况下，不管这些相同术语的上下文之间有什么差异，我们都需要一种方法来正确地标记每个上下文。

名称空间来拯救！XML 名称空间允许您基于 URI(统一资源标识符)创建唯一的名称空间，为该名称空间赋予前缀，并将该前缀应用于 XML 文档元素。

#### **声明名称空间**

要使用和声明名称空间，我们必须首先将名称空间绑定到 URI。请注意，我没有说 URL——您可以到达的特定位置(尽管 URI 可以是 URL)。URI 只是一个唯一的标识符，它将一个事物(比如说，一个 XML 文档标准)与另一个事物区分开来。URIs 可以采取以下形式:

#### 统一资源定位器

统一资源定位符:特定的协议、机器地址和文件路径(例如`http://www.tripledogdaremedia.com/index.php`)。

#### 缸

统一资源名:一个持久化的名称，它不指向资源的实际位置，但仍然唯一地标识它。例如，所有出版的书籍都有 ISBN。ISBN 唯一地标识了这本书，但是在 ISBN 中没有任何地方表明它在任何特定书店的哪个书架上。然而，有了 ISBN，你可以走进书店，让店员帮你找，他们就可以带你找到这本书(当然，前提是这本书有货)。

以下是好的 URIs 的例子:

```
http://www.tripledogdaremedia.com/XML/Namespaces/1  
 urn:bookstore-inventory-namespace
```

但是，我们希望在整个 XML 文档中使用我们的名称空间，我们最不希望做的事情就是在每次需要区分上下文时输入整个 URI。因此，我们定义了一个前缀来表示我们的名称空间，以减轻我们打字时的压力:

```
inv="urn:bookstore-inventory-namespace"
```

但是，等等，我们还没完呢！我们需要一种方法来告诉 XML 解析器我们正在创建一个名称空间。达成一致的方法是给名称空间声明加上前缀`xmlns`:，就像这样:

```
xmlns:inv="urn:bookstore-inventory-namespace"
```

在这一点上，我们有一些有用的东西。如果需要，我们可以在适当的元素中添加前缀来消除歧义(我喜欢这个术语！)任何潜在的模糊用法，如:

```
<inv:title>Build Your Own XML-Powered Web Site</inv:title>  
 <title>Title Deed to the house on 123 Main St., YourTown</title>
```

名称空间非常清楚地表明`<inv:title>`与`<title>`非常不同。

但是，我们将命名空间声明放在哪里呢？

#### **在 XML 文档中放置名称空间声明**

在大多数情况下，放置名称空间声明相当容易。它们通常位于文档的根元素中，如下所示:

```
<inventory xmlns:inv="urn:bookstore-inventory-namespace">  
 ...  
 </inventory>
```

但是，请注意，名称空间有范围。命名空间影响声明它们的元素，以及该元素的所有子元素。事实上，正如您将在稍后讨论 XSLT 时看到的，我们将在定义 XSL 名称空间的元素中使用`xsl`前缀:

```
<xsl:stylesheet  
    xmlns:xsl="https://www.w3.org/1999/XSL/Transform"  

    version="1.0">
```

放在文档根元素中的任何名称空间声明对该文档中的所有元素都可用。但是，如果您想将名称空间的范围限制在文档的某个部分，请随意这样做——当然，要记住这可能会非常棘手。我的建议是在文档的根元素中声明名称空间，然后在需要时使用前缀。

#### **使用默认名称空间**

为文档中的每个元素都键入前缀会变得非常烦人。幸运的是，您可以声明一个不包含前缀的默认名称空间。这个名称空间将应用于所有不包含前缀的元素。

让我们再来看看 XSLT 文件的典型开始`<xsl:stylesheet>`标记:

```
<xsl:stylesheet  
    xmlns:xsl="https://www.w3.org/1999/XSL/Transform"  

    version="1.0">
```

注意无前缀的名称空间: `In an XSLT file, this namespace governs all elements that aren’t specifically prefixed as XSLT elements, identifying them as XHTML tags. On the other side of the coin, all XSLT elements must be given the `xsl:`前缀。`

 `### 使用 XSLT

正如我前面提到的，XSLT 代表可扩展样式表语言转换。可以把它看作是一种工具，可以用来把 XML 文档转换成其他文档。以下是一些可能性:

*   将 XML 转换成 HTML 或原始 ASCII 文本。
*   将 XML 转换成 XML 的其他方言。
*   提取所有标记为西班牙语、法语或德语的段落，创建 XML 文档的外语版本。

还不错——而且我们只是触及了皮毛！

XSLT 是一种基于规则的函数式语言。它不像其他编程语言(如 PHP 或 JSP)那样是过程化的或面向对象的。相反，XSLT 要求您提供一系列规则(称为“模板”)，告诉它在遇到 XML 文档的各种元素时该做什么。

例如，在识别输入文档中的 XML `<para>`标记时，规则可以指示 XSLT 将其转换成 HTML `<p>`标记。

因为 XSLT 即使对于经验丰富的程序员来说也有点令人困惑，所以解决它的最好方法是浏览一系列示例。这样，我可以为您提供入门所需的实用信息，并且您可以在此过程中学习关键概念。和 XHTML 一样，无数的书籍、文章和网站都致力于 XSLT 用这些来继续你的教育。

#### **您的第一次 XSLT 练习**

让我们从 XSLT 开始。在我们的第一个练习中，我们将重用在 CSS 部分看到的非常简单的给母亲写信的例子。我们还将创建一个非常基本的可扩展样式表语言(XSL)文件来转换 XML。保持这两个元素的简单性将使我们有机会逐步了解所涉及的主要概念。

首先，让我们创建 XSL 文件。这个文件将包含我们将 XML 元素转换成原始文本所需的所有指令。

在 XML 世界中，XSL 文件实际上就是 XML 文件，这将成为一个反复出现的主题。因此，它们必须遵循适用于所有 XML 文档的规则:XSL 文件必须包含根元素，所有属性值必须用引号括起来，等等。

所有 XSL 文档都以一个`stylesheet`元素开始。这个元素包含 XSLT 处理器完成工作所需的信息:

**例 2.4。`letter2text.xsl`(节选)**

```
<xsl:stylesheet version="1.0"  
    xmlns:xsl="https://www.w3.org/1999/XSL/Transform">
```

`version`属性是必需的。在大多数情况下，您会使用`1.0`，因为在撰写本文时这是最受广泛支持的版本。

`xmlns:xsl`属性用于声明带有前缀`xsl`的 XML 名称空间。为了让样式表转换工作，必须在开始的`<stylesheet>`标记中为 URI `https://www.w3.org/1999/XSL/Transform`声明一个 XML 名称空间。在我们的例子中，我们将在 XSL 文档中所有与样式表相关的标记上使用一个`xsl`前缀，将它们与这个名称空间关联起来。您会发现这是使用 XSLT 时的常见做法。

下一个元素是`output`元素，用于定义 XSL 文件的输出类型。对于第一个例子，我们将使用`text`作为我们的`method`:

**例 2.5。`letter2text.xsl`(节选)**

```
<xsl:output method="text"/>
```

属性`method`的其他可能值包括`html`和`xml`，但是我们稍后会谈到它们。

现在我们来看 XSLT 的核心——`template`和`apply-templates`元素。这两个因素共同促成了转变的发生。

简单地说，XSLT 处理器(为了我们的直接目的，浏览器)开始读取输入文档，寻找与样式表中的任何`template`元素匹配的元素。当找到一个时，相应的`template`元素的内容告诉处理器在继续搜索之前输出什么。当模板包含一个`apply-templates`元素时，XSLT 处理器将搜索当前元素中包含的*XML 元素，并应用与之相关的模板。*

随着我们的发展，我们会看到一些例外和额外的复杂情况，但现在，这真的是全部了。

我们要做的第一件事是匹配包含文档其余部分的`letter`元素。这相当简单:

**例 2.6。`letter2text.xsl`**
`<xsl:template match="/letter">`(节选)

这个非常简单的 XSLT 批处理简单地声明:“当您在文档的根处遇到一个`letter`元素时，应用与它包含的元素相关联的任何模板。”我们来分析一下。

`<xsl:template>`标签用于创建一个模板，`match`属性指示它应该匹配哪个(哪些)元素。这个属性的值是一个 XPath 表达式(稍后我们将了解更多关于 XPath 的内容)。在这种情况下，`/letter`值表示模板应该匹配文档根处的`letter`元素。如果值仅仅是`letter`，模板将匹配整个文档中的`letter`元素。

现在，这个`<xsl:template>`标签只包含一个`<xsl:apply-templates>`标签，这意味着它本身实际上并不输出任何东西。更确切地说，`<xsl:apply-templates>`标签让处理器寻找其他具有匹配模板的元素。

默认情况下，`apply-templates`不仅匹配元素，还匹配文本，甚至元素之间的空白。XSLT 处理器有一组默认的，或者说是*隐式*模板，其中一个简单地输出它遇到的任何文本或空白。由于我们想忽略出现在`<letter>`内标签之间的任何文本或空白，我们使用`apply-templates`的`select`属性告诉处理器只在搜索中寻找子元素。我们用另一个 XPath 表达式来实现这一点:*表示“当前元素的所有子元素”

现在，我们让处理器寻找`letter`中的元素，所以我们最好给它一些模板来匹配它们！

**例 2.7。`letter2text.xsl`**
`<xsl:template match="to">`(节选)

**到:< xsl:apply-templates/ >**

<template match="”from”"></template>`