# 可靠性陷阱:以太坊的随机数生成

> 原文：<https://www.sitepoint.com/solidity-pitfalls-random-number-generation-for-ethereum/>

*本文是与 [iOlite](https://iolite.io/) 合作创作的。感谢您对使 SitePoint 成为可能的合作伙伴的支持。*

Solidity 是一门相当新的语言，因为没有完美的代码，它包含了与代码相关的问题，以及你想用它完成什么。本文将引导您了解使用随机数作为以太坊智能合约输入时的最佳实践和陷阱。

## 可靠性随机数生成

坚固性不能产生随机数。实际上，创建随机数的每种算法都是伪随机的——没有一种语言能够创建完全随机数。坚固性的问题是复杂的算法代价太大，所以使用更基本的解决方案。除此之外，Solidity 代码应该是确定性的，因为它将在多个节点上运行。我们需要一种算法，能够一次生成一个随机数，并在多个节点上使用它。像时钟时间这样的东西不可用于生成随机数，所以我们必须考虑其他选项。作为开发人员，您应该意识到这个问题，因为攻击者能够预测某些特定情况下的结果。

最常用的算法之一是“线性同余生成器”(LCG)。这是最古老的算法之一，快速，容易理解。对于嵌入式系统来说，LCG 是一个很好的选择，因为它们的内存有限。但是，它不太适合加密安全的应用程序。尽管如此，这仍然在智能合同中使用，因为就天然气成本而言，快速算法的实施要便宜得多。

算法本身执行这些步骤:

*   接受输入
*   对输入执行算法
*   取输出模数(除以所需范围内的最大值)
*   在您要求的范围内输出 0 到最大数量

让我们以彩票智能合约为例，探索创建随机数的不同方式。用户能够通过向合同发送 0.1 以太以及 0 到 250 之间的整数来加入抽奖。

## 1.块.时间戳和块.难度

每当矿工确认交易时，他就分配一个`block.timestamp`。我们的彩票合同中没有玩家能够控制它。让我们来看看这段创建随机数的代码。

```
function random() private view returns (uint8) {
  return uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);
} 
```

*[在这里找到要旨](https://gist.github.com/michielmulders/b14d795a1d2c38af1133ea546fc641bc)。*

这段代码首先散列块时间戳和难度。接下来，我们将哈希转换为整数，然后除以 251，得到一个介于 0 和 250 之间的整数。然而，这段代码的问题是，我们不应该相信一个矿工挑选赢家。

## 2.彩票输入–任意数据

我们需要更多的任意数据来选出我们的获胜者。我们可以使用已经进入我们的彩票智能合同的玩家的地址，但是我们必须对其他玩家隐藏它，因为他们可以滥用它。隐藏这些信息是不可能的，因为它们都记录在区块链上。

提交给我们彩票智能合约的数字可以使用。用户必须将他们挑选的数字和他们的以太坊地址一起散列。这给了我们一个非常随机的数字。

## 3.VRF 链连结

尽管如此，随机性是可以实现的，但是你只需要使用一个 [oracle](https://medium.com/better-programming/what-is-a-blockchain-oracle-f5ccab8dbd72) 从区块链之外获得一个随机数。处理外部数据的问题是，很难证明这个数字实际上是随机的，也很难确保实体链外没有以任何方式操纵随机数。这就是链环 VRF 发挥作用的地方。链环 VRF(可验证的随机函数)是我们如何能够[得到可靠的可验证的随机数](https://blog.chain.link/random-number-generation-solidity/)。

Chainlink VRF 向区块链添加一个事件，Chainlink 节点从中读取，并返回一个随机数。有一个链上的随机性检查，通过所谓的 VRF 协调器发生。这使用了来自 oracle 的特定密钥散列和来自用户的种子短语，并混合了一些加密技术，以确保数字是真正随机的。这样，我们可以得到一个无偏的随机数。

## 4.其他机制

### 4.1 以太坊闹钟

开发者需要考虑什么时候选择赢家。像时钟时间这样的东西在以太坊虚拟机中是不可用的，因为代码将在不同的时间在多个节点上运行。这使得挑选赢家变得更加困难。一种方法是在你的智能合同中实现一个功能，关闭彩票并选出一个赢家。这并不像我们希望的那样分散。当合同的所有者确信他们的一个朋友会中奖时，他可以停止抽奖。我们想避免这种欺骗。

更好的选择是使用以太坊闹钟。这是一项服务，允许安排交易在稍后的时间在以太坊区块链上执行。这个服务是完全不可信的，这意味着整个服务作为一个智能契约运行。基本上，以太坊闹钟是使用块号来安排交易。注意了，不代表契约自己醒了。它依赖于用户对调用“挑选赢家”功能有兴趣(或奖励)。当然，如果没人调用你的函数，你的抽奖就失败了。

### 4.2 随机数据输入

Random.org 提供了一个 API，通过 JSON 给你一个随机的数据源。以太坊智能合约可以使用这种数据源为算法提供一个随机数。由于安全性很重要，所以可以使用数字签名。随机数据将由 Random.org 签名。你可以验证数据的完整性，这样你就可以证明它确实来自 Random.org，数据没有被篡改。

RANDAO 是区块链领域的一个新项目，专门致力于提供随机数。他们结合使用神谕和智能契约来为你提供随机数。然而，目前 RANDAO 服务非常慢。如果您有一个经常使用的应用程序，这并不理想。

### 4.3 块号监视器

您还可以在代码中使用观察器，它会检查块号，直到它与您设置的目标号匹配。

```
function f( blocknumber, to_address, value_) { 
  var filter = web3.eth.filter('latest').watch(
    function(err, blockHash) { 

      var target=blocknumber; 

      if(web3.eth.blockNumber==target) { 
        filter.stopWatching(); // your function here 
        web3.eth.sendTransaction({to:to_address, from:web3.eth.coinbase, value: web3.toWei(value_,"ether")});
        filter = null; 

        console.warn('Block reached'); 

        if (callback) return callback(false);
        else return false;

      } else { 
        console.log('Waiting the block'); 
      } 
  }); 
}; 
```

*[来源](https://ethereum.stackexchange.com/questions/16464/how-to-schedule-a-transaction)[要诀](https://gist.github.com/michielmulders/6309835482c67b27c94f0a5205749057)。*

### 4.4 iOlite 智能合同创建

iOlite 正在开发一种产品，它接受自然语言来创建智能合同。它使用的是斯坦福自然语言处理(NLP)引擎，称为快速适应引擎(FAE)。iOlite 依靠固体专家的社区培训。Solidity 专家(贡献者)可以定义包含一个或多个句子的结构，并将其附加到相应的智能合同代码。

斯坦福大学的自然语言处理引擎是用来理解复杂语言的。语言的复杂程度取决于机器训练的数量。经过适当的培训后，该引擎将能够创建复杂的智能合同。FAE 有能力创建这样的合同，因为一个复杂的合同实际上并不复杂。专家可以将请求拆分成多个较小的代码片段，并将其附加到一个句子中。

当有人输入多个句子时，它会寻找相应的结构/句子来构建“复杂”契约。贡献者将通过新建筑的开采过程获得堇青石令牌。

使用 iOlite 的好处是，智能合约专家可以为您解决类似随机数生成这样的难题。你可以在 [iOlite.io](https://iolite.io/) 找到更多信息。

## 结论

如您所见，生成真正的随机输入并不容易。不要依赖`block.timestamp`、`now`和`block.blockhash`作为随机性的来源。一个好的解决方案包括几个伪随机数据输入的组合，并使用 oracles 或智能合约使其更加可靠。你需要 100%确定没有人能够篡改输入到你的智能合同中的数据。

在实现随机数生成逻辑之前，要小心谨慎，三思而后行。

## 分享这篇文章