# CSS 和 Sass 精确的故事

> 原文:[https://www.sitepoint.com/a-tale-of-css-and-sass-precision/](https://www.sitepoint.com/a-tale-of-css-and-sass-precision/)

![Various browsers as totems looking at a mysterious percentage sign](../Images/667c9e74e05c303396ba3ea92e16916b.png)

SitePoint/ [Natalia Balska 的作品](http://sf-lab.net/)

在 Edenspiekermann ，我们非常依赖代码审查来确保我们提交的工作足够好。我经常遇到的一件事是数字的模糊性，尤其是那些有小数点的数字。因此，这里有一篇短文来阐明这个问题。

## 初始设置

为了在开始之前使整个解释更加清晰，我们将研究一小段恰好与我们的案例非常相关的代码。

```
.list-item {
  float: left;
  width: 33%;
} 
```

## 有什么问题？

也许您想知道这个代码片段有什么问题。从外表上看，并不多。它是三列网格布局。你可以说很平常。

虽然，33% + 33% + 33%等于 99%，而不是 100%。虽然在大多数情况下可能不会有什么不同，但在直线上工作时，1%可能会有很大的不同。一个`1400px`大集装箱的 1%是`14px`。那是一段相当长的距离。

为什么我们不移动小数点(或者说添加小数点)来使它更精确呢？我们可能会把差距缩小到`1.4px`，或者甚至是`0.14px`，我想这已经不值得再烦恼了！让我们从那个开始吧。

```
.list-item {
  float: left;
  width: 33.33%;
} 
```

这样效果更好，但仍不完美。这个问题已经在约翰·阿尔宾·威尔金斯题为“响应式设计的肮脏小秘密”的文章中进行了广泛的讨论。如果你没读过，那就去读吧。

## 浏览器不能处理这个吗？

此时，您可能想知道为什么浏览器不能让它正常工作。问题是，CSS 规范没有向浏览器供应商说明在百分比数字的精度浮动的情况下应该做什么(具有讽刺意味)。当 CSS 规范忽略了一个细节时，你可以肯定每个浏览器都会以自己的方式去做。

以上述文章中的这个例子为例:

> […]对于 6 列网格，每列的宽度为 100% ÷ 6 = 16.666667%。在一个 1000 像素宽的视口中(我方便地选择了这个视口以使我们的数学更简单)，每列计算为 166.66667 像素。由于规范没有给出指导方针，浏览器供应商可以自由制定自己的规则。如果浏览器四舍五入到最近的像素，在我们的例子中，我们会得到 167 像素。但是由于 167 x 6 = 1002 像素，我们在我们的视窗中不再有空间容纳所有的 6 列。或者，如果浏览器每列向下舍入到 166 像素，我们将缺少 4 个像素来将所有列完美地放入我们的视口。约翰·阿尔宾·威尔金斯

事情就是这样。旧版本的 Internet Explorer(主要是 6 和 7)四舍五入到最接近的整数，导致布局破坏。WebKit 浏览器向下舍入，这防止了任何灾难性的布局结果，但给我们留下了额外的空间。Opera(至少在其旧的渲染引擎中)正在做一些奇怪的事情，我甚至懒得解释。但是，同样，规范中没有关于这种行为的规则，所以谁该负责呢？肯定不是浏览器求助于[子像素着色](https://en.wikipedia.org/wiki/Subpixel_rendering)，因为最终这才是最好的结果。

无论如何，这是相当混乱的，我们将在本文的结论中回到这一点。

## 萨斯呢？

Sass 支持数学运算。这并不新鲜，实际上是 Sass 最初被用于的几件事情之一(构建基于数学的网格系统)。我们可以做的是告诉 Sass，我们想把容器的宽度分成 3 等份。

```
.list-item {
  float: left;
  width: (100% / 3);
} 
```

我们也可以使用 [`percentage(..)`函数](http://sass-lang.com/documentation/Sass/Script/Functions.html#percentage-instance_method)来获得相同的结果:

```
.list-item {
  float: left;
  width: percentage(1 / 3);
} 
```

在 Ruby 和 LibSass 中，Sass 的精度选项[为 5。](http://sass-lang.com/documentation/Sass/Script/Number.html#precision-class_method)[这其实是个问题](https://github.com/sass/sass/issues/1122)因为它相当低；10 会更好，但这不是默认的(虽然可以配置，但不容易)。

这段代码将生成以下 CSS:

```
.list-item {
  float: left;
  width: 33.33333%;
} 
```

这并没有解决我们的浏览器问题，但确实使编写样式表更容易了。我们不仅不必自己处理计算和精度，而且通过实际显示计算结果，使代码更便于阅读和更新。

我认为这是一件好事。

## 两全其美

到目前为止，我们已经了解到让 Sass 为我们处理计算比硬编码值更好。现在，最好的方法是让浏览器以最好的方式处理这个问题。为此，有了`calc(..)` CSS 函数。

```
.list-item {
  float: left;
  width: calc(100% / 3);
} 
```

这段代码没有被编译成任何东西。它会在创作时点击浏览器。然后，就看浏览器如何充分利用它了。我将完全诚实地告诉你，我不确定浏览器是否和普通浏览器一样处理`calc(..)`值。我想他们会进行计算，然后进行舍入。一些浏览器似乎将子像素着色带入了等式中。如果你对此有任何见解，请在评论中分享。

对于不支持`calc(..)`表达式的[浏览器，主要是 Internet Explorer 8 和 Opera Mini，我们可以在它前面放一个表示为 Sass 操作的静态值。这样，我们可以两全其美。](http://caniuse.com/#search=calc)

```
.list-item {
  float: left;
  width: (100% / 3);
  width: calc(100% / 3);
} 
```

## 结论

让我们来回顾一下。对于初学者来说，基于百分比的布局很难处理，因为浏览器不一致，并且在浮点精度方面缺乏规范。

然后，硬编码由某种复杂计算产生的值通常不是一个好主意。我们可以让 Sass 计算一个近似值(到浮点后的 5 位数)。

更好的是，我们可以让浏览器计算一个近似值。在一个完美的世界中，当浏览器同时负责数学和渲染时，它应该能够充分利用它。为了朝着这个方向前进，我们依赖于`calc(..)`函数。

这差不多就是现在的情况。没什么新东西，但我想快速回顾一下会有帮助！

## 分享这篇文章