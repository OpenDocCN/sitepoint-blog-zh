# 使用正则表达式的 3 个巧妙技巧

> 原文：<https://www.sitepoint.com/3-neat-tricks-with-regular-expressions/>

我将向您展示使用[正则表达式](https://www.sitepoint.com/learn-regex/)可以做的三件巧妙的事情，它们为一些非常棘手的问题提供了简洁的解决方案:

1.  [删除注释](#removing-comments)
2.  [使用替换回调](#using-replacement-callbacks)
3.  [使用不可见分隔符](#working-with-invisible-delimiters)

## 1.删除注释

正则表达式使**单字符分隔符**变得简单，这就是为什么从字符串中移除标记如此容易:

```
str = str.replace(/(<[\/]?[^>]+>)/g, '');
```

真正起作用的是角色类中的否定:

```
[^>]
```

意思是*“除了`<`”*之外的任何东西。因此，表达式查找起始标记分隔符和可能的斜杠，然后是除结束标记分隔符之外的任何内容，最后是分隔符本身。简单。

然而注释并不简单，因为注释分隔符由不止一个字符组成**。例如， <abbr title="Cascading Style Sheets">CSS</abbr> 和 JavaScript 中的多行注释以`/*`开始，以`*/`结束，但是在这两个分隔符之间可以有任意数量的不相关的星号**。

我经常在注释中使用多颗星来表示我刚刚注意到的错误的严重性，例如:

```
/*** this is a bug with 3-star severity ***/
```

但是如果我们试图用一个否定字符来解析它，就会失败:

```
str = str.replace(/(\/\*[^\*]+\*\/)/g, '');
```

然而正则表达式不可能说:*“除了[这个字符序列]以外的任何东西”*，我们只能说:*“除了[这些单个字符中的一个]以外的任何东西”*。

因此，下面是我们需要的正则表达式:

```
str = str.replace(/(\/\*([^*]|(\*+[^*\/]))*\*+\/)/gm, '');
```

该表达式通过**查看后面的内容来处理不相关的字符**——只要星号后面没有斜杠，就允许使用星号，直到我们找到一个斜杠，这就是注释的结尾。

所以它说:“`/`然后`*`(然后除了`*`之外的任何东西或者任何数量的`*`后跟除了`/`之外的任何东西)(以及任何数量的实例)，然后任何数量的`*`，然后【T6”)。

(语法看起来特别复杂，因为`*`和`/`都是正则表达式中的特殊字符，所以必须对不明确的字面字符进行转义。还要注意表达式末尾的`m`标志，它意味着**多行**，并指定正则表达式应该搜索多行文本。)

使用同样的原理，我们可以修改表达式来搜索任何类型的复杂分隔符。下面是另一个匹配 <abbr title="HyperText Markup Language">HTML</abbr> 评论的:

```
str = str.replace(/(<!\-\-([^\-]|(\-+[^>]))*\-+>)/gm, '');
```

这里有一个用于`CDATA`部分:

```
str = str.replace(/(<\!\[CDATA\[([^\]]|(\]+[^>]))*\]+>)/gm, '');
```

## 2.使用替换回调

`replace`函数也可以被**传递一个回调**作为它的第二个参数，这在你想要的替换不能用简单的表达式描述的情况下是非常宝贵的。例如:

```
isocode = isocode.replace(/^([a-z]+)(\-[a-z]+)?$/i, 
  function(match, lang, country)
  {
    return lang.toLowerCase() 
      + (country ? country.toUpperCase() : '');
  });
```

这个例子规范了语言代码的大写——所以`"EN"`会变成`"en"`，而`"en-us"`会变成`"en-US"`。

传递给回调函数的第一个参数总是完全匹配的，然后每个后续的参数都对应于反向引用(例如，`arguments[1]`是字符串替换所指的`$1`，依此类推)。

所以把`"en-us"`作为输入，我们会得到三个参数:

0.  `"en-us"`
1.  `"en"`
2.  `"-us"`

然后，该函数所要做的就是执行适当的案例，重新组合各个部分并返回它们。回调返回的内容就是替换本身返回的内容。

但是我们实际上并不需要分配返回值(或者根本不需要返回)，如果我们不这样做，那么原始字符串将不会受到影响。这意味着我们可以将`replace`用作**通用字符串处理器**——在不改变字符串的情况下从字符串中提取数据。

下面是另一个例子，它将上一节中的多行注释表达式与一个提取并保存每个注释文本的回调函数结合起来:

```
var comments = [];
str.replace(/(\/\*([^*]|(\*+[^*\/]))*\*+\/)/gm, 
  function(match)
  {
    comments.push(match);
  });
```

因为没有返回任何内容，所以原始字符串保持不变。尽管如果我们想要提取*并*移除注释，我们可以简单地返回并分配一个空字符串:

```
var comments = [];
str = str.replace(/(\/\*([^*]|(\*+[^*\/]))*\*+\/)/gm, 
  function(match)
  {
    comments.push(match);
    return '';
  });
```

## 3.使用不可见的分隔符

当使用标准分隔符时，提取内容是很好的，但是如果你使用只有你的程序知道的自定义分隔符呢？问题是**字符串可能已经包含了你的分隔符**，字面意思是一个字符接一个字符，然后你该怎么办？

嗯，最近我想出了一个非常可爱的小技巧，它不仅避免了这个问题，而且使用起来就像我们一开始看到的单字符类一样简单！诀窍是使用文档不能包含的 **unicode 字符。**

最初，我用未定义的字符尝试了这种方法，这当然有效，但是假设任何这样的字符总是未定义的是不安全的(或者文档不会包含它)。然后我发现 Unicode 实际上专门为这类事情保留了一组代码点——所谓的[非字符](http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters "Mapping of Unicode Characters (wikipedia.org)")，它永远不会被用来定义实际的字符。有效的 Unicode 文档不允许包含非字符，但是程序可以出于自己的目的在内部使用它们。

我正在使用 <abbr title="Cascading Style Sheets">CSS</abbr> 处理器，我需要在解析选择器之前删除所有的注释，这样它们就不会混淆匹配选择器的表达式。但是它们必须在源代码中被替换为占用相同行数的内容，这样行号才能保持准确。然后，为了最终输出，它们必须被添加回源中。

所以首先我们使用一个 regex 回调来提取和保存注释。回调函数返回匹配项的副本，其中所有非空格都被转换为空格，并且两边都用非字符分隔:

```
var comments = [];
csstext = csstext.replace(/(\/\*([^*]|(\*+([^*\/])))*\*+\/)/gm, 
  function(match)
  {
    comments.push(match);
    return '\ufddf' + match.replace(/[\S]/gim, ' ') + '\ufddf';
  });
```

这就创建了一个注释数组，其源代码顺序与它们留下的空格顺序相同，而空格本身占用了与原始注释一样多的行。

然后，只需将每个分隔的空格替换为相应的已保存注释，就可以恢复原来的格式——由于分隔符是单个字符，我们只需要一个简单的字符类来匹配每一对:

```
csstext = csstext.replace(/(\ufddf[^\ufddf]+\ufddf)/gim, 
  function()
  {
    return comments.shift();
  });
```

这多容易啊！

## 分享这篇文章