# 面向小人物的 SOA

> 原文:[https://www.sitepoint.com/soa-for-the-little-guys/](https://www.sitepoint.com/soa-for-the-little-guys/)

SOA，或者说面向服务的架构，经常被认为是一个企业专有的术语，被不小于 Amazon 的公司使用。不要害怕，SOA 也可以被小家伙们使用！让我们打破常规。

任何 SOA 实现的目标都是按照逻辑和业务功能对应用程序进行分段。它可以将单一的应用程序分解成许多更小的、可消费的服务。小家伙们可以使用 SOA，但是在经历成长的烦恼之前，你通常不会想应用它。什么时候应该使用 SOA 没有现成的答案，但是数据库效率低下、团队可伸缩性问题、部署困难和难以管理的复杂性都是关键指标。较小的团队可能希望使用 SOA，希望更容易维护、更快迭代、更健壮的测试和可伸缩性。

在这篇文章中，我想先介绍一下大多数 monolithic Rails 应用程序的架构，将其与面向服务的架构进行比较，然后用 [Sinatra](http://www.sinatrarb.com/) 、 [Redis](http://redis.io/) 和 [RSpec](https://github.com/rspec/rspec) 实现一个非常基本的服务。为了演示 SOA，我们将重点介绍一个(虚构的)音乐应用程序，它将世界各地具有相似音乐兴趣的人联系在一起。

## 典型的 Rails 应用程序

典型的 Rails 应用严重依赖于一个数据库。通常，我们将所有的原始数据塞进数据库，并在上面构建 MVC 栈。这些应用具有以下架构:

![](../Images/7603d02a4186cb58fd8c2e7ea364996d.png)

Rails Monolith 应用程序

随着应用程序的发展，这种结构非常有效，但它有许多长期问题:

*   数据库效率低下。不幸的是，我们喜欢的数据库无法扩展。一个表中的数百万行会给数据库带来巨大的负担，尤其是当数据被连接、操作和混淆时。因此，我们要么优化我们的查询，要么采用新技术来缓存计算值，或者提供新的数据接口(例如 MapReduce)。我们正在修补问题。
*   团队可扩展性。在一个模型上工作经常会破坏其他模型。太多的团队在同一个代码库上工作，这样做有副作用。应用程序之间没有关注点的分离；都是一个回购。
*   部署。当进行小的更改时，您正在重新部署整个应用程序，这可能需要停机。
*   复杂。由于数据是如此紧密地缠绕在一起，团队中的每个新开发人员都必须学习整个系统。找到开发者变得越来越难，系统也变得更加难以理解。

## SOA 方法

面向服务的架构试图缓解整体式 Rails 应用程序的问题。在创建新的应用程序时跳入 SOA 是不明智的，因为架构的本质经常会增加不必要的复杂性。它通常是游戏中的后期玩家，当 Rails 应用程序变得太大时会变得有用。目标是获得一个大型应用程序，并通过将它的逻辑组件分解成单独的服务来恢复它。每个服务都可以被原子地依赖来为其各自的域执行一组任务。与单片 Rails 架构相比，SOA 应用程序可能是这样的:

![](../Images/3185b6ea042ca0eec29966fafd5aaa56.png)

SOA App

每个服务都有自己的数据库、自己的域逻辑和自己的 HTTP 接口。上图显示了三种不同的服务。然后，这些服务被组合到为最终用户服务的**高级应用**中。一部分领域逻辑仍然存在于**高层应用**中，但是大部分已经被抽象成服务。**高级应用程序的**主要工作是将来自服务的数据连接成可以呈现给用户的东西。

将应用程序重构为服务可以提供一些改进:

*   数据库更小。每个服务都可以选择适合其需求的数据存储。通常，服务数据是原始数据的子集，存储在关系数据库中。但是，如果服务将经历高读写，那么像 Redis 这样的内存存储可能会提供更快的结果。无论使用哪种数据存储，数据的复杂性都会降低。
*   团队现在可以独立工作。每个服务成为它自己的可部署应用。这意味着每个团队可以被分配一个单独的服务，并维护他们的代码库，而不会干扰相邻的团队。
*   每个代码库都可以单独部署。只要 HTTP 接口保持不变，就可以快速部署服务，而不会影响应用程序的其余部分。
*   复杂性已经被分解了。每个服务都是一种定义良好的、简单的方式来访问特定领域的数据和逻辑。新开发人员可以在一个服务上工作，而不需要了解其他服务。他们也可以更快地熟悉代码库。

## 定义服务

让我们看看如何将社交音乐应用程序分解为服务。该应用程序的目标是让用户能够找到世界各地有相似音乐兴趣的人。这个社交应用程序从 [Last.fm](http://www.last.fm/api) 中拉出艺术家，允许用户表达对艺术家的兴趣，并提供喜欢相同音乐的用户列表。

我想到的第一个问题是，“如何将我的应用程序分解成服务？”当然，这取决于所讨论的应用程序，但是有一些关键的指导原则要遵循，并且手头有一些选项。

首先，考虑围绕逻辑功能构建服务。上面已经对音乐应用的核心功能进行了分解:从 Last.fm 获取(艺人服务)，跟踪用户对艺人的兴趣(兴趣服务)，管理用户(用户服务)。

接下来，考虑应用程序的变化。一般来说，您希望您的服务随着时间的推移保持稳定，因此最好将经常变化的功能保持在与服务本身分离的**高级应用**中。

考虑数据类型和读/写操作的频率。单个服务可以针对其中一个或另一个进行优化，或者同时针对两者进行优化。注册对艺术家的兴趣是一个高写函数，聚集相似用户是一个高读函数，这两个函数都存在于兴趣服务中。

考虑数据连接的频率。如果数据被频繁连接，那么这些数据可能应该驻留在同一个服务中，并在数据库中处理。如果数据是稀疏连接的，它可以分布在多个服务中，并在**高级应用**中与 Ruby 连接。

对于这个例子，我们将定义三个服务，其中一个我们将实现:艺术家服务、用户服务和兴趣服务。我们将跳过用户和艺术家服务，直接实现兴趣服务。以下是每项服务的工作原理:

*   艺术家服务主要由一个后台工作人员来轮询 Last.fm 的数据。艺术家服务将艺术家的名字和他们的流派存储在一个关系数据库中。
*   用户服务使用关系数据库和典型的用户模型。该服务为用户提供 CRUD 和认证操作。
*   兴趣服务提供了一个界面来注册特定用户对艺术家的兴趣。给定一个用户，它也提供一组具有相似兴趣用户。为了提供这个集合，我们将把艺术家和用户之间的连接存储在一个 [Redis 集合](http://redis.io/topics/data-types#sets)中。Redis 集为我们提供了很高的读/写能力，以及在许多用户的音乐兴趣之间寻找交集的能力。

## 测试兴趣服务

首先编写测试有助于定义您的 HTTP 服务对外界的外观。它也是任何 SOA 实现中最关键的测试组件。不要向服务发送存根或伪造的请求，测试真实的请求。此时，我们假设用户和艺术家服务都已经实现。让我们使用 RSpec 为兴趣服务编写一些测试。

**spec/interest_spec.rb**