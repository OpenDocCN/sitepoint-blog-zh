# C 语言中的运算符

> 原文：<https://www.sitepoint.com/operators-in-c/>

继续我上一篇关于 C 的[基础的文章，我们现在来看看操作符。](https://www.sitepoint.com/fundamentals-of-c/ "Fundamentals of C")

一个*表达式*是计算一个值的一系列操作符和操作数。C 语言中的运算符是一个符号，它告诉计算机对数据进行数学或逻辑操作。运算符所作用的数据项称为操作数。

C 支持的不同运算符有:

1.后缀运算符

2.一元运算符

3.强制转换运算符

4.乘法运算符

5.加法运算符

6.按位移位运算符

7.关系运算符

8.等式运算符

9.按位 AND 运算符

10.按位异或运算符

11.按位异或运算符

12.逻辑 AND 运算符

13.逻辑或运算符

14.条件运算符

15.赋值运算符

16.逗号运算符

## 后缀运算符

当操作符跟在操作数后面时，该操作符称为*后缀操作符*。后缀运算符可以对一个或两个运算符进行运算。C #中有五个后缀运算符:-

1.数组下标

2.函数调用

3.结构和工会成员

4.后缀递增和递减运算符

5.复合文字

### 1。数组下标

在上一篇文章中，我们已经将数组定义为一个标识符，它引用具有相同名称和相同数据类型的数据项集合。每个数据项由它们的 ***数组元素表示。*** 单个数组元素通过它们的 ***下标相互区分。***

后缀表达式(操作数后跟运算符)后跟方括号[ ]中的表达式是数组元素的下标名称。**数组下标运算符[ ]** 的定义是，如果 **a** 是一个**数组**且 **i** 是一个**整数则**。

如果将**数组下标操作符[ ]** 应用于维度为 n > =2 的 **n 维**数组 **x** ，则`x`被转换为指向(n-1)维数组的指针。通过应用间接运算符*来访问单个数组元素。

为了理解上面的定义，需要理解指针的概念以及数组和指针之间的关系。

数组名总是存储数组第一个元素的地址。例如，如果`x[10] `是一个整数数组，那么`x` 存储第一个元素 `x[0]`的地址。由于`x`是一个整型数组，数组的每个元素将占用 2 个字节。因此，可以根据第一个元素的地址加上**偏移量**来访问数组的每个元素。这里的**偏移量**是数组的数据类型占用的**下标*内存。**因此，第二个元素`x[1] `将位于距第一个元素 2 个字节的偏移量处，第三个元素`x[2]` 位于距第一个元素 4 个字节的偏移量处。

**指针**是存储另一个变量地址的变量。在这些术语中，数组被称为**自引用指针**，因为它存储自己的地址，即第一个元素的地址。因此，数组的每个元素都可以用指针(数组名)和偏移量(下标)来表示。所以`x[1] `可以简称为`x+1`，`x[2]` 可以简称为`x+2` 等等。下标的值决定了内存需求必须被添加到初始地址的次数，以获得下标元素的位置。这意味着对于整数数组`x`，需要找到第三个元素`x[2]`的地址，并将内存需求(2 字节)两次添加到初始地址。类似地，`x[3]`的地址将通过向初始地址添加 2 个字节三次来找到。

要找到数组元素的实际值，需要使用**间接操作符*** 。因此，如果`x+2` 表示第三个元素的存储地址，`*(x+2)` 将表示第二个元素的值，即存储在数组中的第二个元素的实际值。

如果一维数组可以用指针(数组名)和偏移量(下标)来表示，那么多维数组也可以用类似的术语来表示。因此，二维整数数组`x[2][3]` 实际上是两个一维数组的集合，每个一维数组包含三个数据项。这个二维数组可以定义为*一个指向一组一维数组的指针，*其中`*x`存储(即它指向)第一个包含 3 个元素的数组的地址，`*(x+1)`存储第二个包含 3 个元素的数组的地址，依此类推。由于每一行都是一维数组，`*(x)`存储第一行第一个元素的地址， `*(x+1)`存储第二行第一个元素的地址。

在具有两个以上维度的多维数组的情况下， `*(x)`或`*(x+1)`将不会存储每行的第一个元素的地址。相反，它们将各自存储多维数组的初始地址。当我们在后面的文章中更详细地讨论数组和指针时，会有更多的内容。

在一个数组`x[i][j]`，`x[i]`等于`*(x+i)`，x 首先被转换成一个指针，存储第一个数组 `j`元素的初始地址，`*(x+1)`存储第二个数组的初始地址，以此类推。现在， `i`的值定义了偏移量，根据定义，偏移量是内存需求的*下标值。这里的内存需求是 `j`元素数组的大小。考虑到我们的例子`x[2][3]`，内存需求是一个单独的数组的大小，每个数组包含三个整数。如果`*x`指向第一个三个整数的数组的初始地址，`*(x+1)`将存储第二个三个整数的数组的初始地址，该地址将位于距第一个数组的初始地址 3*2=6 字节处。因此，多维数组是按行主顺序存储的。

例如:让`x[2][3]= {{5,6,8}, {2,4,7}}`

然后`* x` 存储第一行的初始地址，即{5，6，8}的地址

`*(x+1)`存储第二行{2，4，7}的初始地址

现在每行会占用 6 个字节，所以如果`*x `(即第一行的地址)的初始地址是 1182

那么第二行的地址就是 1182+6 = 1188；ie *(x+1) = 1188

现在，要访问单个元素，应用间接操作符，例如:第一行的第二个元素将位于`(*(x+0)+1)` =1182+1*2 字节= 1184

`*(x+0)`存储第一行第一个元素的地址，然后`*(x+0)[0]= x[0][0]=5`

由于下标给出了偏移量，那么`*(x+0)[0]= *(*(x+0)+0)=x[0][0]=5`

因此，`*(*(x+0)+0)`会给出第一行的第一个元素。

类似地`x[0][1] =*(*(x+0)+1*2bytes))=6`

数组和指针在很多方面是等价的。在这里，我们看数组和指针的基本概念，以便理解数组下标操作符。一旦我们详细讨论数组和指针，数组下标操作符就会变得完全清楚。

### 2。函数调用 

在我之前的帖子[C 语言简介](https://www.sitepoint.com/an-introduction-to-c/ "Introduction to C")中，我给出了一个函数的例子，并介绍了函数原型、函数标题、返回类型和参数的概念。回忆这些概念有助于理解**函数调用操作符()**。

后缀表达式后跟包含逗号分隔的参数或根本没有参数的括号，称为函数调用。后缀表达式表示被调用的函数。

函数的返回类型可以是函数、指针或前面讨论过的任何数据类型。如果函数的返回类型是指针，那么函数返回一个地址。

函数参数是在函数调用的括号中使用的表达式。函数参数是在函数声明或定义的括号内声明的对象。当您调用函数时，会对参数进行求值，并且每个参数都用相应参数的值进行初始化，初始化的顺序是参数在函数调用中出现的顺序。

**自变量的类型转换**

作为数组或函数的参数在作为函数参数传递之前被转换为指针。

传递给非原型 C 函数的参数经历转换:类型`char`参数被转换为`int`，而`float`参数被转换为`double`。这些被称为**默认论点促销。**

编译器将调用函数提供的数据类型与被调用函数期望的数据类型进行比较，并执行必要的类型转换，因此，如果被调用函数不包含原型，则函数的实参被隐式转换为函数形参的类型。

如果函数没有原型，除了上面提到的类型，没有其他类型的参数被隐式转换。如果被调用函数没有函数原型声明符，则不将参数的数量和类型与被调用函数的参数进行比较。

如果函数定义的返回类型与实际返回的值不兼容，您可能会得到一个错误或未定义的程序行为。例如，`char`和`int `兼容，但是`char`和`float`不兼容。如果一个函数的返回类型被声明为`char`，但是它返回一个浮点数，程序会给出一个错误。

为了理解上述要点，请考虑以下示例:

```
/*program to calculate the area of a circle using a user-defined function*/

#include <stdio.h>

#define PI 3.14159

int main()

    {

      float area,radius;

      printf("n Enter the radius:");

      scanf("%f", &radius);

      area= process(radius); //process(radius) is a function call

      printf("Area =%f", area);

      return 0;

     }

float process( float r)// function  expects a float argument

     {

     float a; /*local variable declaration*/

     a= PI*r*r;
     return(a); //function returns value.

     }
```

如果在上面的程序中缺少函数原型，并且如果函数期望类型为`double`的值，并且传递的半径值是类型为`float`的，那么传递的半径值将被隐式地转换为类型`double`。

此外，如果函数被声明为类型`void`，并且您将通过 return 语句返回值，则会出现类型兼容性错误。

理解函数的工作还有很多，但是我们将在以后关于函数的文章中讨论它们。请关注即将发表的一篇文章，这篇文章将继续研究 c 语言中的操作符。

## 分享这篇文章