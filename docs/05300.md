# 用 Ruby 进行动态编程

> 原文:[https://www.sitepoint.com/dynamic-programming-ruby/](https://www.sitepoint.com/dynamic-programming-ruby/)

算法研究是计算机科学研究和教育的基石。然而，在我们以网络为中心的社区中，ruby 爱好者通常不知道常见的算法技术。

本文将通过探索两个不同的问题并给出 Ruby 中的解决方案，让您体验一种称为“动态编程”的常见算法设计技术。事实证明，动态编程实际上是一种非常通用的方法，可以应用于许多学科中的各种问题。

一个警告:如果这是你第一次接触带有数学味道的算法，可能会有点困难。但是，我强烈鼓励你坚持下去！一旦它“咔嚓”一声，你会得到的感觉棒极了。如果你有任何问题，请在下面的评论中提出。

让我们跳进来吧！

## 这是什么？

首先，“动态编程”这个名字和写代码的实践绝对没有关系。它实际上是作为一种解决复杂数学问题的方法开始的。特别是，动态编程(简称 DP)通常被定义为一种通过将一个大问题分解成连续的小问题来解决它的方法。这有点模糊，但有很好的理由:因为 DP 可以以如此多的不同方式应用，所以底层概念是非常通用的。真正理解某事的最好方法是使用它，所以让我们来看看一个我们可以用 DP 解决的问题。

## 最长递增子序列

假设我们有一个数列。我们可以将这个序列的一个*子序列*定义为按照它们在序列中的顺序取的数的任何子集。如果每个元素都比它前面的元素大，我们可以说一个子序列是*递增的*。

问题来了:*求一个序列 a 的最长递增子序列的长度*

好吧，在我们试图找出解决方案之前，让我们先试着对这个问题有个感觉。假设我们得到以下序列:

```
seq = [2, 9, 8, 4]
```

序列本身并没有增加。让我们看看长度为 3 的子序列，看看它们中是否有任何一个在增加:

```
[2, 9, 8]
[2, 8, 4]
[9, 8, 4]
```

很明显，它们都没有严格意义上的增长。检查长度为 2 的子序列，很明显有些在增加，例如

```
[2, 9]
```

所以，我们的答案(递增子序列的最大长度)应该是 2。现在的问题是，我们如何告诉计算机这样做？一种简单的方法是检查整个序列是否在增加，检查长度为 n-1 的所有子序列是否都在增加(其中 n 是序列的长度)等等，直到我们达到可以找到增加的子序列的长度。但是，这是一种叫做![on2](../Images/d45353facebae11e261d29dacce6f513.png)的算法，这意味着它根据输入序列的大小进行平方缩放。

我们能做得更好吗？

事实证明我们可以，我们将通过使用一些 DP 魔法来实现它。首先，我们在`seq[0]`有多少个结束的子序列？只有一个:长度为 1 的子序列，只包含`seq[0]`。那些以`seq[1]`结尾的怎么样？嗯……从`seq[0] , we can simply add on` `seq[1]`到`seq[0]`结束的子序列的结尾。因此，结束于`seq[1]`的子序列的最大长度是 1 加上结束于`seq[0]`的子序列的最大长度，这给出了最大子序列长度 2(结束于`seq[1]`)。

让我们试着概括一下。假设我们想找出结束于`seq[j]`的子序列的最大长度。假设我们有一个名为`q`的数组，它存储了在`seq[j]` *和*小于`seq[j]`之前的序列元素的索引。举个例子:对于`seq = [2, 4, 10, 9, 4]`和`j = 3`(记住，`j`是`seq`的索引)，那么`q = [2, 4]`因为它们是唯一在`seq[j]`之前的元素，而*和*小于`seq[j]`。

那么，我们可以说，结束于`seq[j]`
的递增子序列的最大长度等于 1 加上`q`中所有索引
处的递增子序列的最大长度。基本上，我们用已经计算过的东西来计算出
如何得出最终的解决方案。

代码总是有助于让事情变得清晰:

```
def longest_incr_subseq(seq)
  l = {}

  seq.length.times do |j|
    l_conn_keys = l.keys.select do |i|
      i < j and seq[i] < seq[j]
    end

    l_conn_values = l_conn_keys.map do |k|
      l[k]
    end

    l[j] = 1 + (l_conn_values.max || 0)
  end

  return l.values.max
end
```

我们来分解一下。

```
l = {}
```

这里，我们定义了一个散列，它将索引映射到结束于该索引的递增子序列的最大长度。回到一个例子，如果`seq=[2, 4, 3]`，那么`l = {0=>1, 1=>2, 2=>2}`。只有一个可能的子序列以 0 结尾:`[2]`；所以`l[0] = 1`。然后我们用算法算出`l`剩下的
。

```
seq.length.times do |j|
  ...
end
```

我们循环遍历序列中的所有索引，因为我们必须在`l`结构中为它们填充一个值。

```
seq.length.times do |j|
  ...
  l_conn_keys = l.keys.select do |i|
    i < j and seq[i] < seq[j]
  end
  ...
end
```

`l_conn_keys`相当于我们之前讨论的`q`。它包含在`j`之前的指数，其值小于`j`的值。这意味着以元素`l_conn_keys`结尾的递增子序列可以通过简单地在末尾添加`seq[j]`扩展成更长的递增子序列。

```
seq.length.times do |j|
  ...
  l_conn_values = l_conn_keys.map do |k|
    l[k]
  end
  ...
end
```

我们获取`l_conn_keys`(这是`seq`的索引列表)并将它转换成来自`l` Ruby 散列的值列表。这给了我们在所有连接索引上的递增子序列的最大长度。

```
l[j] = 1 + (l_conn_values.max || 0)
```

这是算法的核心。我们说，我们可以将 our 元素(将长度扩展 1)添加到与具有最大长度子序列的索引相关联的长度中。

让我们看一个例子。说`seq = [2, 4, 9, 5]`。对于`j=0`，很容易看出`l_conn_keys = []`。由此，`l_conn_values = []`。然后，用这个表达`l[j] = 1 = (l_conn_values.max || 0)`给了我们`l[0] = 1`。设置`j=1`。请记住，`l_conn_keys`是“连接”到`j=1`的索引，因此我们得到`l_conn_keys = [0]`，然后将其转化为`l_conn_values = [1]`。我们得到`l[1] = 1 + 1 = 2`。同样，我们可以考虑`j=2`得到`l[2] = 3`。现在`j=3`更有趣一点。注意`l_conn_keys = [0, 1]`因为 9(序列中 2 的索引)大于 5。然后我们得到`l_conn_values = [1, 2]`，最后得到`l[3] = 2 + 1 = 3`。

这给了我们正确的算法(证明本身实际上很简单，使用了数学归纳法——如果你能写出来就加分了！).让我们稍微思考一下它的表现。我们只对整个序列迭代一次(或者“一次”的常数倍数)，所以我们可以说算法是![on](../Images/a80b24a99a91fadca7486e78d5cabe4a.png)或者它是线性扩展的。想想和我们的二次算法相比。这种差异在规模上是巨大的！

从整个问题的本质来看，最重要的几点是:

*   我们把一个大问题分解成小问题，然后从小的解决方案中构建大的解决方案
*   我们使用结束于某个索引的子序列的最大长度。这种“在某个索引处结束”的技巧实际上在各种问题中都非常有用。
*   我们的算法比我们最初达到的算法要快得多

## 百货公司

这一次，我们将尝试使用一些数学来描述我们的算法，而不是马上使用 Ruby-speak。很多情况下，这样做可以让论点更清晰。

假设你经营一家连锁百货商店。您有一个特定的位置(称为位置 0 ),您可以从该位置沿一条直路测量距离。给你一个可能的商店位置列表，从位置 0 到位置 0 的距离是一个向量/集合:![m](../Images/e58c7c6db7265d8dde5602d8f49793cb.png)在 **m** 中的每个位置都有一个相应的利润，这些利润在 **p** 中列出，其中![pi](../Images/a6d975002b605ca875843d0d37787f4d.png)对应于位置![mi](../Images/3e5f06dde3a71ca60f6151c631e95e48.png)
，你还会得到一个数字![k](../Images/25e0f2cbe3cdcd4c8cd28e5b7a046faf.png)

你不能开两家相距不到 **k** 英里的商店。问题很简单:你如何最大化你的利润？

天哪，这看起来真的很复杂。你必须在距离要求和利润最高的商店之间找到平衡点。原来我们可以用动态规划来解决这个问题！

让我们定义一个函数(在数学意义上) **T** ，其中![tx](../Images/e9cad1631ff50fa7d1fb83b40791a4b1.png)代表如果你在距离 **x** 处结束商店列表时的最大利润。因此，我们在一天结束时寻找的值是![tmn-1](../Images/dab3130e440a0cdffaea78f67d59e285.png)，其中 **n** 是商店的数量。

首先，请注意，对于商店之间的距离，最大利润不变。例如，如果我们有一个 10 点的商店和一个 20 点的商店:![t_eqals_10_19](../Images/8e73cea42a72f5ba447e6bc61bd27e34.png)

现在，让我们试着把计算![tmn-1](../Images/5b617dbf88dd2a517c4c142b064fd32b.png)这个更大的问题分解成一些更小的问题。假设我们想在距离![mi](../Images/4f371b681df32c6b73c84a27435cf284.png)处最大化一些 **i** 的利润。然后我们可以包括所有在
![mi](../Images/4f371b681df32c6b73c84a27435cf284.png)后面 **k** 单位的商店

所以，我们可以写:

![t-recurrence](../Images/09027cc31c047b4d6134a00bf522ca6a.png)

同样，如果我们在第一家店结束我们的距离，那么最大利润就是第一家店可以获得的利润。在数学方面:

![basecase](../Images/d41e42742605a749b050fb65db3266d9.png)

现在我们已经有了 DP 算法背后的数学思想，让我们用 Ruby 编写代码:

```
def T(x, m, t_hash)
  return 0 if x < m[0]

  keys = t_hash.keys.sort
  relative_distances = keys.map do |d|
    x - d
  end

  #filter out the stores to leave only the
  #ones that come atleast "k" units before "x"
  filtered_distances = relative_distances.select do |r|
    r >= 0
  end

  key = keys[filtered_distances.index filtered_distances.min]
  return t_hash[key]
end

def dept_store(m, p, k)
  t_hash = {m[0] => p[0]}

  (1..m.length-1).to_a.each do |j|
    b = m[j] - k
    t_hash[m[j]] = p[j] + T(b, m, t_hash)
  end

  p t_hash
  t_hash.values.max
end
```

我们先来看看![tx](../Images/e9cad1631ff50fa7d1fb83b40791a4b1.png)的实现:

```
def T(x, m, t_hash)
  return 0 if x < m[0]

  keys = t_hash.keys.sort
  relative_distances = keys.map do |d|
    x - d
  end

  #filter out the stores to leave only the
  #ones that come atleast "k" units before "x"
  filtered_distances = relative_distances.select do |r|
    r >= 0
  end

  key = keys[filtered_distances.index filtered_distances.min]
  return t_hash[key]
end
```

基本的问题是确保如果我们在两个商店之间有一个 **x** 值，那么具有较低距离的商店的利润被返回。为此，代码会计算出每个商店离 **x** 的距离，过滤掉在 **x** 前面的商店，然后选择最近的一个。它的方式有点笨拙，但完成了任务。

请注意，`t_hash`保存了某些端点的利润信息；例如`t_hash[m[i]]`相当于![tmi](../Images/a71e4825655b9d9754dd577fdee7641e.png)

但是只有商店的位置才是`t_hash`中的关键。

现在我们有了`T`，剩下的算法的实现就*真的*简单了:

```
def dept_store(m, p, k)
  t_hash = {m[0] => p[0]}

  (1..m.length-1).to_a.each do |j|
    b = m[j] - k
    t_hash[m[j]] = p[j] + T(b, m, t_hash)
  end

  t_hash.values.max
end
```

我们首先从知道![basecase](../Images/d41e42742605a749b050fb65db3266d9.png)开始，然后将该信息添加到`t_hash`中。然后，我们简单地重复应用关系![t-recurrence](../Images/09027cc31c047b4d6134a00bf522ca6a.png)。最后，我们简单地返还我们所能拥有的最大利润！

带回家的点数:

*   我们把一个复杂的问题分解成更简单、更小的问题
*   我们使用了一个函数来跟踪状态(事实上，我们对前面的例子隐式地做了同样的事情；如果你能定义函数，那就加分了！)
*   我们提出了一个关系，允许我们“建立”更大问题的解决方案
*   我们的解决方案在线性时间内运行
*   同样的“根据问题结束的地方”来划分问题的技巧被非常有效地使用

## 那都是乡亲们！

希望这篇文章能让你对动态编程背后的概念有所了解，并对如何在 Ruby 中实现它们有所了解。

## 分享这篇文章