# 使用 Velocity.js 的快速 UI 动画

> 原文:[https://www . site point . com/exceibly-fast-ui-animation-using-velocity-js/](https://www.sitepoint.com/incredibly-fast-ui-animation-using-velocity-js/)

性能影响一切。提升的性能(明显的或真实的)改善了用户体验。反过来，用户体验的改善提高了利润。

几项主要研究已经证明，延迟的增加会大幅降低收入。Bing [报告称](https://www.w3.org/2013/Talks/0610-performance/#/2)延迟增加 2000 毫秒会导致每用户收入大幅下降 2%。同样，谷歌发现 500 毫秒的延迟会导致 [20%的流量下降](http://glinden.blogspot.ca/2006/11/marissa-mayer-at-web-20.html)。

因此，在我构建一个[高性能 UI 引擎](http://VelocityJS.org)的过程中，我同时也在构建一个用户体验引擎。本文旨在将当前的 web 性能环境融入其中，并深入探讨 Velocity.js 的性能优化，velocity . js 是一个动画引擎，可以显著提高所有浏览器和设备的 UI 性能和工作流。

在深入研究速度之前，让我们先回答一个紧迫的问题。浏览器多年来一直秘密地拥有巨大的性能潜力，但是前端开发人员仍然没有开发它，这怎么可能呢？

简而言之:开发人员基本上缺乏 web 性能意识。我们来探索一下。

## Web 性能前景

从 UI 设计的角度来看，有很多文章赞美构建移动优先、响应迅速的网站的优点。现在，开发人员明白了。相反，从 UI 性能的角度来看，大多数开发人员都会承认他们不知道自己在做什么。虽然 Google、Mozilla 和 Microsoft 的拥护者已经写了无数关于性能最佳实践的文章，但是大多数开发人员根本没有阅读它们。

更糟糕的是，有了 UI 设计，艺术技巧可以在多年的经验中自信地重复。然而，虽然性能原则(数据结构、延迟和渲染管道)受制于相同的迭代过程，但其前端实现的细节可能会定期发生变化。坦率地说，注重性能的开发人员经常被浏览器的怪癖和设备功能所束缚。这种情况要求开发人员敏锐地意识到 web 的底层架构层(呈现堆栈、垃圾收集和网络)，以便他们能够广泛地抽象出解决性能问题的方法。

但是考虑到开发人员已经有的工作量，当前的风气表明让普通开发人员掌握这个领域是不合理的。作为对此的回应，网络的主要性能倡导者，谷歌的伊利亚·格里戈利克，最近写了一篇逐点分析围绕浏览器和网络性能的神话:[高性能浏览器网络](http://www.amazon.com/High-Performance-Browser-Networking-performance/dp/1449344763)。(其他 web 性能资源可以在本文底部找到。)

当前的 web 性能状况类似于与 IE8 的怪癖并驾齐驱——过了一段时间，你就认输了，只是提高了你的站点的遗留浏览器支持的截止点。

移动领域的情况几乎相同:开发人员告诉自己，“设备变得越来越快。因此，在接下来的几个月里，随着用户不断升级他们的设备，我的网站自然会变得更有性能。”

不幸的是，事实是截然相反的:首先，发展中国家正在采用的智能手机没有我们口袋里的 iPhones 性能好——你真的想为下一个 20 亿上网人口放弃建筑产品吗？如果你的本能反应是，“这不是我的问题”，请放心，你的邪恶的 web 开发人员双胞胎兄弟正坐在一千英里之外咯咯地笑着，想着在你之前上市，努力开发一个即使在低功率设备上也能运行得非常快的解决方案。

即将到来的 Firefox OS 计划将为数亿人带来智能手机。未来已经在这里。我们不是在谈论假设。[爱立信报告称](http://www.ericsson.com/res/docs/2013/ericsson-mobility-report-november-2013.pdf)未来五年，全球智能手机用户数量将从 19 亿增加到 59 亿——几乎完全由发展中国家推动。

“一劳永逸”的心态对网络性能的第二个危险是，开发人员会系统性地犯错误，在具有理想性能负载的设备上测试他们的移动页面。但是，尝试打开更多的应用程序和网页。现在，重新测试你的网站。哎呀，你只是人工再造了一个相对“古老”的 Android 2.3 设备。另外，你已经无意中发现了我们第二个问题的核心:基于浏览器的应用对设备负载很敏感——CPU、GPU 和内存使用。加上设备硬件的可变性，你开始接近移动性能的现实:你应该总是开发最快的网站，而不仅仅是在你的 iPhone 上运行良好的网站。

性能很复杂，性能也很重要。这一点很清楚。但是，我们能做些什么呢？这就是我花了三个多月深入研究开源开发后想要回答的问题。

## 网络动画景观

jQuery 是网络上占主导地位的动画工具，它从 2006 年开始开发，而 Velocity 是在 2014 年建立的。因此，它从一开始就包含了最新的性能最佳实践。

简而言之，Velocity 是一个轻量级的 CSS 操作库，上面有一个动画层。它完全由 JavaScript 驱动，而不是 CSS 转换。它公开了与 jQuery 的`$.animate()`相同的 API，以简化从`$.animate()`到`$.velocity()`的转换。

在 Velocity 之前，DOM 动画领域主要由 jQuery、Transit(通过 JavaScript 控制 CSS 转换的首选库)和 GSAP(第一个高性能 JavaScript 动画库)组成。

这些库的缺点如下:

*   jQuery 的原生`$.animate()`在 UI 动画设计特性上速度较慢且相对较轻——即使与 jQuery UI 搭配使用。
*   Transit 比 jQuery 快得多，但功能更少，由于其通过 JavaScript 填充 CSS 转换的性质，偶尔会有错误，并且不支持 IE8 和 IE9(这两种浏览器继续拥有巨大的全球浏览器份额)。
*   GSAP 是一个成熟的动画平台，拥有巨大的力量。它的功能几乎是无限的；它可以让从 DOM 到 WebGL 的任何东西变得生动。(相比之下，Velocity 只专注于成为一个轻量级工具，用于大幅改善 UI 动画性能和工作流程。)尽管 GSAP 要求对各种类型的业务收取许可费，但 Velocity 是通过极其宽松的 MIT 许可免费开源的。

在所有压力水平下，Velocity 都大大优于 jQuery，而 Transit 从中等压力水平开始。GSAP 的表现类似于速度。要进行面对面的 UI 性能比较，请参考 [Velocity 的文档](http://VelocityJS.org)。

## 定时器优化

我们已经准备好深入研究有趣的性能细节。如何快速制作一个动画引擎？是微优化吗？没有。

速度上没有微优化。这是我确信要抵制的趋势。Stack Overflow 充满了 jsPerf.com 比较，善意的开发人员使用这些比较来确定哪个基于 JavaScript 的实现是性能最好的。然而，开发人员经常被这些表面价值的比较所欺骗，而不考虑它们的上下文。如果一个实现已经可以达到每秒几百万次运算，那么它的替代实现的速度有多快就无关紧要了。您的 JavaScript 代码可能永远不会以每秒百万次运算的速度运行。

DOM 性能的真正瓶颈主要是定时器创建和 DOM 操作。

让我们从分析定时器创建开始。使用`setInterval()`、`setTimeout()`和`requestAnimationFrame()`时会创建定时器。计时器创建有两个性能问题:1)由于浏览器维护它们的开销，太多的计时器同时触发会降低帧速率，2)不正确地标记动画开始的时间会导致丢帧。

Velocity 对第一个问题的解决方案是维护一个全局 tick 循环，一次循环所有活动的 Velocity 动画。不会为每个速度动画创建单独的计时器。简而言之，Velocity 将调度置于中断之上。

第二个问题是标记动画开始的时间，以便循环可以跟踪已经过了多长时间，这个问题通过直接在第一个动画刻度内设置开始时间来解决。

相比之下，开发人员通常在动画被触发时设置动画的开始时间。然而，在用户点击按钮触发 UI 动画的时间和产生的动画循环实际开始的时间点之间，第三方因素(相关的 JavaScript 逻辑、额外的 UI 交互、系统范围的负载等。)会导致延迟。随后，当动画循环最终开始时(例如，大约 16-85 毫秒后)，大多数动画循环的实现方式将导致大量前期帧被丢弃，以弥补时间差异。

速度在第一个动画循环节拍内设置开始时间，而不是在动画实际触发时设置开始时间，其结果是动画有可能在超过其触发的开始点约 16-85 毫秒后开始。然而，这种延迟实际上是察觉不到的，并且最终是无关紧要的，除非你正在创建一个游戏，这通常需要时间精确的碰撞检测。

总之，对于 UI 动画来说，流畅应该总是优先于时间准确性。

## 最小化 DOM 操作

计时器优化仅仅是速度下真正性能优化的垫脚石——最小化 DOM 操作。Velocity 背后的核心性能原则是，虽然你可以提供的帧速率有上限(大脑每秒只能感知这么多帧)，但你可以多聪明地避免 DOM 操作却没有上限。

当然，DOM 是网页上 HTML 底层的分层表示。很自然，DOM 操作由设置和获取组成。当您修改元素的 CSS 属性值时，您正在设置(更新)DOM。相反，当您在 DOM 中查询元素的 CSS 属性的当前值时，您会得到(查询)。这些 DOM 操作会导致性能开销。设置 DOM 后，浏览器必须计算你的改变的效果。毕竟，当您更改一个元素的宽度时，它可能会触发连锁反应，导致其父元素、同级元素和子元素的宽度发生变化。

这种由交替的 DOM 集合和 get 导致的帧速率降低现象被称为“布局抖动”

浏览器经过优化，可以快速执行 DOM 布局重新计算，但是当动画循环并发运行时，每一毫秒都非常宝贵，DOM 操作是在几毫秒内触发浏览器开销的最快方式(而大多数 JavaScript 操作在几分之一毫秒内完成)。为了了解动画循环的时间敏感性，为了实现每秒 60 帧(眼睛感知黄油般平滑运动的速率)，动画循环中的每个滴答必须在 16 毫秒内完成(1s/60 = 16.666 毫秒)。

Velocity 不遗余力地减少布局抖动和 DOM 操作。

首先，作为 Velocity 的唯一开发者，我花时间在 Velocity 的源代码中添加注释，突出显示每一行操作 DOM 的违规代码。简单来说，我在适当的地方撒上`/* GET */`和`/* SET */`。坚持这种做法允许我快速查看我的代码，以确保新特性或错误修复不会引入布局抖动。我跟踪代码路径，看看`/* GET */`后面是否跟有`/* SET */`。如果是这样的话，我要么重新设计批处理集的路径并聚集在一起(以最大限度地减少系统颠簸的发生)，要么完全避免实现这个特性。

第二，Velocity 尽可能对缓存的值进行操作，这样就不必在每个动画开始时重新查询 DOM。例如，Velocity 检测多个动画何时链接在一起，并重用前一个 Velocity 调用的动画结束值作为下一个调用的开始值。这是一个微妙的过程，因为必须不惜一切代价避免对陈旧值进行操作，否则动画会崩溃。Velocity 通过标记每个 Velocity 发起的动画调用来解决这种不确定性，然后当它检测到链中的前一个调用不是由 Velocity 发起时，就避免值缓存(例如，在 Velocity 调用之间注入 jQuery 的`$.queue()`或`$.fade()`函数)。

第三个，也是最后一个，Velocity 采用的主要 DOM 最小化技术是它对单位转换率的“真空”方法。单位转换逻辑是确定百分之一单位是多少像素的代码。例如，当您将元素的宽度设置为“+25%”时，这是必要的—动画引擎必须确定该值的像素值，以便可以使用相同单位类型的两个值执行增量数学运算。为什么特别是像素？因为浏览器在查询时会返回以像素为单位的 CSS 属性值，而不管设置该属性时使用的是什么单位类型。

单位转换过程需要将目标元素的宽度和高度临时设置为 1%,然后计算随后的 DOM 查询为该元素的维度返回什么。返回值以像素为单位，提供 1%和像素之间的比率。

Velocity 在这个单位转换过程中进行了三个关键的优化:首先，它缓存通过测试的元素之间的单位转换比率，以确定它们是否共享相同的比率(即，它们具有相同的父元素和相同的 CSS 位置值)。当一组元素同时被激活时，这是至关重要的。

第二，当不需要的时候，Velocity 会跳过单位转换。例如，当属性的起始值为 0 时，零在每个单位类型中都为零-不需要转换。

第三，Velocity 独特地选择了布局抖动而不是 DOM 树修改。前一种技术通过将动画元素暂时放在虚拟 CSS 属性“真空”中，去除了可能影响维度计算的 CSS 属性(例如，框大小、溢出)，从而产生了不希望的大量交替 DOM gets 和 set。属性剥离，接着是临时值设置和获取，然后是将元素重置为其初始值，这需要几轮布局抖动。

然而，我在 Velocity 开发过程中的一个发现是，布局抖动比目前使用的技术更具性能:通过克隆动画元素来根除 DOM 树，在原始元素旁边插入克隆，对克隆执行单位转换，然后完全删除克隆。这种方法是可取的，因为它避免了创建 CSS 真空的重要过程，但它导致了 DOM 树的重构(通过插入和移除元素来影响其层次结构)，最终导致比交替 CSS 属性值更大的浏览器开销。(我用 jsPerf.com 跨浏览器和设备证实了这些结果；正如它的维护者会告诉你的，这就是 jsPerf 变得非常强大的地方——当你需要跨许多环境比较真正的瓶颈情况时。)

## 把所有的放在一起

那么，在 Velocity.js 的基础上，你能做些什么呢？

*   你可以设计激烈的排版动画，与电影片尾字幕相媲美(仅限桌面):由[@ rachmithtweets](http://twitter.com/rachsmithtweets)制作的[演示#1](http://codepen.io/rachsmith/details/Fxuia) ，由 [@legomushroom](http://twitter.com/legomushroom) 制作的[演示#2](http://codepen.io/sol0mka/pen/kzyjJ) 。
*   你可以把一系列标准的 div 元素变成一个 [3D 粒子演示](http://julian.com/research/velocity/demo.html)(所有设备)。

这两个演示都完全在 DOM 中运行。没有 WebGL。没有画布。

就日常网页设计而言，最近 Velocity 的 UI 性能的一个显著例子可以在[Everlane.com](http://everlane.com)找到。四处浏览；体验令人难以置信的流畅和响应。

正如您刚刚看到的，DOM 和 JavaScript 非常快。您只需要考虑性能最佳实践。

查看下面的参考资料以了解更多信息。

## Web 性能资源

*   [保罗·刘易斯的博客](http://aerotwist.com)
*   [邱建免费](http://JankFree.org)
*   [性能行星](http://www.perfplanet.com)
*   [Mozilla 黑客](http://hacks.mozilla.org)
*   [膨润土盒](http://www.bentobox.io)
*   [“前端性能速成班”讲座](http://www.devoxx.com/display/d'Alene12/Faster+Websites++Crash+Course+on+Frontend+Performance)
*   [“无结块渲染”讲座](https://www.youtube.com/watch?v=cmZqLzPy0XE)

## 分享这篇文章