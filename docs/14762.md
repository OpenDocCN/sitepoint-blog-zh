# 可爱的缓存爱在

> 原文:[https://www.sitepoint.com/lovely-cache-love-in/](https://www.sitepoint.com/lovely-cache-love-in/)

ASP.NET 对我来说最大的吸引力之一是它巨大的缓存能力。您可以将任何对象发送到缓存中，设置其过期时间，并且只需几行代码就可以调用。

简单回顾一下，这是使用缓存对象的方法:

要将一个对象放入缓存，让我们假设一个标签的内容:

Cache["mylabeltext"] = Label1。文本；

要在以后调用缓存的值:

if (Cache["mylabeltext"]！= null)
{
Label1。text =(string)Cache[" mylabeltext "]；
}

现在，那是好东西！

但是有一点我想不起来，我真的不确定为什么这个功能似乎不存在。如何迭代缓存对象？

以下面的场景为例。我缓存搜索结果。当用户输入搜索时，我首先检查结果的缓存版本是否可用:

if (Cache["search"+searchQuery]！= null)
{
//输出缓存
}

但是假设我改变了影响搜索结果的信息？比如改变一个实体的标题…我如何清除引用这个实体的搜索结果的缓存？如果我可以迭代缓存，我可以通过查找引用进行快速搜索，然后更新缓存或删除它们。但是，不存在迭代器。

我设计的一种方法，非常混乱而且最终很慢，就是有一个搜索查询和它们引用的所有实体的列表。然后我可以将它序列化(或者转储到缓存中，就好像缓存被删除了一样，所有缓存的搜索也会被删除！)，并快速定位我需要修改的任何缓存搜索。

我只是不明白为什么迭代器没有在缓存中实现。也许我遗漏了一些显而易见的东西…

亲爱的 Sitepointers 有什么想法吗？:)

**更新**

DHTMLgod 在缓存对象中找到 GetNumerator:

 `Dim objCacheItems As Collections.IDictionaryEnumerator
objCacheItems = Cache.GetEnumerator
While objCacheItems.MoveNext
Response.Write(objCacheItems.Key)
End While`

干得好，伙计！我确信自动完成功能隐藏了……:)

**快速添加！**

我的一个朋友向我展示了他用 C#编写的缓存层的一些源代码……对我来说，他缓存在错误的级别，让我简单解释一下我的意思。

他会缓存来自数据库(数据集)的结果，然后处理信息，将其呈现在页面上。所以:

请求->缓存层->表示层->响应

事实是，简单地在表示层缓存要快得多…毕竟，这是您想要保存的输出。当然，如果您需要存储一个用于构建表示的结构，并且这个结构可能会改变，那么您可以同时缓存这个结构和表示。因此，与之前缓存数据集的情况不同，缓存层会返回一个字符串或 StringArray 等。显示实际内容，这意味着可以绕过表示层:

请求->缓存层->响应

对某些人来说，这似乎是显而易见的，但这种设计缺陷很容易出现。

## 分享这篇文章