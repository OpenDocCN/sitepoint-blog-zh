# 也许我对 Java 的理解是错误的——第 1 部分

> 原文:[https://www.sitepoint.com/maybe-i-was-wrong-about-java-i/](https://www.sitepoint.com/maybe-i-was-wrong-about-java-i/)

*编者按*:在 Java 渠道中，我们大多数人都非常了解这种语言，并且已经在它的生态系统中至少呆了几年。这给了我们常规和专业知识，但也导致了一定程度的狭隘视野。在新的系列 [*中，非爪哇人将向我们展示他们对我们生态系统的看法。*](https://www.sitepoint.com/python-for-java-people/)

我不是 Java 的最大粉丝。必要的话可以看 Java，紧急情况下也写过一些，但是没有养成习惯。我和许多其他非 Java 人对它有着相同的刻板印象:它又大又慢，而且完全是由编程时打着领带的人编写的。

我最出名的可能是对 PHP 的精心解构，但这是因为 PHP 让我产生了一种独特的挫败感。Java 主要激发，啊，无聊。

但是等等。PHP 之所以受欢迎，是因为它有一个独特的优势:它从噩梦般的 web 开发仪式中去掉了一些步骤。Java 没有类似的巨大优势，所以它必须做对一些事情。否则甲骨文也不会吹嘘 9 万亿台运行 Java 的设备。它不会给相当数量的大型网站提供动力。占主导地位的智能手机操作系统不会完全建立在它之上。我不会有一个运行 JVM 的烤面包机。(效果比你想象的要好！你只需要等一会儿，让它热起来。)

所以也许——也许*也许*——我把 Java 全弄错了。也许我对它不公平。*也许吧。*

可能是时候重新审视我对 Java 的先入之见了。打破一些神话，如果你愿意的话。

作为参考，我已经涉猎了许多语言，但我主要使用 Python，并且喜欢它的许多设计决策。Python 和 Java 有一点哲学上的重叠，所以这是一个有趣的比较点。

## Java 很慢

对我来说，Java 绝对是又大又慢。这个词就像是我脑子里的糖蜜。当我想到 Java 时，我就想起了我在桌面上很少遇到的 Java。也许最臭名昭著的是 Azureus，十多年前每个人都用来下载 Ubuntu 版本的 Java BitTorrent 客户端。考虑到它所做的只是下载文件，而且当 Torrent 发布时，每个人都跳到了 Torrent 上，这真是令人惊讶的缓慢。Torrent 当然是用 C++写的，这让它更快更有性能。

问题是，这没有任何意义。我多年来唯一用过的 BitTorrent 客户端是用 *Python* 编写的洪水。(C)从任何角度来看，Python 都没有 Java 快，但对我来说，洪水一直很爽快。使用 JVM 的部分原因是因为它相当快，那么这种与慢的联系是从何而来的呢？

尽管我们想以不同的方式思考，但在这里很难进行任何真正的测量；影响速度的因素如此之多，以至于即使将单个程序与其自身进行基准测试都是不可靠的，更不用说比较两个完全不同的软件了。机器在做其他事情时陷入了困境吗？GC 是否在不恰当的时间介入？一种语言更擅长某项特定的任务吗？我用的 JVM 不好吗？一个应用程序比另一个写得好吗？即使我能控制所有这些因素，测量对速度的*感知*仍然很棘手，这才是真正的原因。我能做的就是仔细考虑一下。

### 缓慢的程序，缓慢的语言

我怀疑这里有一点确认偏差。如果一个程序很慢，我们责怪这个程序——但是如果一个 *Java* 程序很慢，我们责怪 *Java* 。Java 在这里甚至处于特别不利的地位；很容易注意到 GUI 程序是用 Java 编写的，因为 Swing 很突出，但很难确定它是用 C++或类似语言编写的。

以我的经验来看，这在游戏圈尤其明显，在那里你可以找到从未写过一行代码的人对游戏性能的深刻见解。你看，《我的世界》很慢，因为它是用 Java 写的，而 Starbound 很慢，因为开发者没有“优化”它。不管那是什么意思。

另一个可能的因素，虽然我不知道这有多真实:我得到的印象是，许多开发人员写 C++是因为他们想写，但当他们不得不写 Java 时？我遇到过许多 C++代码，它们没有令人信服的理由用 C++编写，但是许多 Java 代码的故事以“我们用 Rails 编写了这个，当它变得太慢时移植了它”开始。(或者“这是为了 Android，所以我们不得不这么做”。换句话说，Java 似乎是加速已经太慢的代码的常用工具，所以任何给定的 Java 程序都有可能做一些非常繁重的工作。并不是说 Java 慢；那就是慢的程序往往是用 Java 写的。一个自我选择的问题。

同时，很多 C++纯粹是出于恶意而写的。或者，更确切地说，有一部分程序员痴迷于最大性能，无论他们是否需要 c++*，因为反对“裸机”给了他们温暖的模糊感，并且完全值得冒伪 segfaults 和内存错误的风险。因此，一个给定的 C++程序不一定会做那种证明使用 C++是合理的密集工作。*

 *### JIT 有错吗？

我最初试图将一些感觉到的缓慢归咎于 JIT 预热，但我不确定这是可能的。随着我越来越多地使用 PyPy，我自己也开始更频繁地体验 JIT 预热。PyPy 是一个 JITted Python 实现(自己编写，因此得名)，更广泛采用的一个大障碍是需要几秒钟的预热时间。用普通 Python 或多或少能立即运行的 Python 程序在用 PyPy 运行时会产生明显的延迟——由于 Python 通常用于命令行工具，这种延迟会影响相当多的程序。

但是对于任何运行时间超过半分钟左右的东西，PyPy 要快得多。我希望 JVM 拥有比 PyPy 相对年轻的版本更先进的 JIT，所以预热时间肯定会更短。我怀疑 Java 会因为在最初的 20 或 30 秒内有点磨蹭而获得缓慢的名声。

我还观察过实时使用 lve 进行 JIT 预热，这是一个使用 LuaJIT 的游戏引擎。如果你在屏幕上画出帧速率，你可以*看到*它从 10 左右开始，在几秒钟内上升到 60。之后运行良好。再次，减速是相当短暂的，它从来没有给我的印象是引擎或 JIT 作为一个整体是缓慢的。

### 作为玩具的 Java

我敢打赌，这在很大程度上是追溯到 Java 刚问世时的流言蜚语。当然，一些 C++开发人员会认为 Java 是 C++的再创造，相对于 C++来说，c++慢得可笑。最初的 Sun JVM 好几年都没有 JIT，所以很早的 Java 就像现在大多数 Python 一样被字节码解释——但是是在更慢的硬件上。

从文化角度来看，这也有一定的道理。Java 是作为一种“严肃的”语言出现的——也就是说，它是 C++的竞争对手——而当时唯一的“严肃的”语言是，呃，C++。任何闻起来像翻译语言的东西都被认为是玩具。我是说，比现在更甚。如果“任何人都会用于严肃开发的语言”的整个范围从 C++到 Java，当然 Java 看起来就像一头笨重的野兽。自动垃圾收集？你是什么，婴儿吗？我敢打赌，你的语言甚至不能切分。

一晃二十年过去了，我一半的操作系统都是用 JavaScript 编写的。我甚至曾经用 Perl (yolo)写了一个桌面应用程序。相比之下至少 Java 更好看？

## Java 很臃肿

我不喜欢“膨胀”这个词。这没有任何意义。或者，更确切地说，它意味着“我不在乎的东西”，这不是一个有用的批评。

有一次有人同时告诉我，ⓐ他们没有用 GIMP 做艺术品，因为它太臃肿了，而ⓑ他们对更简单的 Paint.NET 感到失望，因为它缺少他们需要的一个模糊的功能……而 GIMP 有。

为了精确起见，这里有一些“膨胀”的意思。

### Java 程序使用大量内存

一提到 Java 的内存使用，我就会想起我在$TECHCOMPANY 工作时的一个故事。我负责我们构建系统的维护和维护，这个系统使用了 Closure Compiler，一个用 Java 编写的 JavaScript 到 JavaScript 的“编译器”。

构建系统以`java -Xmx1024M ...`的身份运行 Closure，将最大堆大小设置为 1 GB。当手动调用 Closure 时，我有时会忘记看起来神秘的`-Xmx`开关，JVM 会立即陷入火海。后来我发现了有点模糊的`_JAVA_OPTIONS`环境变量，这让我再也不用记住它了，但是这个秘密仍然存在。当我最终深入调查时，我发现了一个有趣的意图冲突。

我们使用共享的开发机器，每台 64 GB。我们有一个 5 GB 的`ulimit -v`,这阻止了任何进程分配更多的内存。默认情况下，我们的 JVM 试图在启动时分配机器物理内存的四分之一(16 GB)给*。分配失败，因此 JVM 立即关闭。([文档](http://docs.oracle.com/javase/6/docs/technotes/guides/vm/gc-ergonomics.html)确实建议默认情况下堆的上限不应该超过 1 GB，但是[看起来不正确](http://stackoverflow.com/questions/2915276/what-is-the-default-maximum-heap-size-for-suns-jvm-from-java-se-6)。)*

这对 JVM 来说并不是完全不合理的。Linux 会很乐意分配它实际上没有的大量内存，只要进程不试图*使用所有的内存，一切都会很好。JVM 利用这一点预先分配了一个巨大的块，避免了以后大量(缓慢)分配的需要。`ulimit`是一个粗略的试探，以防止失控的进程使机器陷入困境，但它限制了一个实际上没有任何意义的数字。(唉，`ulimit -m`——本应限制实际内存使用——从 Linux 2.4 开始就不再使用了。)*

在我脑子里，这个故事就是“那一次 Java 要 16 GB”。我知道这不公平，但这与 Java 通常被认为是内存猪的模糊感觉产生了共鸣。甚至 Java 本身似乎也认为它可能需要那么多内存。然而，如果我越过刻板印象，我想不出为什么会这样的具体原因。

我可以想象，大多数速度因素在这里也适用:当 Java 程序很大时，Java 会受到指责，但当 C++程序很大时，C++不会受到指责；大型任务往往以 Java 结束；过度优化的 C++开发人员可能会对垃圾收集和每对象开销嗤之以鼻。

啊，但是尽管速度很难量化，甚至对于单个程序来说，大小更具有决定性。同一类型的相同值通常每次运行占用相同的空间。例如，我知道 CPython 对象有 16 字节的开销—一个类型指针和一个引用计数。我对 Java 中的对象开销不太有信心——确切的内存使用被视为 VM 的实现细节，Java 有几个竞争的 VM 在共同使用。(我对 CPython 的了解只是从看源码开始的，已经很熟悉了。)但是我严重怀疑任何 JVM 会比 Python 需要更多的对象开销，在某些情况下，它需要的应该少得多——Python 没有 unboxed 原语。最终，Java 不应该比 Python 差太多，我不认为 Python 是一个内存猪，所以我当然不应该认为 Java 是一个。

#### 伪造科学

足够的猜测。如果尺寸可以更可靠地测量，让我们做一些测量。下面是几个任意选择的桌面程序的初始内存使用的可怕的、不科学的比较。

*   思维映射器 XMind(Java):416 MB
*   [yEd](https://www.yworks.com/products/yed) (Java)，一个图形编辑器(如流程图中，而非 *y = x* ): 372 MB
*   [jDiskReport](http://www.jgoodies.com/freeware/jdiskreport/) (Java)，一个磁盘空间报告的东西:228 MB
*   一个 MC 风格的文件浏览器:183 MB
*   [FreeMind](http://freemind.sourceforge.net/wiki/index.php/Main_Page) (Java)，另一个思维映射器:181 MB
*   [SLADE](http://slade.mancubus.net/) (C++/wxWidgets)，一个末日地图编辑器:93 MB
*   一个图像编辑器:88 MB
*   [LMMS](http://lmms.sourceforge.net/) (C++/Qt)，一个数字音频工作站:75 MB
*   [洪水](http://deluge-torrent.org/) (Python/GTK)，一个 BitTorrent 客户端:85 MB

(顺便说一句，所有的 Java 程序都是以至少 11 GB 的虚拟内存开始的——除了 FreeMind，它附带了一个添加了`-Xmx`的 shell 脚本。甚至一个微不足道的 hello-world Java 程序也为我分配了 10.5 GB，所以看起来默认的初始堆大小仍然大得可笑。我有 32 GB 的物理内存，所以四分之一就是 8gb；不知道 10.5+ GB 的数值从何而来。)

哇哦。我没有想到会有如此巨大的差异，即使我知道很多因素都对 Java 不利。GTK 和 Qt 是共享库，可能与其他进程共享，甚至 Python UI 也包装了这些库，并在 C 级别存储了许多数据；Swing 几乎完全生活在 Java 世界中，并且只被我打开的程序使用。Java 当然有一个完整的运行时(看起来需要 26 MB 的基线)，而 C++“运行时”是微小的。Python 也有运行时，但与其他程序相比，洪水是一个简单得多的程序；这只是我手头上唯一一个非 C++的东西。或者 XMind 和 yEd 可能因为其他原因而不具有代表性。

Java(像 Python 一样)也需要记住很多调试信息，为了反射和堆栈跟踪，这些信息通常会被已发布的 C++程序忽略。垃圾收集倾向于用空闲内存来换取速度；我不知道我的 JVM 的 GC 是如何工作的细节，但是我见过 100%或更多开销的 GC，所以如果这是一个重要因素，我不会感到惊讶。我想说 GC 也有难以解决的碎片问题。

#### Java 的字符串很浪费

我怀疑另一个巨大的罪魁祸首是 Java 的`String`类型。从 20 世纪 90 年代“Unicode”的定义来看，Java 字符串是“Unicode”。看，Unicode 最初承诺它永远不会超过 65，536 个字符，所以两个字节足以表示任何内容。Windows API、至少一个 GUI 工具包、Java、JavaScript(很可能是从 Java 复制过来的)和其他可怜的人们牢记这一点，并声明字符串都将使用双字节字符。字符编码被永远解决了。

直到 Unicode“哎呀”了一声，承诺永远不会超过 1，114，111 个字符，所以*三个*字节就足以表示任何东西，但是没有人有三字节的整数类型，所以让我们把它四舍五入到四个。现在 Java 的处境很尴尬。ASCII 文本占用的空间是它实际需要的两倍。但是如果没有另一种编码机制，Java `String`不能表示所有的 Unicode 字符，所以仍然可以编写错误的文本处理代码，假设每个字符都是一个实际的字符。两个世界中最糟糕的。

字符串可能是 GUI 内存使用的一个重要部分，有过多的标签和工具提示，在这种情况下，这将产生巨大的差异。我知道 XML 和配置文件在 Java 世界中也相当流行，它们自然会产生大量的字符串。我看到 Java 9 被设置为采用更紧凑的方案，其中 ASCII 字符串将透明地使用每个字符仅一个字节。Python 在几个版本前转向了[一个类似的方案](https://www.python.org/dev/peps/pep-0393/)，Django (web)应用程序的内存使用相对于两字节版本下降了 40%。Java 可能会在大量使用文本的程序中看到类似的改进；一份关于对服务器性能指标评测影响的[报告](http://cr.openjdk.java.net/~huntch/string-density/reports/String-Density-SPARC-jbb2005-Report.pdf)发现堆使用率提高了 21%。

#### 最后

我开始时期望发现 Java 比我想象的要紧凑得多，但是……这并没有发生。即使 228 MB 也不算太差，但是 416 MB 就有点可笑了。哦，我不小心让 yEd 跑了一夜；尽管什么也没做，它还是增长到了 854 MB，在一个打开了几个大画布的艺术程序和我的打开了几百个标签的浏览器之后，排名第三。我不知道它在做什么，也不知道该怪谁，但情况不妙。有趣的是，尽管 FreeMind 和 XMind 是同一类型的软件，用同一种语言编写，但它们分别是最好和最差的。

现在，为 Java 说句公道话，老实说，如果我没有去寻找它，我是不会注意到内存使用情况的。我*有 32 GB 内存是有原因的。然而……我的完全基于 Java 的手机只有 2 GB，而且似乎还能应付。也许我漏掉了什么。Java 程序的传播也明显比 C++程序广得多，我不知道为什么。*

 *![programming-in-a-tie-wrong-about-java](../Images/118d69216652ac973f31bc50e48afefa.png)

### Java 程序有很大的文件系统空间

当我环顾房间，看看是否还有其他人认为这是真的时，我觉得自己微微点头表示同意。

问题是，我不知道为什么对我来说这听起来很合理。

Arch Linux 包存储库在这里很方便，因为它列出了每个包的安装大小。我的老朋友[闭包编译器](https://www.archlinux.org/packages/community/any/closure-compiler/)19.7 MB。哇！那太多了。对吗？嗯，也许不是。我能想到的最相似的项目是 [Babel](https://www.archlinux.org/packages/community/any/babel-cli/) ，它将最新的 ECMAScript 编译成对浏览器更友好的东西，它仍然是 7.0 MB。Closure Compiler 可以做 Babel 做的大部分事情，而且它的构建更像传统的编译器，所以我对它更大一点也不惊讶——如果有什么不同的话，我对它只有两倍大感到惊讶。与此同时， [GCC](https://www.archlinux.org/packages/core/x86_64/gcc/) 为 116.1 MB。

这是一种非常不可靠和不科学的测量软件规模的方法。但这就足够了，我已经对这一点产生了严重的怀疑。人们很容易将早期的一些桌面软件进行比较，但是即使是 FreeMind 和 XMind——这两个服务于大致相同目的的 Java 程序——也有非常不同的安装大小，分别为 27 MB 和 138 MB。

我甚至想不出一个轶事来解释为什么我期望 Java 软件会很大。我想知道这是否是因为 Java 小程序在流行时相对较大——那时许多人还在使用拨号上网。

在我停止对 Closure Compiler 挑剔之前，我对“文件系统足迹”有另外一种解释——源文件*的排列*。Closure 的大部分源代码存放在[一个五层目录](https://github.com/google/closure-compiler/tree/master/src/com/google/javascript/jscomp)中，这似乎有点极端。该目录包含 347 个`.java`文件，这似乎也有点极端。许多这些文件看起来像是可以*归入合理的类别，但是它们……不是。*

也许封闭是个例外。GitHub 告诉我，最受关注的 Java 项目是 [elasticsearch](https://github.com/elastic/elasticsearch) ，其的[实际代码也被埋在下面五层。我在这里没有看到任何目录有这么多文件，但是每个目录似乎包含十个以上，我还没有找到底部。](https://github.com/elastic/elasticsearch/tree/master/core/src/main/java/org/elasticsearch)

浏览这些(公认的大型)项目的源代码似乎令人望而生畏。这里有一定程度的蔓延。相比之下，大多数 Python 项目都相对紧凑:几层深度，六个文件宽。

我怀疑这可以归结为 Java 的一个非常重要的属性:一个文件只能包含一个(公共)类。据我理解，Java 没有导出的概念；如果你有一个文件`foo/Bar.class`，其中唯一可以导入的是一个名为`Bar`的公共类。不管你想怎样安排你的代码，不管你的类是大是小，或者你有多少个类，你都需要一个单独的文件来存放每一个公共类。规则是不同的，但这在某种程度上让我想起了 Perl。哇，这么说很奇怪。

与 Python 形成对比，Python 具有看起来相当相似的包层次结构。文件`foo/bar.py`可以导入为虚线路径`foo.bar`，其内容可以引用为`foo.bar.Bar`。但是`foo.bar`将是一个中间名称空间，一个*模块*对象，它包含文件中定义的所有内容。导入看起来类似于 Java，但是文件是自由格式的。一个文件可以包含许多小类、免费函数、公共管道和任何你想要的东西。Python 文件可以包含完整的*想法*；Java 文件被束缚在你认为“类”应该是什么的东西上。

我很难想象在每个文件一个类的限制下从事一个大型项目。创建一个新的类(而不是依附于一个现有的类)已经涉及到一些摩擦；需要创建一个全新的文件将是一个巨大的阻碍。我可能希望拥有尽可能少的类，这可能是为什么我隐约地将 Java 与大型的多毛类联系在一起。每节课的内容越多，意味着整个课越少——问题解决了！

奇怪的是，Java*有办法模拟类似 Python 的模块，但我从未见过或听说过它被使用。允许直接导入嵌套类，所以一个文件可以包含一个大的公共类，里面有任意数量的静态公共类。顶级类将是一个哑容器，类似于 Python 模块，它的静态子类的任何组合都可以由任何其他代码导入。唉，如果这真的像看起来那样不常见，那么其他 Java 开发人员的困惑可能会抵消这些好处。*

 *再看看 elasticsearch，*包*的结构与我可能安排 Python 项目的方式没有太大的不同。考虑这个 [`analysis`目录](https://github.com/elastic/elasticsearch/tree/master/core/src/main/java/org/elasticsearch/index/analysis)，其中的许多文件都是样板文件类，长度不比文件顶部的许可证长。这是一个包含许多小类的单一包；它们只分布在多个文件中，因为语言需要它。按照这种方式解释，elasticsearch 是一个相当整洁的项目。我甚至发现一些目录中只有一个文件/类，如果我用包目录模拟 Python 模块，这正是我最终会得到的结果。

从开发的角度来看，文件蔓延似乎有点烦人，但它与语言的一个基本法则交织在一起。不好意思，Java 这一轮你输了。

### Java 有一个很大的标准库

这是真的有人抱怨吗？我不确定。它类似于最终用户软件的“臃肿”用法，所以值得一看。

标准库是一个棘手的权衡。c 语言微不足道的标准库意味着许多项目重新发明了相同的轮子，但保持了语言本身的简单性和可移植性。另一方面，Python 庞大的标准库非常方便，但也积累了大量奇怪的垃圾，如超过 12 个 IRIX 模块的[。我更喜欢能够很好地扩充核心语言的标准库，尽管我越来越发现一个可靠的包管理器可能比自带语言的厨房水槽好得多。](https://www.python.org/dev/peps/pep-3108/#irix)

除了磁盘上的大小，我想不出什么好的方法来衡量一个标准库的大小。这里是我碰巧安装在机器上的一些语言运行时的大小，以及我用来测量它们的 zsh globs。我的直觉是 Java。NET 和 Python 都有相当大的标准库；铁锈色和红宝石有更适中的；Perl 是相当简单的。c 不算什么。

*   单声道 4.6: 43 兆字节— `/usr/lib/mono/4.5/**/*.dll`
*   OpenJDK 7: 33 MB — `/usr/lib/jvm/java-7-openjdk/jre/lib/rt.jar`
*   CPython 3.5: 27 MB — `/usr/lib/python3.5/**/*.py~*site-packages*`
*   Perl 5.24: 17 MB — `/usr/share/perl5/core_perl/**/*.p[ml]`
*   红宝石 2.3: 8.9 兆字节— `/usr/lib/ruby/2.3.0/**/*.rb`
*   Rust 1.12: 4.9 MB — `/usr/lib/rustlib/x86_64-unknown-linux-gnu/lib/libstd-*.so`
*   C: 2.0 兆字节— `/usr/lib/libc-2.24.so`

嗯，呃，嗯。我略带惊讶之色。

诚然，这是一个可怕的比较。Rust 的标准库被编译成机器代码(使它变得更小)。我认为 Mono 和 OpenJDK 是编译成字节码的。CPython、Perl 和 Ruby 库是未压缩的源代码(使它们更大)，但排除了一些二进制组件(使它们更小)，但包括大量内联文档(使它们更大)，但用更高级的语言编写(使它们更小)。

Perl 的立场让我更加怀疑这种方法论。我真正能得出的结论是，Java 的标准库比 Python 的要大一些，这似乎是正确的——例如，Java 附带的 GUI 包是 Python 的两倍。我在这里没有看到任何明显的迹象表明 Java 的标准库大到无法管理。

## 目前的比分

Java 是传说中笨重的野兽吗？结果喜忧参半。我想不出任何好的理由来指责 Java 特别慢，尤其是在一个越来越由 JavaScript 驱动的世界，而且这与我最近的经历不符。我猜 Java 是第一种广泛使用的依赖于 VM 的语言，它为此受到了大量的抨击，而第一印象会永远存在。

另一方面，Java 可能比我想象的更需要内存。我没有一个令人满意的解释，为什么会这样，或者为什么在我的桌面上看起来比在我的手机上糟糕得多。有可能我为数不多的几个数据点是不好的。也有可能 Java 真的是一个内存猪，这就是为什么没有多少公共桌面软件是用 Java 写的，我从来没有在我的手机上注意到，因为我几乎没有多任务。

我是一名程序员，但我不是一名 Java 程序员，所以大部分都是从最终用户的角度来看的——还有其他几个因素导致了对 Java 的不公平的负面看法。Java 只有在做一些烦人的事情时才会提醒桌面用户，比如在启动时运行快速启动服务(这还是一件事吗？)或者为更新而烦恼。我简单地提到了 Swing 就像一个疼痛的拇指，我尝试的程序巩固了这种印象:它们使用错误的颜色和字体，它们默认使用 Java 自己的子像素字体渲染，这种渲染很糟糕，它们做一些奇怪的事情，比如在 Linux 上模拟 Windows 95 文件选择器对话框。每当我遇到 Swing 程序时，我都会抱怨，因为我知道它会很笨拙——而且由于这个程序显然是用 Java 编写的，所以我把“笨拙”和整个 Java 联系在一起。

但是 Java 在桌面上的份额很小，而且还在不断缩小，并且正在从浏览器中消失，所以也许最终用户的观点并不那么重要。Java 在服务器端仍然非常受欢迎，并且几乎独占了 Android，这肯定有一个很好的理由。我仍然持怀疑态度，但很好奇。在第二部分中，我将不得不从开发的角度更多地了解 Java。** 

## **分享这篇文章***