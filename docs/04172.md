# Sass 使用配置文件进行主题化

> 原文:[https://www . site point . com/sass-theming-with configuration-files/](https://www.sitepoint.com/sass-theming-withconfiguration-files/)

在过去一年左右的时间里，我一直在从事一个大型项目，有多个基于相同代码库的网站。所有这些网站都需要相同的核心功能，但有时会有额外的功能或独特的风格。谈到样式，我们发现的主要问题是某些网站需要有一个与其他网站完全不同的主题。因此，我们决定使用 Sass 来创建网站的 CSS。在这篇文章中，我想告诉你我们是如何为不同的网站编辑主题的。

简单介绍一下背景，这个项目使用了带有父/子主题结构的 WordPress。有一个核心的父 WordPress 主题，包含每个网站会使用的所有主要功能，以及每个不同市场网站的子主题。

## 配置您的 Sass

首先，我想简要了解一下我们通常如何在 Sass 中使用配置文件。下面是我们一个项目的基本文件夹结构:

```
assets/
  |- scss/
    |- base/
    |- components/
    |- pages/
    |- settings/
        |- _colors.scss
        |- _layout.scss
        |- _fonts.scss
    |- tools/
    |- vendor/
    |- main.scss
```

我已经展开了上面的设置文件夹，其中我们为每组设置保留了各种单独的部分。这样做的目的是使这些配置文件尽可能的小并且易于浏览。自从读了 Stuart Robson 关于[重新思考你的 Sass 变量](http://alwaystwisted.com/articles/rethinking-your-sass-variables)的文章后，我就一直在思考这个问题。

例如，如果我们查看颜色的内部，我们会看到类似这样的内容:

```
// COLORS
// ---------------------------

$clr-lightblue:#4BCEFA;
$clr-pink:#F96EC4;
$clr-orange:#FFB400;
$clr-green:#8DD400;
$clr-purple:#009edc;
```

设置片段首先包含在我们的主清单文件中，允许我们在剩余的片段中使用这些变量。这意味着所有的颜色声明都在同一个位置，很容易找到。

## 结构

在具有单一主题的单一样式表的上下文中，使用上述配置方法是很好的。在我们的情况下，我们有一个核心 WordPress 主题和几个子主题，它们都需要样式表——这里有一个规模问题，我稍后会谈到。

为了给每个单独的子主题创建样式表，我们设置了 Sass 结构来匹配我们的 WordPress 主题结构。

```
scss/
  |- australia/
  |- china/
  |- core/
  |- uk

themes/
  |- australia/
  |- china/
  |- core/
  |- uk
```

目录中的每个市场都有自己的 style.scss，它们将直接编译到主题目录中相应的主题中。

**注意**:我们基于使用 Compass 和 Grunt 构建我们的 Sass 来决定这种结构，这在当时似乎是最有效的方法。

## 配置多个主题

到目前为止，我已经完成了配置设置，并讨论了一些关于我们现有的结构。现在，让我们来看看我们实际上是如何使用配置文件来修改不同的主题的。

首先，由于核心/父主题，我们有一个核心或默认配置。为了创建每个单独的主题样式表，我们能够在每个 style.scss 清单中包含我们的核心部分。然后，我们可以添加网站特定的部分，以添加/覆盖该市场所需的任何风格。

```
// Import the core partial containing all base site styles
@import “../core/core”;

// Import site-specific styles
@import “partials/campaigns/competition”;
@import “partials/campaigns/promotion-spring”;
```

### 覆盖配置

到目前为止，我们创建多样式表的方法可以很好地覆盖样式。但是覆盖配置略有不同。当将核心部分导入每个市场站点时，我们得到的是已经使用了我们配置的变量的所有样式。一旦导入，就无法覆盖已经配置的内容。在这种情况下，我们需要在导入核心样式之前添加定制配置。为此，我们有两种选择:

1.  为每个市场创建一组配置部分，或
2.  创建一组默认配置，并根据每个市场的需要进行覆盖。

两者都是可能的，也是完全可以实现的。在这两种情况下，单个市场站点的 style.scss 看起来有点像这样:

```
// Import configuration partials
@import “settings/colors”;
@import “settings/fonts”;

// Import the core partial containing all base site styles
@import “../core/core”;

// Import site-specific styles
…
```

当创建一组完全不同的主题时，大多数情况下所有的设置都可能改变，第一个选项可能是最合适的。然而，在我们的例子中，我们有很多站点几乎总是有相同的配色方案，只有少数需要完全不同的设置。

### 使用`!default`

为了允许我们创建默认设置的配置，我们需要使用[`!default`标志](https://robots.thoughtbot.com/sass-default)。`!default`标志告诉 Sass，如果还没有指定名称的变量集，那么就使用这个。

> […]如果变量已经被赋值，它不会被重新赋值，但是如果它还没有值，它会被赋予一个值。

这意味着，如果没有配置任何其他内容，则需要在您想要使用的值上设置标志。回到我们的颜色配置文件，它现在看起来像这样:

```
// COLORS
// ---------------------------

$clr-lightblue:#4BCEFA !default;
$clr-pink:#F96EC4 !default;
$clr-orange:#FFB400 !default;
$clr-green:#8DD400 !default;
$clr-purple:#009edc !default;
```

使用了`!default`标志后，我们现在可以将这些变量的常规定义添加到特定于主题的配置中，以代替这些默认值。

### 命名变量

当我们开始为我们的主题使用不同的配置时，我们意识到的一件事是，至少可以说，这意味着我们的变量名有点无用。意图是足够诚实的，但是当我们在配置中开始这样做时:

```
$clr-lightblue:#f02233; // Red for China
```

我们知道有些事情必须改变才能改善。

我们决定的命名方案非常符合我们的要求，因为我们有一组需要单独颜色的部分。尽管我肯定会建议坚持一个最适合你正在做的项目的惯例。虽然“主要”、“次要”、“第三”风格的命名约定可能适用于某些人，但可能不适用于所有人。

在我们的例子中，颜色变量与项目相关的名称更加一致。这无疑让我们更容易识别它们的用法。

```
$clr-brand:#4BCEFA !default; // lightblue
$clr-kids-activities:#F96EC4 !default; // pink
$clr-parenting:#FFB400 !default; // orange
$clr-sustainability:#8DD400 !default; // green
$clr-mmr:#009edc !default; // blue
```

## 潜在的陷阱:伸缩

这种方法在一个领域确实有点困难:缩放。当扩展这个解决方案来配置项目中目前的 31 个主题(很快将会是 33 个)时，编译的时间变得非常长。我从没想过我会作为一名前端开发人员参与到 XKCD 漫画的编写中。

这个解决方案可能无法很好地扩展的原因是，对于我们创建的每个主题，我们必须编译所有的 Sass 31 次以上。此外，我们使用 Sass 和 Compass 作为我们的编译器(而不是更快的 LibSass ),在 31 个主题中，每个文件只需要 3-5 秒。每当你想做出改变的时候，等待 2-3 分钟是远远没有效率的。

有几条路可以解决这个问题。第一种方法是编译一个包含所有默认样式的核心样式表，然后编译几个更小的样式表来添加特定于站点的文件。这将减少我们必须为每个站点编译的数量，同时仍然允许我们在需要时覆盖完整的配置。然而，因为只有少数网站有大量的主题定制，我们将能够限制有多少额外的工作。

第二种选择是从核心样式表中分离出所有的颜色定义，并在单独的部分中使用它们。然后，我们可以创建一个特定的主题文件，它可以像我们已经做的那样被覆盖。我们仍然需要为特定于站点的修改和特性创建单独的部分文件。但是这些仍然可以与核心样式表分开创建。

这两个选项都会给我们留下多个输出文件，然后我们需要将它们连接成一个文件，作为主题的输出。考虑到我们正在使用 Grunt，并且有任务可以处理连接，这对我们来说应该很简单。我们只需要对这些解决方案的效率进行一些测试，包括编译时间和输出 CSS 的相对大小。

## 结论

说到主题化，Sass 可能是一个非常强大的盟友。能够使用变量来存储你的主题设置，并使用`!default`标志来覆盖它们，这使得这个特性不仅仅是易于重用。当你设置好合适的条件时，主题化也会变得更容易。创建一个易于理解的、以项目为中心的命名约定，远离那些在值改变时可能被误解的名称。记住要注意潜在的问题，比如缩放，因为你可以看到它会对你的工作流程产生相当大的影响。主题快乐！

## 分享这篇文章