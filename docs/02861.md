# 名称又能代表什么呢难题的反模式

> 原文:[https://www . site point . com/whats-in-a-name-anti-patterns-to-a-hard-problem/](https://www.sitepoint.com/whats-in-a-name-anti-patterns-to-a-hard-problem/)

![hildren's names written on a brick wall](../Images/3336d1b57f5cd9a47dfc55178e86fbd9.png)

> 如果你希望从零开始做一个苹果派，你必须首先创造宇宙。—卡尔·萨根

我们不停地命名。和名字。命名是出了名的困难，但并不是每次我们都要从头开始。我们有习惯、惯例和个人风格。

通常我们不会给一个名字太多的想法，我们仍然做一个合理的工作。当然，有时候我们的第一个想法很糟糕。

没有选择名字的公式。在某些情况下，我们的习惯是不好的。我们的策略——不管有没有明说——都有不足之处。命名充满了歧义。一个好名字回答了重要的问题。它包含什么？为什么会存在？为什么重要？这是什么意思？我将如何使用它？起到什么作用？但是它很难一下子回答所有重要的问题。一个坏名字是令人困惑或无益的。它误导和误导。

有一些常见的策略弊大于利。认识到一个反模式可以更容易地选择一个更好的策略。更好的策略往往会带来更好的名声。

> 反模式是对反复出现的问题的常见反应，通常是无效的，并且有可能产生非常不利的后果。—维基百科

与所有事物命名一样，反模式并不总是错误的选择。通常的告诫适用于:“通常”、“可能”、“也许”、“运用你的判断力”等。等。

## 基础类型和数据结构

如果你看到一个编码底层类型的名字，比如`word_string`或`new_hash`，几乎总会有更好的名字在后面等着你。

类型信息并不那么引人注目。它没有回答任何重要的问题。在大多数情况下，这是不相关的。类型是实现细节，实现细节可以改变，而不会从根本上改变解决方案。

```
def anagrams(string, string_array)
  string_array.each do |str|
    str != string && same_alphagram?(string, str)
  end
end 
```

这段代码很简单。名称是正确的，但没有帮助。

面对平淡无奇的数据类型集合时，您可以问自己的一个问题是:

> 它包含什么？

就字谜而言，它包含单词。

```
def anagrams(word1, words)
  words.each do |word2|
    word1 != word2 && same_alphagram?(word1, word2)
  end
end 
```

现在我们有一个不同的问题。我们在用词，这样我们就可以用词。在`words`、`word1`和`word2`之间没有有意义的区别。我们需要说一些关于单词在检测变位词的上下文中是如何相互联系的。

> 原始单词或短语被称为变位词的*主语*。—维基百科

所以`word1`就是*主语*。我们正在循环的`words`可能是也可能不是字谜。他们是`potential_anagrams`，但是名字里重复`anagram`有点烦。潜在匹配的另一个词是`candidate`。

```
def anagrams(subject, candidates)
  candidates.each do |candidate|
    subject != candidate && same_alphagram?(subject, candidate)
  end
end 
```

当计算拼字游戏分数时，我们会碰到同样的事情。

```
def compute_score(chars)
  chars.inject(0) {|num, char|
    num + char_to_num[char]
  }
end 
```

再一次，问问你自己变量包含什么，这一次是在拼字游戏的背景下。num 是我们正在计算的东西，分数。*字符*是字母或瓷砖。字符到数字的散列包含每个图块的点值。

```
def compute_score(tiles)
  tiles.inject(0) {|score, tile|
    score + points[tile]
  }
end 
```

在名称中使用数据类型并不总是反模式。

当作用域很小时，给变量起一个更有表现力的名字可能是多余的。上下文已经回答了关于它的重要问题。没有理由用额外的描述来膨胀代码。只需使用类型，比如用`s`表示字符串，用`i`表示整型。

有时数据结构的名称有助于阐明重要的细节。A `queue`是程序员熟悉的概念。名称`jobs`可能会传达你的意图。但也许不是。如果 FIFO(先进先出)方面是至关重要的，那么`job_queue`可能会更好。它表达了事物包含的内容，以及如何使用它。

## 结构的

另一个常见的策略是根据事物在程序中的角色来命名它们。它是输入或输出。这是重复出现的短语或中间的句子。它是一个备忘录或总和或结果。

这里有一些计算差异的代码，这是一种被称为[汉明距离](https://en.wikipedia.org/wiki/Hamming_distance)的算法的简化。

```
def self.compute(first, second)
  first.length.times.count { |i|
    first[i] != second[i]
  }
end 
```

这种算法很有表现力，但是名字`first`和`second`似乎很随意。它们是第一个和第二个参数，但是顺序重要吗？不清楚。还有`first`和`second`什么？

第一和第二条 DNA 链。咄。

事实证明，顺序并不重要。我们只关心两条相似的链之间有多少突变。

名字`strand`回答了它是什么的问题。一个简单的后缀来区分这两者就足够了。我们不需要讲更多的故事了。我们可以使用`A`和`B`，它们不像`1`和`2`那样强调顺序。

```
def self.compute(strandA, strandB)
  strandA.length.times.count { |i|
    strandA[i] != strandB[i]
  }
end 
```

这是之前的拼字游戏评分方法，有结构名称。

```
def compute_score(input)
  input.inject(0) {|sum, x|
    sum + lookup[x]
  }
end 
```

关于*输入*有趣的事情不是它碰巧作为参数传递给方法。有趣的是*中包含的*，在这个例子中是拼字游戏。同样地，`sum`不是任何旧的总数，而是某人的分数。这是一个不可否认的事实，我们正在寻找一些东西，但`lookup`解释不了什么本质。问题是*你在查什么*？分。如果你去寻找，这里就有戏剧。

## 想法片段

在 Ruby 中，这是一个诱人的陷阱，一旦你发现它，你就无法视而不见。到处都是。

它如此诱人的原因是它导致了许多小方法。

> “等等，什么？”

是啊，对不起。不是说小方法不好。而是一切都是有得有失。原来还有比 SLOC(源代码行)更重要的东西。谁知道呢？

下面是一些代码中安排聚会的方法:

```
def prev_or_next_day(date, date_type)
  date_type == :last ? date.prev_day : date.next_day
end 
```

方法的名称重复了它所包含的条件。

这没有一个好的名字，因为这种方法不能孤立出一个完整的想法。它把一个想法的一小部分放在一个方法中。当每个方法代表一个概念的一个片段时，解决方案就变得不可理解了。你可以把所有独立的片段放入你的大脑，但它们不能形成一个连贯的画面。

这里的解决方案是将它与代码中任意定义的方法中的所有其他想法片段一起内联到它的来源。然后——一旦所有东西都在同一个地方——你更有可能找到并说出整个想法。

## 实现片段

有时候方法隔离了完整的思想，但是方法名没有抓住要点。

一些生成 99 瓶啤酒歌曲的歌词的代码中就有这个方法。

```
def bottle_or_bottles(quantity)
  if quantity == 1
    "bottle"
  else
    "bottles"
  end
end 
```

(以上摘自一本[即将出版的关于用这首歌学习 OOP 的书](http://99bottlesbook.com)。充分披露，我是这本书的合作者之一。)

这也重复了条件句。瓶子和瓶子是同一个概念的两个不同实例。同一概念的其他片段可能是“咆哮者”或“小桶”或“六罐装”。

```
def container(quantity)
  if quantity == 1
    "bottle"
  else
    "bottles"
  end
end 
```

一个好名字不会加入杂草中的实现。它抬起眼睛，看到了一个更大的画面。

这里有一个在代码中找到的方法来生成歌曲的歌词，歌词是“我知道一个吞下一只苍蝇的老太太”。

```
def swallowed
  "She swallowed the #{predator} to catch the #{prey}."
end 
```

捕食者和猎物是很棒的名字。它们解释了变量包含的内容，以及它们之间的关系。但是`swallowed`对读者帮助不大。

作者取了实现的一小部分，并对其名称进行了呼应。

一个方法应该命名一个想法，而不是一个想法的一个随机的小片段。歌曲讲的是一个小老太太莫名其妙吞了一只苍蝇。然后她吞下越来越大的生物，使问题复杂化。这个方法分离出了歌曲中试图解释*为什么*有人会做这样的事情的部分。这解释了 T2 选择背后的推理。她的*动机*。

```
def motivation(predator, prey)
  "She swallowed the #{predator} to catch the #{prey}."
end 
```

## 结论

每个例子都有不同的问题，但是解决它们的策略是相似的。第一步是用英语描述这个问题。编程术语以后可能会变得很重要。现在，只需找到来自该领域的单词。

拼字游戏有点数、分数和方块。

字谜是关于单词的。但不仅仅是文字。以特定方式相互关联的单词。一个主题和候选人。

两条 DNA 链之间的海明距离不是任何旧的总和，而是突变的计数。

任何歌曲都可以有第一行和最后一行。许多歌曲会有重复出现的句子。一首关于喝啤酒的歌和一首关于吞咽小动物的歌是有区别的。这些差异很重要。

进行有意义的区分。删除多余或不必要的细节。

总之，讲好故事。

## 分享这篇文章