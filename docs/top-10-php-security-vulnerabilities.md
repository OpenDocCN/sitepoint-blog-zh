# 十大 PHP 安全漏洞

> 原文：<https://www.sitepoint.com/top-10-php-security-vulnerabilities/>

安全不是你要做的事情的列表。安全是一种思考方式，一种看待事物的方式，一种应对世界的方式，这种方式说“我不知道他们会怎么做，但我知道他们会试图整我”，然后，与其陷入一种存在主义的恐惧，不如主动预防问题。

但是，你不能违背统计数据。没有人会去读一篇题为“安全编码”的文章每个人都想要一篇有数字的文章:“8 种最常见的 PHP 安全攻击以及如何避免它们”，“不要对超级模特说的 23 件事”，以及“避免辐射中毒的 15 个理由。”所以，下面是“十大 PHP 安全漏洞”

## SQL 注入

头号杀手是 SQL 注入袭击。在这种情况下，有人在 URL 或 web 表单中输入一个 SQL 片段(经典的例子是 drop database 语句，尽管有许多不包括删除的可能性，这些删除可能具有同样的破坏性)作为值。现在先别管他是怎么知道你的表名的；那完全是另一个问题。你面对的是一个阴险而足智多谋的敌人。

那么，你能做些什么来避免这种情况呢？首先也是最重要的，你需要怀疑你从用户那里接受的任何输入。相信大家都很好？只要看看你配偶的家庭…他们都很怪异，有些非常危险。

防止这种事情的方法是使用 PDO 准备好的报表。我现在不想对 PDO 进行全面的讨论。可以说，准备好的语句将数据与指令分开。这样做可以防止数据被视为数据以外的任何东西。要了解更多信息，您可能想看看 Timothy Boronczyk 的文章[从 MySQL 扩展迁移到 PDO](https://www.sitepoint.com/migrate-from-the-mysql-extension-to-pdo/ "Migrate from the MySQL Extension to PDO") 。

## XSS(跨站点脚本)

诅咒那些在这种欺骗中茁壮成长的黑心。父母们，今天要和你们的孩子谈谈，以免他们成为邪恶的 XSS！

任何 XSS 攻击的本质都是将代码(通常是 JavaScript 代码，但也可以是任何客户端代码)注入 PHP 脚本的输出。当您显示发送给您的输入时，例如您在论坛发帖时，这种攻击是可能的。攻击者可能会在他的消息中发布 JavaScript 代码，对您的站点进行不可描述的操作。请不要让我细说；我的心为这些强盗的所作所为而哭泣。

要了解更多信息以及如何保护自己，我建议阅读 PHPMaster 上的这些优秀文章:

*   乔治·费克特的交叉脚本攻击
*   Toby Osbourn 使用过滤函数进行输入验证

## 源代码揭示

这一点与人们能够看到文件的名称和内容有关，在 Apache 的配置发生故障时，他们不应该看到这些内容。是的，我明白，这不太可能发生，但它可能发生，而且保护自己相当容易，为什么不呢？

我们都知道 PHP 是服务器端的——你不能只通过查看源代码来查看脚本代码。但是如果 Apache 出了什么问题，突然之间你的脚本变成了纯文本，人们会看到他们从来没有想过要看到的源代码。其中一些代码可能会列出可访问的配置文件，或者包含数据库凭据等敏感信息。

该解决方案围绕如何为应用程序设置目录结构展开。也就是说，坏人能看到一些代码并不是一个大问题，而是如果敏感文件保存在公共目录中，他们能看到什么代码。将重要文件放在公众可访问的目录之外，以避免这种错误的后果。

有关这方面的更多信息，包括您的目录结构的示例，请参见本文中的[点 5。关于此话题的更多讨论，请参见](http://www.phpfreaks.com/tutorial/php-security "PHP Security")[本次论坛讨论](http://forums.phpfreaks.com/topic/206394-external-file-access/ "External file access")。

## 远程文件包含

请稍等，我会解释一下:远程文件包含是指远程文件被包含在您的应用程序中。很深，是吧？但是为什么这是一个问题呢？因为远程文件不可信。它可能被恶意修改，包含了您不希望在应用程序中运行的代码。

假设你有这样一种情况，你在 www.myplace.com 的站点包括 www.goodpeople.com/script.php.图书馆，一天晚上，www.goodpeople.com 被入侵，文件的内容被替换为恶意代码，这将毁坏你的应用程序。然后有人访问你的网站，你拉进更新的代码，然后砰！那怎么阻止呢？

幸运的是，解决这个问题相对简单。你所要做的就是打开你的`php.ini`并检查这些标志上的设置。

*   `allow_url_fopen`–表示是否可以包含外部文件。默认设置为“开”,但您想关闭它。
*   `allow_url_include`–表示`include()`、`require()`、`include_once()`和 require_once()函数是否可以引用远程文件。默认设置为关闭，关闭`allow_url_fopen`也会强制关闭。

## 会话劫持

会话劫持是指一个不怀好意的人窃取并使用别人的会话 ID，就像保险箱的钥匙一样。当客户机和 web 服务器之间建立会话时，PHP 会将会话 ID 存储在客户机端的一个 cookie 中，这个 cookie 可能叫做 PHPSESSID。将 ID 和页面请求一起发送可以让您访问服务器上持久化的会话信息(它填充了超级全局`$_SESSION`数组)。

如果有人窃取了会话密钥，这有什么不好吗？答案是:如果你在那个会话中没有做任何重要的事情，那么答案是否定的。但是如果你使用那个会话来认证一个用户，那么它将允许一些卑鄙的人登录并进入东西。如果用户很重要并且有很大的权限，这就特别糟糕。

那么人们是如何窃取这些会话 id 的呢？像我们这样虔诚的人又能做些什么呢？

会话 id 通常通过 XSS 攻击被窃取，因此防止这些是一件好事，可以产生双重效益。尽可能频繁地更改会话 ID 也很重要。这减少了你的盗窃窗口。在 PHP 中，您可以运行`session_regenerate_id()`函数来更改会话 ID 并通知客户端。

对于使用 PHP5.2 及以上的人(你是吧？)，有一个`php.ini`设置将阻止 JavaScript 访问会话 id ( `session.cookie.httponly`)。或者，您可以使用`session_set_cookie_parms()`功能。

如果你使用共享主机服务，会话 id 也可能是易受攻击的服务器端，共享主机服务将会话信息存储在全局可访问的目录中，如`/tmp`。您可以简单地通过将您的会话 ID 存储在磁盘或数据库中只有您的脚本可以访问的位置来阻止这个问题。

## 跨站点请求伪造

跨站请求伪造(CSRF)，也称为布雷特特立独行，或肖恩斯潘塞，赌博，涉及欺骗一个相当不知情的用户发出一个请求，我们应该说，不是他的最佳利益。但是与其让我喋喋不休地谈论 CSRF 攻击，不如参考一个 PHPMaster 上内容的杰出例子:[防止跨站点请求伪造](https://www.sitepoint.com/preventing-cross-site-request-forgeries/ "Preventing Cross-Site Request Forgeries (CSRF)")作者 Martin Psinas。

## 目录遍历

像其他许多攻击一样，这种攻击寻找安全性不尽如人意的站点，当找到一个时，它会导致文件被访问，而所有者并不打算公开访问这些文件。它也被称为../(点，点，斜线)攻击，攀爬攻击和回溯攻击。

有几种方法可以抵御这种攻击。第一是非常非常努力地希望这不会发生在你身上。有时候向仙女和独角兽许愿会有帮助。有时候不会。第二个是使用白名单定义给定请求可以返回哪些页面。另一种选择是将文件路径转换为绝对路径，并确保它们引用允许目录中的文件。

## 摘要

这些是十大问题，如果你不小心避免，会让你的 PHP 应用程序被攻破。是的，10 分钟。数一数… 1，2，3…什么？你只数了 8 个？好吧，也许 7 个。好吧，那让你知道你是多么容易被愚弄，我甚至不是坏人！

<small>图片 via[Fotolia](http://us.fotolia.com/?utm_source=sitepoint&utm_medium=website_link&utm=campaign=sitepoint "Royalty Free Stock Photos at Fotolia.com")</small>

## 分享这篇文章