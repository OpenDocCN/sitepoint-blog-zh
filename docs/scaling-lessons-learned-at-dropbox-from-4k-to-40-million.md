# 扩展 Dropbox 的经验教训:从 4k 到 4000 万

> 原文：<https://www.sitepoint.com/scaling-lessons-learned-at-dropbox-from-4k-to-40-million/>

## Dropbox 从 4K 扩展到 4000 万

有一段时间，我负责扩展 Dropbox，从大约 4000 人增加到 4000 万人。在那段时间的大部分时间里，我们有一到三个人在做[后端](https://en.wikipedia.org/wiki/Front_and_back_ends)。这里有一些关于扩展的建议，特别是在资源有限、快速发展的环境中，这种环境不能总是以“正确的方式”做事，即任何真实世界的工程项目！

## 带额外负荷运行

我们反复使用的一种技术是在实时站点中创建人工的额外负载。例如，我们会做很多不必要的 memcached 读取。然后当 memcached 崩溃时，我们可以快速关闭重复的查询，有时间想出一个解决方案。为什么不提前计划呢？因为大多数时候，这是一个非常突然的故障，我们无法用监控检测到。请注意，仅仅进行额外的读取并不完美，因为高写入负载更有可能导致问题，但是写入很难模拟(危及数据的风险，没有获得实际数量的锁争用)。根据我的经验，仅仅额外的阅读就足以赢得时间。

## 特定于应用的指标

在扩展过程中，另一件变得越来越有用的事情是将数千台服务器上的数千个自定义统计数据汇总成图表。大多数开箱即用的监控解决方案并不打算处理这种负载，我们想要一种添加统计数据的单行方式，这样我们就不必考虑它是否有任何成本，或者只是为了添加一个统计数据而在配置文件上做文章(减少测试和监控的摩擦是一个重要的优先事项)。我们选择在 memcached、cron 和 [ganglia](https://ganglia.sourceforge.net) 的组合中实现一个解决方案。每当发生我们想要绘制的事情时，我们会将它存储在线程本地内存缓冲区中。每一秒钟，我们都会将该统计数据发送到 memcached 中的一个带时间键的桶(timestamp mod 什么的)中，而在一台中央机器上，每一分钟，memcached 中的桶都会被清空、聚合并发送到 ganglia。非常可扩展，这使得我们能够近乎实时地跟踪数千个统计数据。即使像“读取一个 memcached 键的平均时间”这样细粒度的统计数据(每个请求发生几十次)也能很好地执行。当然，当你有成千上万的统计数据时，仅仅“看图表”来发现异常是很困难的。这里有一个我们认为最有用的总结图:![](img/951795308b9834b0c3518aa3bdc5b481.png)

顶行代表站点的平均响应时间(我们有一个 web 流量的图表，一个客户端流量的图表)。每个部分代表一个工作的划分。因此，您可以看到在 1:00 左右出现了一个响应时间峰值，这是由 MySQL 提交阶段的某个问题引起的。我们实际的图形有更多的段，所以想象一下当你试图计算时，这能节省多少屏幕空间。“CPU”是欺骗，它实际上只是平均响应时间减去我们排除的所有其他因素。如果有一种方法可以做到这一点，那么在图形上标记出可以注释的事件(比如代码推送或 AWS 中断)也是很酷的。

## 用 bash 分析穷人

如果您没有经常使用 shell，那么某些任务的速度之快会让您大开眼界。假设您正在尝试调试您的 web 服务器中的某个东西，您想知道最近是否有一个活动高峰，而您所拥有的只是日志。为该 web 服务器绘制图形是很好的，但是如果像大多数系统一样间隔 1 或 5 分钟，可能不够细粒度(或者您可能只想查看某一类请求，或者其他什么)。

```
Apr 8 2012 14:33:59 POST ...
Apr 8 2012 14:34:00 GET ...
Apr 8 2012 14:34:01 POST ...
```

您可以像这样使用您的 shell:

```
cut -d’ ’ -f1-4 log.txt | xargs -L1 -I_ date +%s -d_ | uniq -c | (echo “plot ‘-’ using 2:1 with lines”; cat) | gnuplot
```

嘣！

很快你就有了一个很好的图形，你可以很容易地修改它(只选择一个 URL，改变成柱状图，等等。).几乎所有的命令行工具都将行分隔、空格分隔的 2D 数组作为输入，并在必要时进行隐式数值转换，因此通常不需要对管道程序一起进行反向操作。它们也不会在坏数据上抛出异常，我认为这是一件好事，当你只是试图快速做一些事情，而不在乎一些丢失的数据点时。如果你不熟悉命令行工具，我推荐你熟悉以下列表:`sed, awk, grep, cut, head, tail, sort, uniq, tr, date, xargs`

## 垃圾日志真的很有帮助

垃圾日志并没有那么糟糕。我们曾经有如此多的随机打印语句分散在代码中，这些语句最终会出现在我们的 web 服务器日志中，但是我无法计算有多少次它被证明是无意中有用的。这几乎是一种随机跟踪代码的方式。例如，在调试一个特别糟糕的竞争条件时，我注意到一个特殊的“## your special comment ##”没有打印在它应该打印的地方，这就清楚了问题发生在哪里。

## 如果有些事情可能会失败，那就确保它会失败

如果您知道某些东西可能会在任何时候失败，并且您认为故障转移会很顺利，那么您实际上应该经常测试这一点。随机将该服务器从网络中移除，并确保故障转移正常工作，因为可能会发生以下几种情况:

1.  自上次故障切换以来，增加的负载意味着故障切换过程现在会导致级联。
2.  从上次故障转移到现在，已经有大量的代码推送、数据库模式更改、内部 DNS 重命名等。因此，从那以后没有运行过的任何脚本都可能依赖于旧的假设。

这些事情在和平时期比较好搞清楚，所以最好是故意让这种事情发生。也许在现场运行消防演习听起来很愚蠢，但是测试环境是不够的，这是非常好的保险。

## 一般来说，更经常地运行不常用的东西

以上几点也适用于那些不经常在你的代码库中运行的东西。如果您能够更频繁地通过不常用的代码路径推送代码，这将省去一些麻烦。例如，如果您有一个每月运行的 cron，可以每天或每周运行一次，以确保至少假设是一致的，这样您就不必在一个月的提交后调试它。只手动运行的脚本也是如此。

## 尽量保持事物的同质性

很久以前，我们有两个用户数据碎片，一旦它开始变满，我就添加第三个碎片来放入新用户。该死，真让人头疼！然后我们有两个碎片以几乎完全相同的速度生长，一个新的生长得更快，这意味着我们必须在不同的时间重新生长。更好的办法(但显然更棘手)是将每个碎片一分为二，并保持它们看起来都一样。同质性对硬件也有好处，因为容量规划变成了一个更简单的问题。

## 记录停工日志

每当站点停机或降级时(即使是短暂的停顿)，记下停机的开始和结束时间，然后标记任何适用的原因(糟糕的代码审查、不充分的监控、日志溢出)。然后，当你看着列表时，你可以客观地回答这个问题“我现在该怎么做才能最大限度地减少停机时间？”通过找出如何完成最多的时间。解决方案可能跨越多个问题，每个问题可能有多种解决方式，所以尽可能多地写下来会有所帮助。例如，适当的监控可能会提醒您即将出现的磁盘已满问题，或者您可以限制写入磁盘的数据量。

## 协调世界时。亦称 COORDINATED UNIVERSAL TIME

将 UTC 的所有东西都保存在内部！服务器时间，数据库里的东西，等等。这将省去很多麻烦，不仅仅是夏令时。有些软件甚至不能正确处理非 UTC 时间，所以不要这样做！我们在墙上挂了一个时钟，设置为协调世界时。当您想要向用户显示时间时，请在最后一秒进行时区转换。

## 我们使用的技术

对于那些对我们的选择和原因感到好奇的人，我们使用的软件是:

1.  Python 几乎无所不包；不超过几千行 C 语言
2.  MySQL 的实现
3.  Paster/Pylons/Cheetah (web 框架——除了模板化和处理表单输入之外的最小使用)
4.  用于存储和服务文件块的 S3/EC2
5.  数据库前面的 memcached，用于处理服务器间的协调
6.  ganglia 用于绘图，drraw 用于自定义图形，如上面提到的堆栈图
7.  nginx 用于前端服务器
8.  haproxy 用于应用服务器的负载平衡，在 nginx 之后(比 nginx 的平衡模块更好的可配置性)
9.  nagios 进行内部健康检查
10.  用于外部服务监控和寻呼的 Pingdom】
11.  用于将 IP 映射到位置的 GeoIP】

相当标准。我们选择这些东西的原因都是一样的——可靠性。即使是 memcached，这种概念上最简单的技术，被许多其他公司使用，也有一些我们必须处理的非常糟糕的内存损坏错误，所以我不敢想使用更新更复杂的东西。对于选择技术，我唯一的建议是选择那些在你的公司之外有用的轻量级产品，或者做好成为项目“主要贡献者”的准备。

## 尝试之前先模拟/分析

与难以推理的产品不同，后端工程相当客观(优化页面加载时间、正常运行时间等)。)所以我们可以利用这一点。如果你认为某事会产生结果，你可以考虑在实施之前用一种更简单的方式来模拟结果。就像把你的数据库服务器转移到一个延迟更长的地方一样，在你的底层数据库中增加几毫秒的延迟，看看会发生什么。

## 安全性和便利性的权衡

安全对于 Dropbox 来说真的很重要，因为这是人们的个人文件。但是所有的服务都是不同的，许多安全决策会给某人带来不便，无论是程序员还是用户。在不需要相互通信的服务器之间安装内部防火墙——这也是一个好主意。但是，如果您的服务实际上不需要这样做，就不一定要这样做，或者在重要的地方这样做。也许这是有争议的…但是安全是人们喜欢口头上说说和纸上谈兵的东西，但是实际上我认为很多服务(甚至银行！)有严重的安全问题。所以弄清楚它是否真的对你很重要(你值得被黑吗？你真的在乎自己被黑吗？是否值得工程或产品成本？)在你走之前，锁好一切。

## 分享这篇文章