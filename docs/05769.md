# 如何加快你的应用程序的 API 消耗

> 原文:[https://www.sitepoint.com/speed-apps-api-consumption/](https://www.sitepoint.com/speed-apps-api-consumption/)

## 介绍

在创建 PHP 应用程序的过程中，您可能会遇到这样一种情况:将它与远程资源或服务隔离开来可能会成为开发中的一个障碍。为了推进项目，你可以使用不同的 API 服务来获取远程数据，连接其他网站上的用户帐户，或者转换应用程序共享的资源。

[ProgrammableWeb](http://www.programmableweb.com/) 网站称，目前网络上有超过一万个可用的 API，所以你可能会发现很多可以用来扩展你的 PHP 应用功能的服务。但是以不正确的方式使用 API 会很快导致性能问题，并延长脚本的执行时间。如果您正在寻找避免这种情况的方法，可以考虑实现本文中描述的一些解决方案。

### 一次提出多个请求

![](../Images/5fce854270f45d8f18c54e213242c0de.png)

当执行一个典型的 PHP 脚本时，代码中的命令会一个接一个地运行。这看起来完全合乎逻辑，因为您可能希望获得上一个操作(例如，数据库查询或变量操作)的结果，以进入脚本的下一步。当您进行 API 调用时，同样的规则也适用。你必须发送一个请求，等待远程主机的响应，然后你可以对收到的数据做任何事情。但是，如果您的应用程序进行了几次 API 调用，并且您需要来自每个源的数据继续前进，您不必单独执行每个请求。记住，负责处理 API 调用的服务器准备好一次处理几个查询。你需要做的只是创建一个并行执行 API 调用的脚本，而不是一个接一个。幸运的是，PHP 提供了一组用来做这件事的`curl_multi`函数。

使用`curl_multi`函数类似于用 cURL 库在 PHP 中发出典型的请求。唯一的区别是，您需要准备一组要用 [curl_init](http://php.net/manual/en/function.curl-init.php) 函数执行的请求(而不是一个),并将它们传递给 [curl_multi_add_handle](http://php.net/manual/en/function.curl-multi-add-handle.php) 函数。然后，调用 [curl_multi_exec](http://php.net/manual/en/function.curl-multi-exec.php) 函数将同时执行请求，而 [curl_multi_getcontent](https://php.net/manual/en/function.curl-multi-getcontent.php) 将让您获得每个 API 调用的结果。只需阅读[这里的](http://www.phpied.com/simultaneuos-http-requests-in-php-with-curl/)来查看实现所述逻辑的代码示例。

如果你想在你的 PHP 应用程序中使用`curl_multi`函数，有一些要点需要记住。首先， [curl_multi_exec](http://php.net/manual/en/function.curl-multi-exec.php) 函数将花费传递给 [curl_multi_add_handle](http://php.net/manual/en/function.curl-multi-add-handle.php) 函数的请求集中最慢的 API 调用的时间。因此，在每个 API 调用花费相似时间的情况下，使用`curl_multi`是有意义的。如果在一个`curl_multi`集合中有一个请求明显比其他的慢，那么你的脚本将无法继续，直到那个最慢的请求完成。

同样重要的是，您需要确定一次可以执行的并行请求的数量。请记住，如果您的站点处理大量流量，并且每个用户同时触发对一个远程服务器的 API 调用，那么一次发出的请求总数可能会很快变高。不要忘记检查 API 文档中规定的限制，并了解当您达到这些限制时服务将如何响应。当您达到限制时，远程服务器可能会发送特定的 HTTP 响应代码或错误消息。这种情况应该由您的应用程序正确处理，或者记录在日志中，以便您可以诊断问题并减少请求的数量。

### 将 API 调用与应用程序主流程分开

如果您希望保持 web 应用程序的响应性，并避免提供加载缓慢的页面，那么对远程服务器的大量 API 调用可能会使这项任务变得更加困难。如果所有请求都是在主应用程序流中发出的，那么最终用户将看不到呈现的页面，直到 PHP 脚本接收到 API 响应并处理数据。当然，有许多 API 服务托管在快速服务器上，可以快速处理请求。但是，您的应用程序可能偶尔会因为连接延迟或一些影响连接过程或远程服务器本身的随机因素而变慢。

如果您想保护最终用户免受此类问题的影响，您需要将应用程序中负责处理主流程请求的部分分离到一个独立的脚本中。这意味着 API 调用将在一个独立的线程中执行，不会干扰负责显示站点的代码部分。

要实现这样一个解决方案，你只需编写一个单独的 PHP 脚本，并使用`exec()`函数执行它，就像你执行任何命令行应用程序一样。不同的 PHP 框架通常提供简化命令行脚本编写的模块，并允许您轻松地将它们与现有的应用程序模型或组件集成。只需检查 [Symfony2](http://symfony.com/doc/current/components/console/introduction.html) 或 [CakePHP](http://book.cakephp.org/2.0/en/console-and-shells.html) 控制台组件就能看到一些例子。各种 PHP 平台——不仅仅是框架——也可能提供工具来简化命令行脚本的编写，比如[WP CLI](http://wp-cli.org/)—WordPress 的命令行界面。

如果你正在寻找一种更强大的方法来处理独立进程中的 API 调用，考虑建立一个像 [Gearman](http://gearman.org/) 这样的作业服务器。作业服务器是一个完整的解决方案，它执行将特定任务(`jobs`)分成独立进程所需的所有操作。阅读 Alireza Rahmani Khalili 的[gear man](https://www.sitepoint.com/introduction-gearman-multi-tasking-php/)介绍文章，查看它是如何工作的，以及如何用 PHP 实现它。如果您在 Zend 服务器平台上工作，您可以使用提供类似功能的 [Zend 作业队列](http://files.zend.com/help/Zend-Server/zend-server.htm#jobs_component.htm)组件。Alex Stetsenko 撰写的文章[用 Zend 作业队列调度](https://www.sitepoint.com/zend-queue/)中描述了它的特性和使用示例。

无论您选择哪种分离 API 调用的解决方案，您都必须为应用程序的不同部分找到一种相互通信的方式。首先也是最重要的，你应该把从 API 调用接收到的数据放在一个整个应用程序都可以访问的地方(比如一个数据库表或者一个文件)。您还必须共享单独脚本的执行状态。主应用程序必须知道外部执行的 API 调用是否已经在进行中，是否已经完成或者已经失败。如果您考虑使用作业服务器解决方案，它可能会提供监控作业状态的功能。但是如果您只想坚持编写一个简单的 PHP 命令行脚本，您将不得不自己实现这样的逻辑。

**多 HTTP 请求还是多线程？**
那么哪种解决方案更好呢——使用`curl_multi`函数一次执行几个 HTTP 请求还是将 API 调用从主应用程序流中分离出来？这取决于查询远程服务器的上下文。您可能会发现，整个 API 调用处理脚本花费的时间很长，不仅仅是因为发出了请求。还可能有大量代码负责处理接收到的数据，尤其是当它包括转换文件或进行大量数据库写入时。在这种情况下，使用`curl_multi`函数可能不足以加速你的应用程序。运行负责整个操作的单独线程，并处理从远程主机接收的数据，可能会在应用程序的性能方面获得更好的结果。另一方面，如果你需要执行大量简单的 API 调用，而这并不涉及大量的数据处理，那么坚持使用`curl_multi`函数可能就足以让你的应用程序运行得更快。

当然还有第三种解决方案——混合上述两种方法。因此，您可以运行一个负责处理 API 调用的单独线程，然后通过一次发出多个请求来尝试让它运行得更快。这可能比为每个请求执行单独的脚本更有效。但是，这可能还需要对如何设计脚本流进行更深入的分析，以便不同的脚本执行和同时执行的不同 API 调用不会相互干扰，也不会重复彼此的工作。

### 构建智能缓存引擎

加速严重依赖 API 使用的应用程序的另一个解决方案是构建一个智能缓存引擎。它可能会阻止您的脚本进行不必要的调用，因为位于不同服务器上的内容没有改变。适当的缓存还可以减少单个 API 调用中服务器之间传输的数据量。

要编写一个能够正常工作并返回有效数据的缓存引擎，您需要确定远程服务器的响应不会改变的情况，这样就没有必要每次都获取它。这可能会因特定的 API 服务而异，但总的想法是找到一组参数(在请求中传递),这些参数在给定的时间段内给出相同的响应。例如，如果您从远程服务获取每日货币汇率，您可以确保给定货币的汇率(这是参数)全天保持不变。因此，用于存储从这个特定 API 接收的数据的缓存键必须包含货币和日期。如果您的应用程序下次必须获取这个特定的汇率，您可以参考保存在缓存中的数据(例如，在数据库或文件中)并避免发出 HTTP 请求。

上述场景假设您的应用程序负责检查从远程服务接收的数据何时可以缓存，因此您需要自己实现适当的缓存逻辑。但是也有这样的情况，API 服务跟踪它共享的数据的变化，并返回包含与特定资源链接的元数据的附加字段。元数据可以由诸如最后修改日期、修订号或基于资源内容计算的散列值组成。利用这些数据可以很好地提高 PHP 应用程序的性能，尤其是在处理大量数据时。您不需要在每次与 API 连接时获取整个资源，只需要将时间戳或散列值与您上次收到的值进行比较。如果它们相等，就意味着您可以使用之前获取的数据，因为远程内容没有改变。这种解决方案假设您在应用程序中使用了缓存引擎，但是您不需要担心存储在缓存中的数据是否有效。因为您依赖于 API 服务返回的元数据，所以您只需要比较远程服务器给出的元数据值。

当采用文件托管服务 API 时，使用远程资源元数据可能特别有益。使用远程文件夹和文件通常意味着传输大量数据，这可能会导致性能问题。为了举例说明如何避免这种情况，让我描述一下 Dropbox API 中使用的解决方案。Dropbox API 服务返回特定的数据，用于检查远程文件是否已经更改。首先，[元数据](https://www.dropbox.com/developers/core/docs#metadata)方法(它返回文件夹和文件的信息，如它们的名称、大小或路径)包含代表返回资源的哈希值的`hash`字段。如果您在新的请求中提供一个来自前一个请求的哈希值作为参数，并且远程数据在请求之间没有改变，那么 API 将只返回一个 HTTP 304 ( `Not modified`)响应。Drobox API 还提供了 [delta](https://www.dropbox.com/developers/core/docs#delta) 方法，专门用于通知特定文件夹或文件中的更改。在 [API 文档](https://www.dropbox.com/developers/core/bestpractices)中推荐使用哈希值和`delta`方法，因为这可能会给你的应用程序带来显著的性能提升。

### 最后但同样重要的是:掌握 API 文档

这听起来可能是显而易见的，但在某些情况下，通读 API 文档可能会为您提供如何更有效地进行 API 调用的具体解决方案。上面描述的 Dropbox API 用法就是一个非常明显的例子。但是可能有其他方法来减少响应中传输的数据量(例如，只选择几个特定的字段由 API 返回，而不是接收整个数据集)。您还可以检查在单独的请求中执行的操作是否不能同时执行。例如，Google Translate API 的 [translate](https://developers.google.com/translate/v2/using_rest#Translate) 方法(用于获取不同语言的文本翻译)可能会在一个请求中返回多个翻译。通过在单个 API 调用中传递几个文本字符串进行处理，您可以避免多次请求，这可能会节省一些应用程序执行时间。

### 摘要

正如您所看到的，有许多方法可以提高严重依赖远程 API 的 PHP 应用程序的性能。您可以一次执行多个请求——要么使用`curl_multi`函数，要么运行单独的应用程序线程。另一个解决方案是实现一个缓存引擎，它将防止您进行不必要的 API 调用或降低服务器之间传输的数据量。最后，API 服务提供的方法可能会为您提供一些现成的解决方案来获得性能提升，就像在一个请求中执行多个操作一样。

我希望这篇文章能让您对如何有效地处理 API 请求有所了解。如果您对本文中提出的要点有任何意见，或者对如何加速使用 API 有任何其他建议，请随意发表在下面。也可以通过 [Google Plus](https://plus.google.com/112138584619019192671?rel=author) 直接联系我。

## 分享这篇文章