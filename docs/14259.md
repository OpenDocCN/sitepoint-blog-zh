# 一些 PHP，用 Python 生成

> 原文：<https://www.sitepoint.com/some-php-generated-with-python/>

最近看了一些代码，它们提供了一种为不同人类语言本地化用户界面的机制。这样做的机制看起来像这样(重复多次)；

 `<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="POST">: <input name="firstname" type="text">
<input type="submit" value="<?php echo $lang['btn_ok']; ?>">
</form>

全局变量$lang 是一个巨大的关联数组，在调用这个函数之前被加载，这取决于用户偏好的语言，就 PHP 数组而言，可能类似于这些文件；

 `'Name',
'btn_ok' => 'OK',`

 `);

？>

‘提名’，
‘BTN _ ok’=>‘授权’，` 

`);` 

有问题的代码也不例外。我见过许多 PHP 应用程序以这种方式处理本地化。在[用 PHP 国际化和本地化](http://www.onlamp.com/pub/a/php/2002/11/28/php_i18n.html)中,“天真”的读者可能会得出这样的结论:这是默认的最佳实践。这篇文章没有错，但是简单的例子/简短的散文的必要性给读者留下了想象的空间。

以这种方式进行本地化的最大问题是它发生在运行时。每个页面请求都会导致页面的本地化版本被动态生成——参见[这里的](https://www.sitepoint.com/blog/),大致了解一下为什么这样不好。

现在也许可以缓存输出 HTML 并将其存储为静态文件，但在一个真实的例子中，我们可能会将真正的动态数据混合在其中，例如来自数据库的一些数据，这使得缓存变得棘手。如果没有缓存，翻译会给每个页面的生成增加大量的基线开销，这将使 UI 变得更加复杂。

同时，只有有限数量的用户界面翻译，只有当用户界面本身改变时才会改变(很少——当然不是在预先请求的基础上)。所以拥有多个版本的 drawNameForm()函数不是更好吗？

 `<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="POST">

名称:<input name="firstname" type="text">
<input type="submit" value="OK">

</form>

和...

 `<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="POST">

<input name="firstname" type="text">
<input type="submit" value="AUTORIZACION">

</form>

当然，谁希望手动维护同一代码的多个版本呢？

对于这个*特定的*问题解决方案已经发展出来，通常打包成模板引擎。[杰夫的](http://www.procata.com/blog/)文件方案在 [WACT](http://wact.sourceforge.net) 实现，在 PHP 脚本上“JIT”生成，正如你在这里看到的。我相信 [Smarty](http://smarty.php.net) 也有类似的功能。只要你对[模板引擎](http://www.massassi.com/php/articles/template_engines/)满意就好。

然而，还有其他类似的问题没有得到很好的解决。例如应用程序配置。这是另一个提示性的片段；

 ``if ( $config['allow_bbcode'] ) {

if ( $user_sig！= '' && $user_sig_bbcode_uid！= '' ) {

$ user _ SIG =($ config[' allow _ bb code '])？

bbencode_second_pass($user_sig，$user_sig_bbcode_uid):

preg_replace('/:[0-9a-z:]+]/si '，']'，$ user _ SIG)；

}

if ( $bbcode_uid！= '' ) {

$ message =($ board _ config[' allow _ bb code '])？

bbencode_second_pass($message，$bbcode_uid):

preg_replace('/:[0-9a-z:]+]/si '，']'，$ message)；

}

}` 

`}` 

关键的一行是；

 ``if ( $config['allow_bbcode'] ) {` 

在每个页面请求上，这个条件(以及许多其他条件)都被重新评估。如果$config['allow_bbcode']为 false，直接删除代码块不是更好吗？有人尝试过构建 PHP 安装程序，有些非常成功，是为单一应用程序设计的(例如 [eZ publish 3](http://ez.no) )，最成熟、最通用的尝试是 [Sandro 的](http://www.zzoss.com/weblog/) [Zzoss 安装程序](http://www.zzoss.com/phpwiki/index.php/ZzossInstaller?nav_node=Software)，我在这里[之前提到过](https://www.sitepoint.com/blog/)。

围绕着用 PHP 编写安装程序这一点，我认为事情开始“分崩离析”，总的来说是因为 PHP 是专门为网站设计的——它不是一个通用的解决方案。这并不是说“永远不会”，而是说，通过考虑其他技术，生活会变得更容易/ PHP 应用程序会变得更好吗？

代码生成在之前[就已经出现在这个博客上了。另一个环节来自【http://www.codegeneration.net/】的](https://www.sitepoint.com/blog/)此后，[这里](http://www.codegeneration.net/lth_archives/000064.html)；

> PHP 很神奇，因为它运行起来非常便宜。你所需要的是 Apache、MySQL 和 PHP，你可以运行一个网站或服务。

...此外，部署脚本是多么容易——只需将它放在 web 服务器上的某个地方，然后就可以开始了——例如，这为“及时”生成打开了大门。

代码生成往往被认为是用一些友好的“拖放”来构建完整的应用程序，例如 [CodeCharge Studio](http://www.yessoftware.com/products/product.php?product_id=1) 。虽然这有它的位置，但它往往是“全有或全无”。

我今天遇到的一种有趣的替代代码生成形式是[面向方面的 PHP](http://www.aophp.net/) 。它使用 Java 对 PHP 脚本进行一些基本的解析，并与第二个“方面”脚本合并(参见这里的[来了解 AOP 是什么)。就性能而言，现在这可能不是一个现实的建议，但它很有趣，因为，首先，他们使用 Java 来完成这项工作，这为他们处理多字节字符或更复杂的解析操作提供了坚实的基础，因为他们正在动态生成 PHP。](http://en.wikipedia.org/wiki/Aspect-oriented_programming)

回到上面的本地化问题，最近在看 [empy](http://www.alcyone.com/software/empy/) :“一个强大而健壮的 Python 模板系统”。到目前为止，使 *empy* 有吸引力的一些事情是，它是为*通用*模板设计的(不是 HTML 专用的)，它是成熟的，标记*与 PHP 和 HTML 非常*不同(你真正需要注意的唯一事情是@符号)，它允许你在需要时使用 [Python](http://www.python.org) 本身作为模板语言。

一个从 drawNameForm()生成 PHP 的 *empy* 模板可能是这样的；

 ``函数 drawNameForm() {

？>

<form action="<?php echo $_SERVER['PHP_SELF'] ?>" method="POST">

@(姓名):<input name="firstname" type="text">
<input type="submit" value="@(btn_ok)">

</form>

我使用过的 *empy* 标记是: *@(名字)*和 *@(btn_ok)* ( *empy* 比这多得多，但是现在，坚持使用一些基本的变量引用)。

在浏览器中查看此函数的输出会产生以下 HTML 源代码；

 ``<form action="/~harry/ui.tpl.php" method="POST">@(name): <input name="firstname" type="text">
<input type="submit" value="@(btn_ok)">
</form>`  `换句话说，我仍然可以将它作为一个有效的 PHP 脚本使用(至少在这个例子中)。

同时，如果我通过 python 脚本运行它(它反过来调用 *empy* ),比如:

 `#!/usr/bin/python
# translate.py`

 `# Load empy
导入 em

#使用字典(像一个相关 PHP 数组)
#作为例子。在实践中使用外部文件...

langs = {}

langs['en'] = {

名称':'名称'，
'btn_ok': 'OK '，

}

沿着[' s ']= {。

名称':'命名'，
'btn_ok ':'自动授权'，

}

#创建一个空解释器

解释者= em。解释程序()

#加载模板 PHP 脚本
tpl = open('ui.tpl.php ')。阅读()

#循环浏览可用的翻译

对于 lang in langs:

#给解释器一个新文件，将输出写入
解释器。output = open('ui。+lang+'。php '，' w ')

# Reset for new parse(使其使用输出文件)
interpreter.reset()

#用单词列表
#填充解释器数据空间，以写入模板
interpreter . globals = langs[lang]

#(重新)解析模板
解释器.字符串(tpl)` 

`interpreter.shutdown()` 

它吐出本地化的 PHP 脚本，文件名标识语言，例如；

 `<form action="<?php echo $_SERVER['PHP_SELF'] ?>" method="POST">

<input name="firstname" type="text">
<input type="submit" value="AUTORIZACION">

</form>

现在，我可以将它作为我的应用程序构建过程的一部分，因为它正在为发布做准备。在运行时，使用这个脚本的代码(手工编码)可能看起来像这样；

 `无论如何——只是沉思和一个显而易见的解决方案，如果你已经在做的话。我不能说这种方法对于大型 PHP 代码库有多好，但是，我猜，只要涉及的脚本保持简单，专注于执行单个任务，没有真正的问题。

关于 Python 的一些特殊点。通过利用像 [py2exe](http://starship.python.net/crew/theller/py2exe/) 或 [py2app](http://undefined.org/python/) 这样的东西，你可以分发可执行的安装程序。加入一些 [wxPython](http://www.wxpython.org) ，你就有了一个用于安装的跨平台 GUI(看起来像真的一样——使用本地小部件)。

有什么故事吗？```` 
``````````` 

## 分享这篇文章