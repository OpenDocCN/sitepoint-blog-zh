# 关于 Android 启动和恢复映像需要知道的事情

> 原文：<https://www.sitepoint.com/things-know-android-boot-recovery-images/>

*本文最初发表在 [TextNow 工程博客上。](https://engineering.textnow.com/android-boot-and-recovery-images-fd756e234c1f)*

为了充分理解 Android 启动和恢复映像的作用，我们首先需要了解 Android 手机的一般启动过程。虽然嵌入式软件不再是我在 TextNow 的日常工作的一部分，但我在以前的一份工作中曾经戴着嵌入式工程师的帽子，并且在业余时间涉足嵌入式电子产品，因此我非常熟悉现代微处理器的启动例程。我必须提醒你，这是一个非常技术性的帖子，但希望对那些正在寻找如何将所有这些结合在一起的参考资料的人有用，如果需要，可以链接到哪里进行更深入的研究。这种类型的帖子在我学习的时候会非常有用:)

## Android 启动过程

当处理器通电并复位时，它会醒来并需要知道该做什么。在现代处理器中，通常有一个非常小的程序嵌入到处理器中，其功能是验证下一个组件的完整性。这个第一个组件有时被称为*安全引导 ROM，*，它的工作是确保它加载的下一个组件是可信的、经过验证的软件。这防止了对系统软件的不希望的篡改，并且因此增加了设备的安全性。这种验证通常涉及某种使用公钥/私钥方案的密码，私钥通常由制造商严格保密。**注意:**通常公钥是由手机制造商在组装时编程的，其内容永远不能改变，因此要求处理器总是运行一个指定的引导加载程序，公钥的私有副本在组装时被烧录。

安全引导 ROM 加载的下一个组件是人们通常所说的*引导加载器*。正如我提到的，引导程序通常用手机制造商的私钥签名，它有几项工作:

1.将引导映像从非易失性存储器(现在通常是 NAND 闪存)加载到易失性存储器(RAM)并运行它。

2.可选地，该图像需要在加载前进行加密验证(目前越来越多的手机甚至不提供解锁引导加载程序以运行未签名图像的方法)。

3.提供将新的引导和其他映像闪存到非易失性存储器的能力，以便将来升级和从故障中恢复。

4.在屏幕上显示某种信息，并有选择地为用户提供一个交互界面。在一些摩托罗拉、谷歌和其他制造商的设备上，这通常被称为*快速启动模式*。

## Android 启动映像

现在我们来看引导过程的最后一个部分——将引导或恢复映像加载到 RAMand 中并运行它。

从技术上讲，启动映像和恢复映像之间没有结构上的差异。唯一的区别是加载了哪个内核和哪个初始 ramdisk，但是它们的打包方式是一样的。我们将回过头来看看这些是如何打包的，以形成一个整洁的引导映像。

运行引导映像涉及几个子步骤:

1.密码验证

2.在所需的内存地址加载(Linux)内核

3.在所需的内存地址加载初始内存磁盘

4.跳转到内核的起始地址

加密验证通常是特定于制造商的，通常很难对这种方法进行逆向工程，尽管这是不可能的——以前已经对某些手机进行过验证(例如，旧款 Kit-Kat 时代的 LG 手机)。

内核是操作系统的心脏，因为它不断发出中断和事件的心跳，使现代操作系统保持运行。这种魔力的起源非常贫乏，它是一个简单的字节块，以这样一种方式编译，以唤醒并从特定的内存地址开始运行。该地址因特定的手机和存储器布局而异。一旦执行开始，内核将开始加载驱动程序，并设置更高级的设施，这样它就可以开始运行一些自己的程序。

内核本身并不知道加载后该做什么。它会坐在那里，什么也不做。但是 Linux 内核*所期望的*是一个预定义内存地址的初始内存盘。这个 ramdisk 包含一个非常基本的、通常是只读的文件系统，其中包含了最基本的根文件系统，以及一个位于 */sbin/init* 下的文件，内核在初始化过程中最后执行这个文件。这个 <ahref>*init* 程序开始运行一些脚本，这些脚本启动其他程序相互通信，并最终提供系统必须提供的完整体验。</ahref>

现在我们回到引导和恢复映像之间的区别。虽然内核有时与 bootimage 相同，但恢复映像内存磁盘有一组不同的 *init* 脚本，它们不启动 Java VM，而是启动一个名为(你猜到了吗？)*恢复*。恢复显示一个有限的用户界面，允许用户启动系统、恢复出厂设置、清除缓存分区等。一些自定义恢复有自己的程序，提供更多的功能。

## 打包 Android 启动映像

Android 启动映像有一个特定的结构，其内部组织反映了它所在的内存，即闪存。闪存是一种特殊类型的存储器，它不是随机存取的，而是按页读取，页的大小因特定芯片而异，通常在 4K 字节范围内。出于这个原因，引导映像的组件与页面大小对齐，这样加载更有效(还有其他原因，我在这里就不详细介绍了)。引导镜像的结构如下图所示:

## Android 启动映像的布局

我应该提一下这个第二阶段。老实说，我不知道它存在的理由，也不知道它的初衷。我看到它在最近被某些手机制造商用来保存内核的设备树块(DTB，另一个很长很深的技术话题，在别处有解释)。旧的内核将 TB 作为内核映像的一部分，现在他们已经将它分割成自己独立的部分，以便更容易地构建一个更通用的内核，它可以适应同一架构内的各种硬件配置。

快速向前移动(并返回！)到 bootimage 头，这主要告诉引导加载程序如何加载引导映像的组件，它看起来像这样:

## Android 启动映像头

正如您所看到的，它有几个“簿记”字段，关于启动映像的其他子组件有多大，将它们加载到什么地址，等等。

它还有一个领域叫做*魔法*。magic 字段仅仅是一个众所周知的字符串，用来标识这是一个机器人启动映像。在这种情况下，字符串是“ANDROID！”，正好适合 8 个字节。

熟悉 Linux 内核和启动过程的人会认识到内核标签和命令行参数字段是向内核传递更多定制信息的方式，例如控制台应该在哪里，以及从哪里找到初始 ramdisk 来加载它的 *init* 程序。

## 使用 Android 启动映像

所以，既然我们为我们的 Android 手机(如 TWRP，CWM 等)定制了恢复和启动映像。)，显然，有人必须创建自己的恢复映像或修改已经存在的引导映像。大部分工作都是使用已经开源的谷歌 Android 代码完成的，但是只有代码可以从它的组件创建一个引导镜像。没有工具可以打开启动映像包进行修改。现在，你可以使用像<ahref target="_blank">https://github.com/osm0sis/mkbootimg 这样的工具来打包和解包启动映像，并更换内核，或者修改初始内存磁盘。</ahref>

## 进一步探索的领域

关于初始 ramdisk，有一些有趣的方面适用于启动和恢复 Android 映像，本文不会详细讨论，因为它的大小已经开始增长，但是值得一提。

●初始 ramdisks 使用的文件系统通常是一个 gzipped [CPIO](https://en.wikipedia.org/wiki/Cpio) 档案

●您可以打包和解包初始内存磁盘，并对其进行修改

● init 脚本是用他们自己的领域特定语言(DSL)编写的，你可以阅读他们的<ahref>自述文件以获得更多信息</ahref>

●默认的 SELinux 文件上下文和策略通常位于 ramdisk 的根目录中

我们可以花很多时间来谈论和研究上述内容，但至少现在我会把它们作为一个练习留给热心的读者。

## 分享这篇文章