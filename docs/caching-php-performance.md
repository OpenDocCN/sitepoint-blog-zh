# 缓存它！解决 PHP 性能问题文章

> 原文：<https://www.sitepoint.com/caching-php-performance/>

在过去的好时光里，建立网站就像敲出几个 HTML 页面一样简单，将网页发送到浏览器只是让 web 服务器获取一个文件。除非使用特别慢的调制解调器，否则一个网站的访问者几乎可以立即看到它的小的纯文本页面。页面下载后，浏览器会将其缓存在本地计算机上的某个地方，这样，如果再次请求该页面，在与服务器进行快速检查以确保页面没有更新后，浏览器可以显示本地缓存的版本。页面尽可能快速有效地送达，每个人都很高兴。

然后动态网页出现了，它带来了两个问题:

*   当服务器收到对动态网页的请求时，必须完成一些中间处理，比如 PHP 引擎执行脚本。在 web 服务器开始将输出传递给浏览器之前，这种处理会带来延迟。对于简单的 PHP 脚本来说，这可能不是一个显著的延迟，但是对于一个更复杂的应用程序，在页面最终准备好交付之前，PHP 引擎可能有很多工作要做。这种额外的工作会导致用户请求和页面在浏览器中的实际显示之间出现明显的时间延迟。
*   典型的 web 服务器(如 Apache)使用文件修改时间来通知 web 浏览器所请求页面的年龄，从而允许浏览器采取适当的缓存操作。对于动态网页，实际的 PHP 脚本可能只是偶尔改变；与此同时，它所显示的内容(通常从数据库中获取)会频繁变化。web 服务器没有办法识别数据库的更新，所以它不发送最后修改日期。如果客户端(即用户的浏览器)不知道数据将保持有效多长时间，它将进行猜测。如果浏览器决定使用现在已经过期的页面的本地缓存版本，或者如果浏览器决定向服务器请求页面的新副本，而该副本实际上没有新内容，从而使请求变得多余，那么这就有问题了。无论数据库中的数据实际上是否发生了变化，web 服务器总是用一个新构建的页面版本进行响应。

为了避免网站访问者查看过期内容的可能性，大多数 web 开发人员使用 meta 标记或 HTTP 头来告诉浏览器不要使用页面的缓存版本。然而，这否定了 web 浏览器缓存网页的自然能力，并带来了一些严重的缺点。例如，动态页面提供的内容可能一天只改变一次，所以让浏览器缓存页面肯定有好处——即使只有 24 小时。

如果您正在使用一个小型 PHP 应用程序，这两个问题通常都可以解决。但是随着你的网站越来越复杂——并吸引更多的流量——你将开始遇到性能问题。然而，这两个问题都可以解决:第一个是服务器端缓存；第二，从应用程序内部控制客户端缓存。解决这些问题的确切方法将取决于您的应用程序，但是在这一章中，我们将考虑 PHP 和 PEAR 的一些类库作为您的网页灾难的可能的万灵药。

注意，在本章关于缓存的讨论中，我们将只关注那些可以用 PHP 实现的解决方案。对于更一般的介绍，web 缓存的权威讨论由马克诺丁汉的教程代表。

此外，本章中的解决方案不应该与一些基于优化和缓存编译的 PHP 脚本的脚本缓存解决方案相混淆，例如 [Zend Accelerator](http://www.zend.com/) 和 [ionCube PHP Accelerator](http://www.php-accelerator.co.uk/) 。

本章节选自[*《PHP 选集:101 个基本技巧、窍门& Hacks，第二版*。](https://www.sitepoint.com/books/phpant2/)

##### 如何防止网页浏览器缓存网页？

如果及时的信息对您的网站至关重要，并且您希望防止过时的内容出现，那么您首先需要了解如何防止 web 浏览器和代理服务器缓存页面。

***解***

我们可以采取两种方法来解决这个问题:使用 HTML 元标记和使用 HTTP 头。

**使用 HTML 元标签**

防止页面缓存的最基本方法是利用 HTML 元标记:

`<meta http-equiv="expires" content="Mon, 26 Jul 1997 05:00:00 GMT"/>
<meta http-equiv="pragma" content="no-cache" />`

插入一个已经传递到`Expires` meta 标签中的日期告诉浏览器页面的缓存副本总是过期的。一旦遇到这个标签，浏览器通常不会缓存页面。尽管`Pragma: no-cache` meta 标签没有得到保证，但它是大多数 web 浏览器遵循的一个相当受支持的约定。但是，与这种方法相关的两个问题(我们将在下面讨论)可能会促使您考虑替代解决方案。

**使用 HTTP 报头**

更好的方法是使用 HTTP 协议本身，在 PHP 的 header 函数的帮助下，生成上面两个 HTML meta 标记的等价物:

`<?php
header('Expires: Mon, 26 Jul 1997 05:00:00 GMT');
header('Pragma: no-cache');
?>`

我们可以更进一步，使用支持 HTTP 1.1 的浏览器支持的`Cache-Control`头:

`<?php
header('Expires: Mon, 26 Jul 1997 05:00:00 GMT');
header('Cache-Control: no-store, no-cache, must-revalidate');
header('Cache-Control: post-check=0, pre-check=0', FALSE);
header('Pragma: no-cache');
?>`

对于 HTTP 1.1 缓存控制头的精确描述，请看一下 W3C 的 HTTP 1.1 RFC 。关于 HTTP 头的另一个很好的信息来源是 [mod_perl 关于发布正确头的文档](http://perl.apache.org/docs/general/correct_headers/correct_headers.html)，它可以很容易地应用于 PHP。

***讨论***

使用`Expires` meta 标签听起来是个不错的方法，但是有两个问题与之相关:

*   浏览器首先必须下载页面，以便读取 meta 标签。如果一个标签在浏览器第一次请求页面时不存在，浏览器将会很幸运地保持无知，并保留原始页面的缓存副本。
*   缓存网页的代理服务器，如 ISP 常用的代理服务器，通常不会自己读取 HTML 文档。web 浏览器可能知道它不应该缓存页面，但浏览器和 web 服务器之间的代理服务器可能不知道，它将继续向客户端提供相同的过期页面。

另一方面，使用 HTTP 协议来防止页面缓存实质上保证了没有 web 浏览器或中间代理服务器会缓存页面，因此访问者将总是收到最新的内容。事实上，第一个头应该自己完成这个任务；这是确保页面不被缓存的最佳方式。添加`Cache-Control`和`Pragma`标题是为了某种程度的保险。虽然它们不能在所有的浏览器或代理上工作，但是`Cache-Control`和`Pragma`头会捕捉到一些过期头不能正常工作的情况——例如，如果客户端计算机的日期设置不正确。

当然，完全禁止缓存会引入我们在本章开始时讨论的问题:它否定了 web 浏览器缓存页面的自然能力，并会产生不必要的开销，因为总是会请求页面的新版本，即使这些页面可能自浏览器上次请求后没有更新过。我们一会儿就来看看这些问题的解决方案。

##### 我如何控制客户端缓存？

我们在“如何防止 web 浏览器缓存页面？”中讨论了禁用客户端缓存的任务，但是禁用缓存很少是唯一(或最佳)的选择。

在这里，我们将研究一种机制，它允许我们以一种可以从 PHP 脚本中控制的方式利用客户端缓存。

需要阿帕奇！
*这种方法只有在您将 PHP 作为 Apache web 服务器模块运行时才有效，因为它需要使用 getallheaders 函数(只适用于 Apache)来获取 web 浏览器发送的 HTTP 头。*

***解***

在控制客户端缓存时，您有两种选择。您可以设置页面过期的日期，或者响应浏览器的请求标题。让我们看看这些策略是如何执行的。

**设置页面到期标题**

最容易实现的标题是`Expires`标题——我们用它来设置页面过期的日期，在此之前，web 浏览器可以使用页面的缓存版本。下面是这个标题的一个例子:

**expires.php(节选)**

```
 <?php
function setExpires($expires) {
header(
'Expires: '.gmdate('D, d M Y H:i:s', time()+$expires).'GMT');
}
setExpires(10);
echo ( 'This page will self destruct in 10 seconds<br />' );
echo ( 'The GMT is now '.gmdate('H:i:s').'<br />' );
echo ( '<a href="'.$_SERVER['PHP_SELF'].'">View Again</a><br />' );
?> 
```

在这个例子中，我们创建了一个名为`setExpires`的自定义函数，它将 HTTP `Expires`头设置为以秒为单位定义的未来时间点。以上示例的输出显示了当前的 GMT 时间，并提供了一个链接，允许我们再次查看页面。如果我们点击这个链接，我们会发现时间每十秒钟更新一次。如果您愿意，也可以尝试使用浏览器的刷新按钮来告诉浏览器刷新缓存，并观察显示的日期会发生什么变化。

**Go to page:** 1 | 2 | 3 | 4 | 5

## 分享这篇文章