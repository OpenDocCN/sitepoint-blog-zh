# AJAX 和会话“竞争条件”

> 原文：<https://www.sitepoint.com/ajax-and-session-race-conditions/>

via Keith——有一个问题我很自责，因为我没有在[AJAX @ localhost](https://www.sitepoint.com/ajaxlocalhost/)—[异步 AJAX 请求和 PHP 会话的问题](http://www.chipmunkninja.com/article/asyncsessions)中明确涉及，作者 [Marc Wandschneider](http://travel.lanfear.com/) 。

> 通常，当您用 PHP 编写 web 应用程序时，这真的不是一个问题，因为每个页面请求都有自己的执行环境，用户一次只能访问一个页面。来自特定用户的每个页面请求或多或少按顺序到达，并且不与其他页面请求共享数据。
> 
> 然而，Ajax 改变了这一切:突然之间，一次页面访问会导致对服务器的大量并发请求。

现在，在我继续讲下去之前—**这不是 PHP 的问题**,尽管标题如此(我希望[网环](http://tnx.nl/php)注意了)——这是 HTTP 的一个特性——它是无状态的。问题是 AJAX 引入的界限变得模糊——这直接涉及到了[和](https://www.sitepoint.com/two-kinds-of-ajax-html-vs-client-soa/)两种 AJAX 之间的界限——是客户端还是服务器管理状态？

正如基思指出的那样；

> 简而言之，像 PHP 这样的服务器端技术不允许跨请求锁定对会话的访问。

我想稍微扩展一下——简而言之，使用像 HTTP 这样的无状态协议，任何跨请求锁定服务器端资源*的尝试都将是一种丑陋且潜在危险的攻击。例如，如果客户端在锁定某个东西后不久就断电了，该怎么办？*

顺便说一下，一个有用的案例研究是 [Dokuwiki](http://wiki.splitbrain.org) ，它实现了一个页面锁定机制，以防止两个人同时编辑时出现问题。它使用一个“锁”文件来做到这一点，每当你开始编辑一个页面或点击预览时，这个文件就会“接触”到最新的时间戳。如果服务器在 15 分钟内没有收到您的消息(默认)，您的锁可能会被转移给其他人。正如它所言，这是一个非常好的实现，因为它永远不会导致需要管理员清除的“僵尸”锁——我不认为有更好的方法来做到这一点。但是这个时间是基于对终端用户正在执行的一个非常具体的任务(编辑一个 wiki 页面)的假设，对于人们用 AJAX 做的典型事情来说，15 分钟显然太长了。我不认为这种方法可以转化为 AJAX——它不能以通用的方式完成。

把水搅浑

马克得出的结论可能是最聪明的。

> 既然我们已经意识到这个问题以及它是如何表现出来的，下一个问题当然是我们如何解决它？不幸的是，我认为这是最好通过避免来解决的问题之一。在我们的 web 应用程序中构建逻辑和其他东西来锁定执行线程(即单个请求)将会非常昂贵，并且会消除通过 Ajax 进行异步请求的许多乐趣和好处。相反，当我们执行多个会话请求时，我们将避免修改会话数据。

除了我在这里试图提出的事情之外，这是你在编写 AJAX 应用程序时必须注意的另一件事。这不一定是一个问题——*这取决于*你在做什么。

试着把它放在某种大的画面上，就像“嘿，我们的数据库不支持 [ACID](http://en.wikipedia.org/wiki/ACID) 事务，但是如果你小心的话，这没关系”。也许你能体会到这有多荒谬——也许不能(是的——我知道—<在这里插入众所周知的 DB，它从前不做交易>)。

麻烦的是阅读对这个问题的回复类型，比如那些回复 [AJAXian 对这个](http://ajaxian.com/archives/troubles-with-asynchronous-ajax-requests-and-php-sessions)的报道的回复。特别是那些应该“明白”的人显然不明白；

> PHP 的特点是它是基于请求的，这意味着信息存储不是跨请求持久的。每次请求时，仍会保存/恢复会话数据。如果您无法处理这个问题，并且需要对一个应用程序发出多个异步请求来访问同一个数据集(为什么我不明白，有其他方法可以解决这个问题)，那么我建议使用 J2EE 平台。

回到老肯特路。不要通过 Go。关于 HTTP 的事情是它是基于请求的——不管你扔给它多少 EJB！

这里的问题实际上是针对 [HTML++风格的应用](https://www.sitepoint.com/two-kinds-of-ajax-html-vs-client-soa/)(客户端/ SOA，当/如果它发生时不会受此影响，会话纯粹是客户端的)——人们确实需要意识到“Hello World！”@localhost 不翻译成 AJAX == easy。我知道 AJAX 爱好者不想听到这些问题，但是每个人都从不同的页面上阅读，而其他人则在玩“听不见，说不出，看不见”的游戏，我们并没有提高关于可以做什么和不可以做什么的标准。反过来说，AJAX 实际上比看起来更难，这导致了对学科专家的需求——如果你愿意的话，把这看作是一件好事。

## 分享这篇文章