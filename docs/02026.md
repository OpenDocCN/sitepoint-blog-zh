# 垃圾收集中的代际差异

> 原文:[https://www . site point . com/generation-disparity-in-garbage-collection/](https://www.sitepoint.com/generational-disparity-in-garbage-collection/)

本文原载于[我的日常 Java](http://mydailyjava.blogspot.de/2016/10/generational-disparity-in-garbage.html) 。我们在这里重新发布它，是因为它是一个案例研究，说明隐藏在 Java 表面下的机制是如何意外交互的——这是每个有抱负的 Java 专家都需要了解的。

去年，我一直在帮助初创公司 [Instana](https://www.instana.com/) 创建一个 Java 代理来跟踪 Java 应用程序中的执行。收集和连接这些执行数据，以生成用户请求的跟踪以及系统所有者半球内服务之间的通信结果。这样，非结构化的通信可以被可视化，这大大简化了由多个交互服务组成的分布式系统的操作。

为了生成这些跟踪，Java 代理重写了所有读取外部请求或发起外部请求的代码。显然，需要记录这些进入或退出系统的操作，此外，还需要交换元数据来跨系统唯一地标识请求。例如，在跟踪 HTTP 请求时，代理会添加一个包含唯一 id 的标头，然后接收服务器会记录该标头作为请求来源的证据。概括地说，它类似于 Zipkin 正在建模的东西，但是不需要用户修改他们的代码。

在最简单的情况下，这种跟踪很容易实现。感谢[我的库字节伙伴](https://github.com/raphw/byte-buddy)完成了繁重的工作，所有注入的代码[都是用普通的旧 Java](https://www.instana.com/blog/how-instana-safely-instruments-applications-for-monitoring/) 编写的，然后在运行时使用 Java instrumentation API 复制到相关的方法中。例如，当检测一个 servlet 时，我们知道无论何时调用服务方法，都会生成一个 JVM 条目。我们还知道，当这个完全相同的方法退出时，入口就完成了。因此，只需在方法的开头和结尾添加一些代码，就可以将任何这样的条目记录到 VM 进程中。我的大部分工作是钻研许多 Java 库和框架，以增加对它们的通信方式的支持。从 Akka 到 Zookeeper，在过去的一年里，我已经在整个 Java 生态系统中找到了自己的路；我甚至可以为所有的服务器编写 EJB！我必须理解 Sun 的 CORBA 实现。(剧透:没有道理。)

然而，当跟踪异步执行时，事情很快变得更加困难。如果一个请求被一个线程接收，但是被另一个线程响应，那么仅仅跟踪入口和出口是不够的。因此，我们的代理还需要跟踪并发系统中通过线程池、 [fork join 任务](http://homes.cs.washington.edu/~djg/teachingMaterials/spac/grossmanSPAC_forkJoinFramework.html)或定制并发框架进行的所有上下文切换。同样，调试异步执行也很困难，这对我们来说也是相当大的工作量。我认为我花在处理并发性上的时间和记录入口和出口的时间一样多。

## 对垃圾收集的影响

但是所有这些对垃圾收集有什么影响呢？在实现性能监视器时，人们面临着解释虚拟机的工作和通过这样做给该机器带来工作之间的权衡。虽然大部分处理是在代理向其报告数据的监视器后端完成的，但我们必须在与被监视的应用程序共享的 Java 进程中做最少的工作。您可能已经猜到了:通过分配对象，我们不可避免地会对 VM 的垃圾收集产生影响。幸运的是，现代垃圾收集算法做得非常好，通过大部分避免对象分配和自适应采样我们的跟踪工作，我们的代码变化的影响对于绝大多数用户来说是可以忽略的。理想情况下，我们只消耗一些未使用的处理器周期来完成工作。事实上，很少有应用程序充分利用了它们的处理潜力，我们很乐意抓住这种过剩的一小部分。

编写一个垃圾收集友好的应用程序通常并不太困难。很明显，避免垃圾的最简单方法是完全避免对象分配。然而，对象分配本身也不是太糟糕。分配内存是一项相当廉价的操作，因为任何处理器都拥有自己的分配缓冲区——一个[所谓的 TLAB](https://blogs.oracle.com/jonthecollector/entry/the_real_thing)——当我们只从线程中分配一点内存时，我们不会强加不必要的同步。如果一个对象只存在于一个方法的范围内，JVM 甚至可以完全删除对象分配，就好像对象的字段被直接放到堆栈上一样。但是，即使没有这个[逃逸分析](http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html)，短命的对象也会被一个叫做[年轻一代收集](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)的特殊垃圾收集圈捕获，这个垃圾收集圈的处理效率相当高。老实说，这是我的大部分对象的归宿，因为我经常把代码可读性看得比 escape 分析提供的小改进更重要。目前，逃逸分析很快就达到了极限。然而，我希望未来的热点能够有所改进，即使不改变我的代码也能两全其美。手指交叉！

当编写 Java 程序时，我通常不会考虑对垃圾收集的影响，但是上面的指导方针往往会在我的代码中体现出来。对于我们的大部分代理人来说，这种做法非常有效。我们正在运行一大堆示例应用程序和集成测试，以确保我们的代理有良好的行为，并且在运行示例时，我也会密切关注 GC。在我们的现代，使用像[飞行记录器](https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/run.htm#JFRUH164)和 [JIT 手表](https://github.com/AdoptOpenJDK/jitwatch)这样的工具，性能分析已经变得相当平易近人。

![old-young-generational-disparity](../Images/87a8ccbd3069981ed6e2f1905deffa98.png)

## 短命的相对性

在我们代理的早期版本中，有一天我注意到一个应用程序[触发了一个没有它就不会触发的永久收集](https://plumbr.eu/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc)周期。因此，收集暂停增加了很多。然而，最终出现在使用权集合中的对象只是被监控的应用程序本身的对象。但是由于我们的代理运行时大部分是独立于应用程序线程的，这一开始对我来说没有意义。

当深入挖掘时，我发现我们对用户对象的分析触发了一些额外的对象逃逸，但影响很小。应用程序已经产生了相当数量的对象，主要是通过使用 NIO 和 fork 连接池。后一种框架的一个共同点是它们依赖于许多短命对象的分配。例如，一个 fork-join 任务经常将自己分成多个子任务，这些子任务重复这个过程，直到每个任务的有效负载小到可以直接计算。每个这样的任务都由单个有状态的对象来表示。一个活跃的 fork 连接池每分钟可以产生数百万个这样的对象。但是由于任务计算速度很快，表示对象可以很快被收集，因此可以被年轻的收集器捕获。

那么这些物品怎么会突然出现在终身收藏中呢？此时，我正在原型化一个新的拼接工具，以跟踪这种 fork join 任务之间的上下文切换。遵循 fork join 任务的路径并不简单。fork join 池[的每个工作线程应用工作窃取](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)，并可能从任何其他任务的队列中抓取任务。此外，任务可能会在完成时向其父任务提供反馈。因此，跟踪任务的扩展和交互是一个相当复杂的过程，这也是因为存在所谓的延续线程，在延续线程中，单个任务可能会在几毫秒内将作业转移到数百个线程。我想到了一个相当优雅的解决方案，它依赖于许多短命对象的分配，每当回溯一个任务到它的起点时，这些对象就被突发地分配。事实证明，这些爆发本身引发了相当多的年轻收藏。

这是我没有考虑到的:每一次年轻代收集都会增加此时没有资格进行垃圾收集的任何对象的年龄。对象不是随着时间老化，而是随着触发的年轻收集的数量老化。这并不是对所有的收集算法都是如此，但对其中的许多算法来说却是如此，比如对热点的所有[默认收集器来说。并且通过触发如此多的收集，代理线程“过早成熟”被监控应用的对象，尽管那些对象与代理的对象无关。在某种程度上，运行代理使目标应用程序的对象“过早成熟”。](http://www.oracle.com/technetwork/java/javase/overview/index-jsp-140228.html)

## 回避问题

起初我确实不知道如何解决这个问题。最后，没有办法告诉垃圾收集器单独处理“你的对象”。只要代理线程以比主机进程更快的速度分配寿命较短的对象，它就会将原始对象刷新到有期限的收集中，从而导致垃圾收集暂停次数增加。为了避免这种情况，我开始将我正在使用的对象进行池化。通过池化，我很快将我自己的对象成熟到永久收集中，垃圾收集行为恢复到正常状态。传统上，联营被用来避免在我们那个时代变得廉价的分配成本。我重新发现了它，以几千字节的内存为代价，消除了我们的“外来进程”对垃圾收集的影响。

我们的追踪器已经在其他地方汇集了对象。例如，我们将入口和出口表示为包含一组原始值的线程本地值，我们无需分配单个对象就可以对这些原始值进行变异。虽然这种易变且经常是过程化的编程不再流行，但它被证明对性能非常友好。最后，改变位更接近于处理器实际做的事情。通过使用固定大小的预分配数组而不是不可变的集合，我们节省了相当多的内存往返行程，同时还将我们的状态保存在少数几个缓存行中。

## 这是“现实世界”的问题吗？

你可能认为这是一个相当特殊的问题，大多数人不需要担心。但事实上，我描述的问题适用于大量的 Java 应用程序。例如，在应用程序容器中，我们通常在单个 Java 进程中部署多个应用程序。就像上面的例子一样，垃圾收集算法不按应用程序对对象进行分组，因为它没有这个部署模型的概念。因此，共享一个容器的两个独立应用程序的对象分配确实会干扰彼此的预期收集模式。如果每个应用程序都依赖其对象在年轻时死亡，那么堆的共享会导致短生命期的持续时间有很强的相关性。

我不是微服务的倡导者。事实上，我认为它们对于大多数应用程序来说是个坏主意。在我看来，只能存在于交互中的例程应该理想地部署在一起，除非有很好的技术理由不这样做。即使孤立的应用程序简化了开发，您也会很快在运营中付出代价。我只是提到这一点，以避免误解上述经验的寓意。

这个经历告诉我，如果这些应用程序是异构的，那么在一个 Java 进程中部署几个应用程序可能是一个坏主意。例如，当运行与 web 服务器并行的批处理进程时，您应该考虑在各自的进程中运行它们，而不是将它们都部署在同一个容器中。通常，批处理进程分配对象的速率与 web 服务器非常不同。然而，许多企业框架仍然在宣传解决这些问题的一体化解决方案，而这些问题本来就不应该共享一个流程。在 2016 年，额外进程的开销通常不是问题，因为内存很便宜，所以升级服务器而不是共享堆。否则，在孤立地开发、运行和测试您的应用程序时，您可能会遇到意想不到的收集模式。

## 分享这篇文章