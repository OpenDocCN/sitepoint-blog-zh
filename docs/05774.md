# 航班是你现有网站的正确选择

> 原文：<https://www.sitepoint.com/taking-flight-twitter-flight/>

在 2014 年初，我甚至从未考虑过使用 Twitter 的 [Flight](http://twitter.github.io/flight/) JavaScript 组件框架，然而在这里，我毫不含糊地声明，它是您现有网站的正确选择，而我可能对此一无所知。当你准备好评论区的干草叉时，我最好解释一下我自己。

## 让我给你描述一下

飞行是推特的组成部分。Flight 没有受到太多的关注，因为它的专长不是带有数据绑定的花哨的单页应用程序演示，而是主要基于服务器端代码库构建的真实世界的 web 应用程序。它的设计完全并且仅仅是组件和事件。没有实例变量。没有魔法。数据组件触发事件来广播数据，而 UI 组件监听数据事件并依次触发它们自己的 UI 事件。

Flight 组件是非常解耦的，绝不会“接管”你的页面(不像 Angular 的`ng-app`)，而且它们的解耦本质上非常容易测试、移植和重构。继承现有 Flight 组件的维护或重构现有组件的认知负荷大大低于使用 Backbone 或 Angular 的可能性，并且您不会像使用 Backbone 或任何包含模型的 JS 框架那样将领域逻辑泄漏或复制到您的应用程序中。

## 为什么飞行？

你的团队已经做了几年的网站了。它主要由服务器端技术驱动——Ruby、PHP、Python。net——这是您解决真正的特定领域问题的地方。许多这些解决方案是你的网站成功的原因。除了这些服务器驱动的特性之外，您还不断地添加了更多的 JavaScript 增强功能来改进交互、更快捷的界面等等。也许它是从 jQuery 意大利面把别人的插件粘在一起开始的。也许有一些 jQueryUI 或 Backbone、Angular 或 Ember 在网站的孤立角落里表现得足够好。

随着这些增强的老化和增加，您开始注意到一个令人不安的趋势。而您的业务逻辑主要存在于带有测试套件和 QA 工具的服务器端，对吗？！)，越来越多的内容需要在 JavaScript 层进行复制。你不想加倍，但是你的 UI 现在有了逻辑，它需要做出正确的决定。类似地，您在服务器上积累的定制组件和格式化助手需要在客户端复制，以将您的 API 响应转换成正确格式化的视图。

所以现在你处在十字路口。您是继续沿着这条路走下去，在两个代码库之间复制逻辑并冒着它们不同步的风险，还是决定将精力重新放在 API 支持的“胖客户端”方法和大型 JavaScript 应用程序框架上？

那么第三种选择呢——这种选择允许您避免重写核心业务逻辑和视图层，同时为您提供一种极其松散耦合的轻量级 JavaScript 方法，这种方法高度可测试、易于理解和重构，最重要的是允许您逐渐摆脱现有 JavaScript 特性的混乱。如果有一天你发现它不再合适，同样的替代方案也很容易被移植，同时允许你通过快速地在你的用户面前获得新的想法并相信它们会如预期的那样工作来轻松地进行创新，那会怎么样？

第三种选择听起来不错。那么，Flight 打算如何兑现这些崇高的承诺呢？

## 每个人都在说，每个人都在听

虽然您定义组件的方式非常像常规类(包括在事件处理程序中将`this`上下文绑定到您的组件)，但是任何组件都不可能引用其他组件的实例。这意味着您不能紧密耦合 API，也不能通过善意的设计避免任何相关的错误。组件可能*只有*通过事件进行通信，这些事件要么作用于组件所连接的 DOM 节点，要么作用于`document`。这是一个飞行大会，向任何想听的人广播一个事件。

因此，一个 Flight 组件不知道也不关心它是否在与另一个 Flight 组件对话。没有预期的接口，因为实际上根本没有接口。如果您希望现有 JS 的一部分向 Flight 组件发送数据，它所要做的就是用组件正在监听的名称触发一个事件，并发送数据(例如`$(document).trigger('dataShoppingCart' cartContents)`)。

## 计算机科学中最难的问题

`dataShoppingCart`事件名称暗示部分飞行没有为您解决—事件命名。如果每个组件都在监听并触发所有这些事件，您将如何跟踪它们？至少对于传统的基于实例的 API，您可以很容易地看到什么依赖于什么，以及数据应该来自哪里。然而，你必须记住，Twitter 是为他们自己做的。他们不打算做一个指导初学者的框架，他们雇佣有经验的开发人员，他们有必须遵守的内部编码惯例。

编码约定正是防止事件命名问题失控的因素。在它的核心，有两种类型的事件——名称以`ui`开头的 UI 事件和名称以`data`开头的数据事件。一个`data`事件总是新的可用数据的广播，而一个 UI 事件代表一个用户交互。为了获得更多关于事件命名的指导，Tom Hamshere 从他将 TweetDeck 移植到 Flight 的经历中得到了一些关于[命名飞行事件](http://simplebutgood.net/flight-at-tweetdeck/)的提示。

## 关注点分离

这种 UI 与数据的划分一直延续到组件本身，在这里我看到了以预期的方式使用 Flight 的最大回报。Twitter 的 Flight 示例组件分为两个不同的组，`components_ui`和`components_data`。数据组件对 DOM 一无所知，UI 组件从不接触网络。通过扩展，用户事件只在 UI 组件中处理，所以你不会得到以`e.preventDefault()`开始的数据处理方法(比如 XHR 表单提交)，以及其他反模式。

## 完全实用的测试驱动开发

特定于行为和特定于数据的 JavaScript 的这种分离为开发人员提供了回报，减少了开发时的认知负荷，并且更容易测试。准备和执行 API 调用发生在一个数据组件中，用 [jasmine-ajax](https://github.com/pivotal/jasmine-ajax) 很容易测试。另一方面，交互和用户行为事件在匹配的 UI 组件中处理，并用 [jasmine-jquery](https://github.com/velesin/jasmine-jquery) 和 [jasmine-flight](https://github.com/flightjs/jasmine-flight) 进行测试。数据组件的规范将加载代表 API 响应的 JSON fixtures，而 UI 组件将加载最少的 HTML fixtures，这些 fixture 也作为组件期望的标记的规范引用。

## Flight 使用 DOM 而不是支配它

在我第一次使用它的时候(仅仅一个月前)，Flight 让我确信它非常适合现实世界中的长寿命产品。我和我团队中的另一个开发人员在 UI 的一个区域并行工作，这个区域提供了一个选项卡式的协作者选择，协作者列表中有异步应用的搜索标准。我将选项卡面板和导航作为一个 UI 组件来实现，而他在另一个 UI 组件中实现搜索控件和结果列表。当我们都完成时，我去合并两个 git 分支，完全期望我们的两个 JS 添加会由于对方的假设而中断。

它刚刚*工作了*！

Flight 组件不拥有它们所连接的 DOM 节点的任何所有权，也不假设这些节点的状态。没有像主干视图中的`this.el`那样紧密耦合的诱惑，没有角度视图中的`ng-app`——没有那些占有欲指令。Flight 真正利用了 DOM，它没有镜像它，劫持它，或者采用“我们的方式或高速公路”框架方法。从那以后，我返回并将结果列表重构到它自己的组件中，这同样不需要对相邻组件的预期或实现进行任何更改。我们的代码易于测试，易于修改，对于下一个需要阅读它的人来说也易于理解。

## 结论

对于大量包罗万象、功能强大的可用 JavaScript 框架，并不缺少合适的用例。如果我要开发一个新的 web 应用程序，而我在一开始就知道客户端会非常依赖 JavaScript，我可能会选择 Ember、Angular 或 Backbone +木偶。我会使用他们的路由，他们对 X 的固执己见的方法，我会“以 **____** 的方式”实现它。但在我工作的世界里——一个由多元化团队开发和维护的长期存在的 web 应用程序——像 Flight 这样的组件系统是一个完美的选择，我会自信地向任何处于类似位置的团队推荐。

## 分享这篇文章