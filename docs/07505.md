# 数据结构，大 O 和你

> 原文：<https://www.sitepoint.com/data-structures-big-o-and-you/>

数据是任何重要应用程序的核心——虽然 Ruby 提供了优秀的数组和哈希类，并提供了一些令人感觉良好的语法支持，但其他任何东西在标准库中都相当稀少。

当您为项目选择标准散列和数组之外的数据结构时，主要的考虑，实际上也是转换的主要动机，通常是数据结构的效率。在这篇文章中，我将从更高的层面来看我们如何在效率方面比较数据结构。

我们将以链表为例。

## 阵列上的快速旁白

就本文而言，当我谈到数组时，我指的是 Ruby 对数组的实现，这与许多低级编程语言有很大的不同。首先，它对可以插入的数据的类型和大小都没有限制。其次，它可以动态调整大小，这意味着增加大小的操作不再(或很少)需要将数组复制到更大的兄弟中这一昂贵的步骤。

所有的例子和基准都是使用 ruby 1.9.3 给出的，它天真地实现了`Array`类——这意味着对于给定的操作，两个数据结构具有相同的复杂性类，但一个是纯 ruby 的，一个是 C 语言的。天真地实现的结构会更快。

## 复杂类？

为了理解为什么选择一种数据结构而不是另一种，能够测量和分类它们随着输入的增长如何表现是有用的。我们将具有相似成本的算法放入复杂性类别中，以便对它们进行比较。例如，一些算法无论输入如何都要花费相同的时间来运行，一些算法随着输入线性增长，一些算法呈指数增长。

当我们谈论运行的“时间”时，很少会使用基准来比较两种算法——这容易受到编程语言、机器速度和垃圾收集器活动等方面的差异的影响。相反，计算机科学家将着眼于一个算法为了完成而必须执行的有意义的动作的数量。

一个有意义的动作相当依赖于领域。例如，当谈到排序算法时，一个有意义的动作可能是一个值与另一个值的比较。

算法也往往有一个恒定的成本。即总成本中不依赖于投入大小的部分。当您考虑大型数据集时，通常可以忽略这一成本。对于任何具有大型数据集的非平凡应用程序，随着输入的增长，增长率将很快使最大的恒定成本相形见绌。

例如，如果一个算法的常量成本为“10”(假设为秒)，但运行它需要 input^2 时间，那么对于 2 的输入，该常量可能是运行它需要的 14 秒中的很大一部分。但是如果你的投入是，比如说，10 亿美元呢？好吧，你需要在大爆炸之前开始这个过程。在这种情况下，常数变得无足轻重。

当我们比较算法时，有一些非常方便的符号可以使用。大 O 用于表示给定算法的最坏情况。因此，我们可以说算法 x 是 O(n ),这意味着，在最坏的情况下，算法 x 对于 15 个输入有 15 次有意义的运算。然而，如果 x 的运行时间为 O(n*15)，我们将会看到 225 个有意义的操作。

## 链接列表

链表是你能得到的最简单的数据结构之一，还有传统的数组。数组是一组分配的内存段，内存段中有内容，而链表是一组节点，其中每个节点都有一个指向下一个节点的指针。

想象一个 10 屉柜。在数组中，每个抽屉的编号为 0 到 9，每个抽屉都有一些值。要在抽屉 2 中找到一个元素，您只需打开那个抽屉，就可以得到您想要的东西。

然而，在一个链表中，抽签的数字是不相关的。它们可以是随机的数字、颜色或猫的图片。你从一开始就知道哪个抽屉是列表中的第一个。要找到第二件物品，你必须打开第一个抽屉，阅读一个说明，指出顺序中下一个抽屉的位置。

如果我们从头到尾遍历一个数组和一个链表，那么遍历整个链表需要 O(n)。对于列表中的每个元素，我们必须打开一个抽屉。

然而，当我们试图在列表中的第 *i* 处找到一个元素时，差异就出现了。在数组的情况下，我们可以打开抽屉，然后就完成了——随机访问的最坏情况是 O(1)。然而，在链表中，我们必须通过遍历指针来遍历所有的抽屉并找到我们的元素。如果我们要寻找的元素在列表的末尾，那么我们必须打开 n 个抽屉，复杂度为 O(n)。

你可能会问为什么我们会使用链表呢？如果我们需要在列表中的某个地方插入一个元素(假设我们已经知道我们想要插入的元素在哪个抽屉中)，我们可以简单地将指向前一个元素抽屉中下一个元素的指针替换为指向新抽屉中新元素的指针，然后让新抽屉指向之前在那个位置的元素。这意味着插入操作只需要打开一个抽屉，因此复杂度为 O(1)。

然而，对于数组，如果我们想把一个新元素放在最上面的抽屉里，那么我们必须把它下面的每个抽屉里的所有元素都移动。这意味着我们将打开 n 个抽屉，复杂度为 O(n)。

让我们看一些样本代码，一个简单的链表实现，以及一些基准来看看这是如何进行的。