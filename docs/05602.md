# 表格格式

> 原文:[https://www.sitepoint.com/table-formatting/](https://www.sitepoint.com/table-formatting/)

表格是 HTML 中最复杂的元素，表格格式是 CSS 中最复杂的部分之一。如下图所示，CSS 定义了许多与表格格式相关的对象。

![Table formatting objects](../Images/c0a73a99085b2b6a7c10a5e7883850f7.png)

表格格式对象

表格可以包含标题、行组和列组。行组包含行，而列组包含列。行和列包含单元格。表格以自下而上的指定顺序呈现为层:表格、列组、列、行组、行和单元格。

HTML 中的表格模型是以行为中心的。尽管可以在标记中指定列和列组，但单元格在结构上是包含在行中的。列和列组是从表格所有行的单元格集合中派生出来的更深奥的项目。

表格可以作为块级或行内级框包含在格式化上下文中。它可以有[填充](https://reference.sitepoint.com/css/paddinglayout)、[边框](https://reference.sitepoint.com/css/bordersoutlines)和[边距](https://reference.sitepoint.com/css/margins)。

table 元素生成一个包含表格框和标题框的匿名框(如果它们存在的话)。标题框呈现在表格框之外，但与表格框有着千丝万缕的联系。当表格被重新定位时，外部的匿名框被移动以使标题跟随表格。

标题从表中继承可继承的属性。标题被格式化为块框，但它的行为并不完全像一般的块框。如果插入元素在表格之前，它将不会插入标题框。

标题的位置可以通过标题侧属性来控制。CSS2.1 中的有效值是`top`和`bottom`，这应该是不言自明的。

表格的内部元素(行组、列组、行、列和单元格)生成可以有边框的常规框。单元格也可以有填充，但是内部表格对象没有边距。

`display`属性的十个有效值表示与表格相关的格式样式。下表显示了这些值以及默认情况下与它们相关联的 HTML 元素类型。

<caption>Table 1\. Table `display` Property Values</caption>
| 元素类型 | 属性值 | HTML 元素 |
| --- | --- | --- |
| 桌子 | `table` | `table` |
| `inline-table` | 不适用的 |
| 标题 | `table-caption` | `caption` |
| 行组 | `table-header-group` | `thead` |
| `table-footer-group` | `tfoot` |
| `table-row-group` | `tbody` |
| 排 | `table-row` | `tr` |
| 列组 | `table-column-group` | `colgroup` |
| 圆柱 | `table-column` | `col` |
| 细胞 | `table-cell` | `td` |
| `th` |

除了属于 HTML 表格模型的元素类型之外，还可以为其他元素类型指定这些显示值；但是，Internet Explorer 及更高版本不支持这些值。

当与表相关的`display`值用于非表元素时，可能必须生成匿名的与表相关的元素，以便正确地呈现元素。这里，我们列出了可能创建匿名表相关元素的情况:

*   单元格必须有一行作为其父单元格。一个行对象将被生成为一个或多个连续单元格的父对象，这些单元格没有一行作为它们的父对象。
*   行必须有一个行组或一个表作为它们的父行。列必须
    有一个列组或一个表作为它们的父列。行组和列
    组必须有一个表作为它们的父组。一个表格对象将被
    生成为那些
    类型的一个或多个连续对象的父对象，这些对象没有所需的父对象。
*   如果表对象的子对象不是标题、行组、列
    组、行或列，将生成一个行对象作为该子对象的
    的父对象，以及任何需要行作为其
    父对象的连续兄弟对象。
*   如果一个行组对象的子对象不是一个行，那么一个行对象将被
    生成为该子对象的父对象，以及任何
    需要一个行作为其父对象的连续兄弟对象。
*   如果行对象的子对象不是单元格，单元格对象将被生成为该子对象的父对象以及任何连续的
    不是单元格的兄弟对象。

## 适用于列和列组元素的属性

只有少数属性可以应用于显示属性值为`table-column`或`table-column-group`的元素:

*   `border`属性，但仅在
    折叠边框模型中(见下文)
*   `background`属性，其中单元格和行
    具有透明背景
*   `width`属性
*   `visibility`属性值
    `collapse`—对于列和列组，任何其他可见性值都被忽略

## 表格宽度算法

与其他块框不同，水平边距为零且宽度属性设置为“自动”的表格不会调整大小以填充其包含的块。相反，表格的大小将由其内容决定。不过，通过将`margin-left`和`margin-right`设置为自动，可以将表格水平居中。

确定表格列的宽度有两种截然不同的算法:`fixed`表格布局算法和自动表格布局算法。这些是用`table-layout`属性指定的(对于固定布局，取值为`fixed`，对于自动布局，取值为`auto`)；它的初始值是 auto。如果表格的宽度被指定为 auto，则通常使用自动表格布局算法。在块级表格的情况下(当`display`被设置为`table`时)，用户代理被允许使用固定的表格布局算法，但是他们不被要求这样做。

使用固定表格布局算法，列的宽度和表格的宽度不受表格单元格的内容控制。相反，每列的宽度按如下方式确定:

*   `width`不是
    `auto`的列对象设置该列的宽度。
*   第一行中的单元格，其`width`不是
    `auto`，设置其所属列的宽度。
    如果单元格跨越多列，则宽度在
    列上划分。
*   任何剩余的列均分剩余的水平
    空间，减去任何边框或单元格间距。

表格的宽度是表格的 width 属性值和列宽之和(加上边框或单元格间距)中的较大值。如果表格比列宽，多余的空间将分布在列上。

> ## 不要省略单元格！
> 
> 因为表格第一行中的单元格用于确定列宽，所以如果使用固定表格布局算法，就不应该忽略第一行中的任何单元格。CSS2.1 规范没有定义这种情况下的行为。

自动表格布局算法通常需要不止一遍。CSS2.1 规范建议使用一种[算法来确定列宽](https://www.w3.org/TR/CSS21/tables.html#auto-table-layout)，但是用户代理并不需要使用它。

确定列宽的建议算法检查整个表格中的每个单元格，计算呈现每个单元格所需的最小和最大宽度。然后，这些值用于确定每列应该有多宽，这反过来又可以决定表格本身的宽度。

## 性能和自动表格布局

因为必须检查每个单元格，所以当对具有大量行和/或列的表格进行计算时，自动表格布局算法会变得非常耗时。

## 表格高度算法

如果表格的 height 属性的值不是`auto`，并且指定的高度不同于行高加上边框或单元格间距的总和，则行为是未定义的。

对于行、行组和单元格，height 属性的百分比值未定义。

每个单元格的`vertical-align`属性决定了它在行内的对齐方式。仅允许值`baseline`、`top`、`bottom`和`middle`。对于任何其他值，将使用`baseline`。

## 表格对象上的边框

在 CSS2 中有两种不同的模型来呈现内部表格对象的边框:分离边框模型和折叠边框模型。我们可以通过使用`border-collapse`属性选择我们喜欢的模型，并将值设置为分离(初始值)或折叠。

在分离边框模型中，只有单元格(和表格本身)可以有边框；行、行组、列和列组不能。在单元格周围单独绘制边框，单元格之间由`border-spacing`属性指定的垂直和水平距离分隔。在单元格边框之间的空间中，行、行组、列和列组的背景是不可见的。在单元格间距中，只有表格背景可见。下图显示了使用分离边框模型渲染的表格示例。

![Rendering a table with separated borders](../Images/d737725e2d5e7cf8c1fa6d8e224835b4.png)

呈现具有分离边框的表格

下面是该表的相关 CSS:

```
table {
  border-collapse: separate;
  border-spacing: 1em 0.5em;
  background-color: #ddd;
}
```

另一个应用于分离边界模型的属性是`empty-cells`属性。它控制缺少可见内容的单元格是否有边框和背景(如果值为 show，则为初始值)或没有边框和背景(如果值为 hide)。回车符、换行符、制表符和空格不被视为可见内容，尽管不间断空格是可见内容。

在折叠边框模型中，单元格不会彼此分离，它们的边框(以及行、行组、列、列组和表格本身的边框)会以一种相当复杂的方式折叠(或重叠)。此处显示了应用折叠边框模型的表格示例:

![Rendering a table with collapsed borders](../Images/bf23fd87015f1aabe11d13dd9fee5ddc.png)

呈现带有折叠边框的表格

有了这个模型，相当多的边界可以被指定为在同一个地方呈现。CSS2.1 规范提供了一种解决边界冲突的算法，也就是说，在这些情况下，哪个边界会胜出，或者被渲染。非常宽泛地说，会呈现最醒目的边框，除非至少有一个边框的`border-style`设置为`hidden`，在这种情况下不会呈现任何边框。

如果没有隐藏边界，宽边界会战胜窄边界。如果两个或更多的边框具有相同的宽度，那么`border-style`属性决定哪一个将被渲染。样式的首选顺序如下:`double`、`solid`、`dashed`、`dotted`、`ridge`、`outset`、`groove`、`inset`。“边框样式”设置为“无”的边框优先级最低，永远不会胜过其他边框样式，即使它们的宽度值很大。

如果仍然没有获胜者，该算法将查看为其设置了边框的对象。首选顺序是:单元格、行、行组、列、列组和表格。

当使用折叠边界模型时，`border-spacing`和`empty-cells`属性被忽略。

## 分享这篇文章