# 处理来自陌生人的内容

> 原文：<https://www.sitepoint.com/handling-content-from-strangers/>

让 web 开发既有趣又累人的一件事是，相同的主题如何不断出现，一遍又一遍，却没有任何明确的答案。一方面，建立自己的网站非常容易。但是建立一个能够处理大量流量，并且易于更改和修改的网站并不容易。

让我开始的是[这个最近由](http://www.intertwingly.net/blog/1742.html) [Sam Ruby](http://www.intertwingly.net/) 写的博客，他是 IBM 的老板，他为之而死，PHP 应该感谢他的 Java 扩展，他是 Apache 组的成员，参与了无数其他 web 创新和组。

问题？如何发布访问者提交到您网站的内容。解决这个问题是一个和最古老的网络应用程序一样古老的问题——留言簿，如果你在 Sam 的网站上搜索评论，你会很快发现仍然没有人能确定答案。

毫无疑问，你知道，最基本的问题是允许你的博客或论坛的访问者提交更多的内容，而不仅仅是普通的、无格式的文本，你需要允许他们通过某种机制来增加结构。但是如果你让他们访问整个 HTML 词汇库(加上 Javascript 和 CSS)，不仅你的网站会变得一团糟，而且你还可能会让访问者接触到像 XSS 漏洞这样的东西。

最近，我越来越迷恋于列出描述常见开发问题的清单，以此作为真正解决问题的手段。这里猜测一下，一个好的解决这个问题的方法需要做什么(以我的观点/视野有限为准)；

**好闻的味道**

1.防止你的网站结构被破坏

2.不会对你的网站或访问者的安全构成威胁

3.就如何格式化他们的提交内容而言，为访问者提供了足够的动力，让他们感到快乐。

4.易于解析(提取提交的格式并处理它不需要博士学位)

5.很容易使用。信不信由你，有些人对 HTML 一无所知。

6.保留格式的*意图*。不太确定如何解释我在这里的意思，但思想测试可能是:“有可能将提交的内容转换成其他输出类型吗？”–也就是说，与 HTML 相比，生成 PDF 文档至少是可行的。

多一点/少一点？

满足所有这些要求可能是不可能的——这将是某种程度上的妥协。

解决这个问题的一些常见的解决方案是:

**常见款式**

a.允许“安全”HTML 的有限子集。这解决了第三点。和 6。非常好，并且假设有 HTML 的基础知识，对用户学习新的标记语法没有额外的要求。另外有利的一面(取决于你的观点)是现在有很多所见即所得的“插件”，如 [Editize](http://www.editize.com/) 或[基于 JavaScript 的解决方案](https://www.sitepoint.com/forums/showthread.php?t=159278)。缺点是很容易出错，特别是在安全性方面(参见 PHP 的 [strip_tags()](http://www.php.net/strip_tags) 函数和后面关于“邪恶属性”的注释)。另一个问题是如何解析？除非您要求用户提交格式良好的 XML，否则您的标准 XML 解析器会被 HTML 卡住。使用正则表达式来解析 HTML 通常是一个噩梦。尽管现在大多数网络语言已经发展出一两个 HTML 解析器。也就是说，令人震惊的是，特别是 PHP，迄今为止基本上没有内置的 HTML 解析器(幸好 PHP5 将 HTML Tidy 带入了争论，加上 DOM 扩展现在可以处理 HTML)。

b.维基风格。使用“标记”，如 ***this 表示粗体*** 和 *_this 表示斜体 _* 。Wiki 风格通常开始时很好，易于使用且安全，但在第三点上可能很弱。但是事情越往下走，你提供给用户的格式选项越多，解析越来越难管理，语法越来越奇怪，就像**！！！这对于一些大文本**。用户需要学习这种陌生的标记，并且可能会发现很难表达他们精确的格式意图(意图因此而丢失，变得任意，因为像 [McDougals](http://c2.com/cgi/wiki?McDougals) 这样的文本被自动分配为指向新维基页面的链接)。最后，我不认为维基做了太多的工作来解决他们最初的目标受众之外的问题——软件开发人员

c.隐含格式。这很少作为独立的机制使用，但是经常作为其他风格的一部分出现。从本质上讲，空白具有 HTML 中通常没有的含义。PHP 提供了 [nl2br()](http://www.php.net/nl2br) 举例。它绝对易于使用并且相当安全(例如，取决于您对 URL 的处理)。它也很容易解析。它失败的地方在于，它通常不能为用户提供什么功能，而且很容易丢失格式的意图，因此它经常用一种或多种其他样式来增强。

d. [BBCode](https://www.sitepoint.com/forums/misc.php?do=bbcode) 风格。本质上使用您自己的自定义标记；如果在完成的页面中出现任何未解析的片段，web 浏览器将完全忽略这一点。尽管对于从未遇到过的用户来说这可能有点棘手，但这是一种尝试，测试和成功，正如像 [vBulletin](http://www.vbulletin.com) 和 [phpBB](http://www.phpbb.com) 这样的论坛应用程序已经证明的那样，到了 BBCode 几乎是(一个不成文的)标准的地步。令人惊讶的是，在 Sams 的博客上，没有人提到它，但这可能反映了 PHP 开发人员和其他 web 人员之间的共同分歧；做和谈论。对于最终用户来说，这通常意味着基于 HTML 的标签已经或多或少地被一对一地翻译成了 bb code——只需将<替换为[，所以如果你懂 HTML，你可能会相当高兴。你也可以像 Sitepoint 一样选择引入自己的标记，比如“Google”标签。解析是可以忍受的，并且可以清楚地表达和保存格式意图。对我来说，这是应该走的路，但这就是我。

还有吗？

一个值得注意的混合体是[纺织品加价](http://www.textism.com/tools/textile/index.html)，它包含了所有的东西。那些次我被它折磨，结果是“恶心！”。另一款混合动力车似乎是 [Markdown](http://daringfireball.net/projects/markdown/) 。

**实用笔记**

安全问题之外的几个要点:

–当在数据库中存储访问者提交的内容时，为了以后的显示，在内容被存储之后应用解析操作*，而不是在*之前应用*。换句话说，不要解析，插入然后选择，但是插入，选择然后解析(如果性能是一个问题，缓存解析产生的 HTML)。这样做的基本原因是，它使以后编辑内容(无论是由您作为站点管理员还是由访问者自己)变得容易——您可以在文本区域中显示他们的内容(或多或少),而不必反转解析操作来返回他们开始时的内容(这是一个令人头痛的方法)。您还有更好的机会保留格式的意图，如果您需要反转解析，这很容易丢失。您可能会考虑在存储内容之前对其进行过滤——当然是为了 SQL 注入，也可能是为了“坏词过滤器”之类的东西，但是不要对内容进行转换或添加。*

–记录您的标记。我看到的期望访问者猜测的博客数量(挪动挪动 Sitepoint))…

还有吗？

当我在这里时，一些 PEAR 项目可以在这方面提供帮助；

–[PEAR::HTML _ BBCodeParser](http://pear.php.net/HTML_BBCodeParser)–你甚至不需要自己编写(这甚至已经成为了一个 [WACT 标签](http://wact.sourceforge.net/index.php/HtmlBBCodeTag))。注意像转换 [HTML 实体](http://www.php.net/htmlentities)和处理换行这样的事情仍然是你的工作。

–[PEAR::Text _ Wiki](http://pear.php.net/Text_Wiki)–实际上是 Wiki 标记的抽象层。Text_Wiki“捕获”了最终用户可能拥有的所有常见的文档结构化需求，作为“规则”,并且可以将您喜欢的任何标记翻译成这些规则，即呈现(X)HTML 的规则。非常聪明的项目。也可以作为一个 BBCode 解析器(实际上几乎是任何东西)。

–[XML _ HTML Sax](http://pear.php.net/XML_HTMLSax)–一个不会阻塞 HTML(格式错误的 XML)的 SAX 解析器。事实上， *HTML* Sax 这个名字有点误导，因为它没有 HTML vocab 的具体知识。事实上，它很像 Python[html parser](http://www.python.org/doc/current/lib/module-HTMLParser.html)，尽管像
这样隐式关闭的标签会导致带有 XML_HTMLSax 的开放标签处理程序的四个参数，以及对关闭处理程序的调用，而 Python；的 HTMLParser 有一个针对这种情况的“startendtag”回调。我见过但从未尝试过的几个项目是用于 PHP-4 的 [HTML 解析器](http://php-html.sourceforge.net/)，它提供了一个基于状态的 API 和 [PHP HTML 解析器](http://anton.concord.ru/)，它确实有一些 HTML 知识，似乎旨在转换 HTML 是一次通过(从用户的角度来看)。还要注意的是[简单测试](http://www.lastcraft.com/simple_test.php)有一个(你猜对了)简单的基于 SAX 的 HTML 解析器——它使用正则表达式，基于 [lamplib](http://sourceforge.net/projects/lamplib) 中的 Lexer 仍然需要对它进行基准测试，因为 HTMLSax 使用基于字符串位置的解析方法，只是出于兴趣。

总之——长篇大论。已经够了。

## 分享这篇文章