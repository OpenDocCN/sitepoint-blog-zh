# 回到基础:JavaScript 提升

> 原文:[https://www.sitepoint.com/javascript-hoisting/](https://www.sitepoint.com/javascript-hoisting/)

变量声明是任何编程语言最基本的方面之一。然而，JavaScript 有一个小怪癖，称为*提升*，它可以将一个看起来无辜的声明变成一个微妙的 bug。这篇文章解释了什么是吊装，以及如何避免被它烧伤。
T3】

JavaScript 是一种非常灵活的语言，允许你在任何地方声明变量。例如，以下立即调用的函数表达式(IIFE)声明了三个变量，然后使用警告对话框显示它们。顺便说一下，你不应该使用警告框，但是我们在这里试图证明一点。

```
(function() {
  var foo = 1;
  var bar = 2;
  var baz = 3;

  alert(foo + " " + bar + " " + baz);
})();
```

这看起来像正常的 JavaScript 代码。正如所料，它显示了字符串`"1 2 3"`。现在，假设警报被移动，如下所示。

```
(function() {
  var foo = 1;
  alert(foo + " " + bar + " " + baz);
  var bar = 2;
  var baz = 3;
})();
```

如果有人真的写了这段代码，那很可能是错误的。显然，警报发生在声明`bar`和`baz`之前。然而，这是完全有效的 JavaScript，不会产生异常。相反，警报显示`"1 undefined undefined"`。

基于我们之前的实验，似乎你可以引用尚不存在的变量。现在，让我们采用相同的生命，但是将`baz`声明一起删除，如下所示。突然，我们有了一个`ReferenceError`，因为`baz`没有被定义。

```
(function() {
  var foo = 1;
  alert(foo + " " + bar + " " + baz);
  var bar = 2;
})();
```

这真是有趣的行为。要理解这里发生的事情，你必须理解提升。提升是 JavaScript 解释器将所有变量和函数声明移动到当前作用域顶部的动作。但是，只悬挂实际的申报单。任何作业都留在原处。因此，我们的第二个例子 IIFE 实际上转化为下面的代码。

```
(function() {
  var foo;
  var bar;
  var baz;

  foo = 1;
  alert(foo + " " + bar + " " + baz);
  bar = 2;
  baz = 3;
})();
```

现在可以理解为什么第二个例子没有生成异常了。提升之后，`bar`和`baz`实际上是在 alert 语句之前声明的，尽管它们的值没有定义。在第三个例子中，`baz`被完全删除了。因此，没有什么可提升的，警报语句导致了一个异常。

## 功能提升

如前所述，函数声明也被挂起。但是，分配给变量的函数不会被提升。例如，由于函数声明提升，下面的代码将按预期工作。

```
foo();

function foo() {
  alert("Hello!");
}
```

然而，下面的例子将会失败。`foo`的变量声明在函数调用前被挂起。但是，由于没有提升对`foo`的赋值，所以在试图调用非函数变量时会抛出一个异常。

```
foo();

var foo = function() {
  alert("Hello!");
};
```

## 结论

提升是 JavaScript 语言中容易理解但经常被忽略的细微差别。如果没有对提升的正确理解，你的程序很容易出现细微的错误。为了帮助避免这些错误，许多开发人员(和林挺工具)提倡在每个作用域的最开始使用单个变量声明语句。因为 JavaScript 解释器本质上就是这样看你的代码的，所以这条规则是有效的——即使我个人违反了这条规则。

## 分享这篇文章