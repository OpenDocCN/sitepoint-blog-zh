# 如何自动化设计

> 原文:[https://www.sitepoint.com/how-to-automate-a-design/](https://www.sitepoint.com/how-to-automate-a-design/)

*本文是与 [JotForm](https://www.jotform.com/?utm_source=SitePoint&utm_medium=Article) 合作创作的。感谢您对使 SitePoint 成为可能的合作伙伴的支持。*

## 问题是

这一切都始于 2017 年 10 月，当时我们正在搜索 HackWeek 项目创意。

我们在 [JotForm](https://www.jotform.com/?utm_source=SitePoint&utm_medium=Article) 的团队注意到，我们的新表单设计——jot form Cards，在嵌入用户网站时，看起来不如独立版本好。啊哦。

![](../Images/7b701a37adb1ab48225bbc59542ce802.png)

基本上来说， [JotForm Cards](https://www.jotform.com/cards/) 的设计并不适合这个网站。虽然表单本身看起来很漂亮，但是在与标准用例如此不同的环境中使用这种设计会毁了它。

随着我们继续在网站中嵌入 JotForm 卡片，我们意识到这种情况非常普遍。双倍哦哦。

我们注意到像*表单被压缩成列…* :

![](../Images/01519d522821b21eef8a99efeadf4df4.png)

*与网站不符的特征颜色:*

![](../Images/d7b9a74a81fc16867a82b0e6bc483237.png)

*以及不同字体的重复标题。*

![](../Images/ee18dc115d07c956ada26dea5509d3ea.png)

乍一看，这些问题似乎不是很大，但是因为我们只有 7 天的黑客周来解决它们，我们很紧张，真的很紧张。

## 结构

在深入实现之前，我将分享一些关于 JotForm 卡的结构信息。

前端的样式结构使用 SCSS(基本上是带有漂亮语法的 SASS)作为预处理器，使用 PostCSS 作为后处理器。剩下的前端结构(标记、逻辑)大多基于 React。

*附注:表单的 CSS 文件是由 PHP 准备和提供的，PHP 是这个实现的主要后端语言。*

## 挑战

我们决定自动化设计，以实现以下目标:

*   为 JotForm 卡片生成一个干净的模板(不破坏它的设计)
*   创建空间来操作表单，以匹配每个网站的设计
*   理解我们嵌入表单的网站的设计选择
*   在不降低 JotForm 卡独立设计质量的情况下，将这种设计选择应用到我们的模板中

最后，在合理的时间内完成所有这些。

### 清理模板

我们的第一个障碍是清理 JotForm 卡。幸运的是，由于表单已经具有动态结构，生成我们想要的模板很容易。

我们开始完全根据 SCSS 变量构建我们的样式。这使得我们可以简单地通过添加！必要变量的默认标志。

![](../Images/231521bf086252d6357f4c1cffdc8d78.png)

*默认的 JotForm 卡片模板(左)和清理过的模板(右)。*

### 设计选择的推论

因为我们的主要目标是以一种容易调整的方式来装饰一个干净的模板，所以我们决定考虑网站设计的一些风格方面:

*   颜色
*   字体
*   网页中容器的形状(边框、大小等)。)
*   阴影

### 第一步:让我们从 CSS 中获取

我们决定用 PHP 读取网站的 CSS 内容，从中提取信息。我们在后端这样做的原因是因为我们的整个系统，CSS 生成，已经基于 PHP。

这意味着通过使用 SCSS 解析器将默认的表单样式和用户定义的样式属性合并到一个文件中。因此，我们的计划是添加另一个层来合并流程，以便用网站 CSS 中的信息覆盖默认的样式属性。

该实施包括三个步骤:

1.  获取页面的 HTML
2.  解析样式/链接标签
3.  从管理的 CSS 内容中获取相关属性

简码可以在本要旨中找到[。](https://gist.github.com/cemjotform/c2161282dc7fd3cdc47ed99a9648e42f)

为了将这些 CSS 内容打包成可合并的格式(以及过滤掉不必要的样式变量)，我们使用定制的 Css2less 库将所有内容转换成 s CSS。

下一步是从 SCSS 变量中获得有意义的信息。我们的第一个方法是“幼稚”的。基本上，我们想确保我们在正确的轨道上——而不投入太多时间(还没有)。

这种方法包括:

*   获取数字属性的平均值，如颜色、阴影、边框、大小。等等。
*   使用最常用的字体作为默认字体

令人惊讶的是，结果还不错。

![](../Images/321e4b73988b833ab53588c2937c9c8e.png)

![](../Images/bc0e77f6fa737cf366cafb3d420ca5bd.png)

尽管如此，还是有一些我们没有预料到的搞笑结果。

*喜欢太大的边框半径……*

![](../Images/e8dea2e3b241fb26b5e3479751975020.png)

*和图标，而不是常规字体系列……*

![](../Images/b255c9e7033a012e344889a34e136263.png)

*缺少动作栏:*

![](../Images/1c58391179fb26b47c60fc2854e6a8b4.png)

基于这些例子，我们为变量的允许值设置了界限，这样就不会偏离我们最初的设计。其中一些调整包括:

*   在计算平均半径时，对边界半径设置最大限制，以便将其视为可用
*   如果有阴影存在，显示我们的默认阴影，如果没有，删除它
*   消除图标字体并推广某些字体系列

只剩下一个问题:颜色。

与其他属性相比，颜色是一个完全不同的故事。不可能知道彩色 HTML 容器会覆盖多少页面，或者网页中使用的图像是什么颜色。我们需要将 HTML 代码放入浏览器来找出答案。正是在这一点上，我们问自己，“为什么我们不只是使用一个无头浏览器来找出颜色？”

然后，我们决定对网页进行颜色提取，这需要对网页进行整页截图，并从中提取样本来开发我们的配色方案。

在测试了几个无头浏览器和屏幕截图测试套件后，我们决定使用 Puppeteer，因为它的颜色质量高，并且在整页屏幕截图中显示了正确的网页高度。

然后，我们为木偶师和颜色提取开发了一个简单的节点应用程序。在 Node 上实现颜色提取可以确保在向 PHP 发送截图时不会浪费时间。

[使用木偶师和获取图像颜色时，屏幕截图和颜色提取示例代码见本要点](https://gist.github.com/cemjotform/0d8d8b9916c25d25478585548bc93b9e)。

在将这些信息传递给 PHP 之后，我们终于准备好使用网站的配色方案来装饰表单了。

![](../Images/b30a0ded8ba74ac36b0554a55eec11ff.png)

![](../Images/f213af2e4bf765dcd2c64b5b5aa8c132.png)

![](../Images/9a82233f630288b154d600928f13a52a.png)

![](../Images/6727d21af841edf426d58662865607d5.png)

## 自动化和性能

我们还有最后一个问题:如何在自动化这些过程的同时避免打扰用户？

该过程大约需要 5 到 10 秒，具体取决于网站。虽然这并没有给我们的用户带来太多的困扰，但是在每次表单加载时都处理网页就有点过头了。

![](../Images/1f8325a9a563cb489f3a580c541b3880.png)

### 样本流程

这就是为什么我们决定为每个基于 URL 的网页保留额外的样式文件缓存。独立的样式缓存允许用户将相同的表单嵌入到多个页面中，每个页面上有不同的设计。这也有助于我们避免破坏独立的样式文件。

除了缓存问题，自动化过程还有另一个问题:将网站 URL 从复制和粘贴的嵌入代码(我们不能从用户的 web 页面更改它)传递到 PHP 中。

最初，我们试图通过 PHP 中的 referrers 获取这个 URL，但在 Safari 的几个版本中失败得很惨。

接下来，我们被迫从一般用途的 JavaScript 获取 URL，并将其作为参数传递给样式文件请求。

*补充说明:这最后一个问题背后的原因是我们为 React 组件和样式标签使用了服务器端渲染，以避免给用户带来负担。确实没有办法确切知道请求是由 iframe 完成的还是直接在服务器端完成的。*

## 我们做到了！

最后，所有这些改变都是在我们的黑客周期间由一个五人小组实施的。

在这样的自动化中，一个团队可以改进的东西有很多，它们大多涉及到使用机器学习的力量。例如，你可以训练一个机器学习模型来更好地检测与你的产品或项目自动化相关的重要属性，而不是像我们一样微调方法。

然而，我们在 [JotForm](https://www.jotform.com/?utm_source=SitePoint&utm_medium=Article) 的团队对我们通过简单使用上面的技术成功实现的东西感到满意。

## 分享这篇文章