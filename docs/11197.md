# 微软修复他们的非随机浏览器选择屏幕

> 原文:[https://www . site point . com/Microsoft-fix-they-non-random-browser-choice-screen/](https://www.sitepoint.com/microsoft-fix-their-non-random-browser-choice-screen/)

![browser choice](../Images/cb64177bb0893727eba1a565ff899a2e.png)这里有一个有趣的数学和计算机科学问题:*微软新的[欧盟浏览器选择](https://www.sitepoint.com/european-browser-choice-today/)屏幕的随机程度如何？*根据过去一周发表的几篇统计分析文章，答案是否定的。

IBM 工程师 Rob Weir 在 [browserchoice.eu](http://www.browserchoice.eu/) 上制作了一份关于浏览器订购的较好报告。非随机性是相当复杂的，它不一定有利于互联网浏览器；IE 出现在最后一半的时间，而 Chrome 更有可能出现在前三个位置。

## 从秩序中带来混乱

在数字设备上生成随机数并不容易。大多数实现使用返回伪随机数的数学函数。这看起来可能是随机的，但顺序是可以预测的。然而，这不是微软遇到的问题。

有各种算法来“随机”洗牌，但据 Rob Weir 说，微软选择了最差的一个。他们对 array.sort()使用了以下 JavaScript 比较函数:

```
 function RandomSort(a,b)
{
	return (0.5 - Math.random());
} 
```

由于比较函数返回一个随机结果，排序过程将收到有关其进度的不一致信息。它可以不进行掉期交易，或者从理论上讲，它可以无限期地继续下去。最终，结果不是完全随机的。

Weir 建议微软应该使用 Fisher-Yates shuffle。本质上，这是从源数组中随机选取一个项，并将其移动到目标数组的末尾。该过程继续，直到原始数组中的所有项目都被移动。

## 有关系吗？

在我看来——不。大多数人会看一两次屏幕。在检查包含数千用户的人口样本之前，洗牌的不一致性不会变得明显。

但是微软需要进一步的法律争论吗？对于所有兴奋地期待一场关于浏览器偏见的冗长技术案件的律师们来说，你们来得太晚了。微软已经改变了他们的数组重排算法:

```
 function ArrayShuffle(a) {
	var d, c, b=a.length;

	while(b) {
		c=Math.floor(Math.random()*b);
		d=a[--b];
		a[b]=a `；
a

 `= d；
}
}` 

给定一个五元素数组，该函数将遍历元素 4 到 0(变量 b)。在 0 和 b(变量 c)之间生成一个随机数。然后交换元素 b 和 c。它不是 Fisher-Yates 算法，但它好得多，并且肯定会在 5 次迭代后结束*(尽管它可能会在 4 次迭代后结束，因为最后一个元素总是会与其自身交换)*。

我怀疑它会导致浏览器位置更均匀的随机分布。热切的统计学家肯定会仔细检查结果！` 
```

## ``分享这篇文章``