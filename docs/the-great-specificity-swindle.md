# 大专一骗局！

> 原文：<https://www.sitepoint.com/the-great-specificity-swindle/>

最近我一直在做一个 SitePoint 项目:终极 CSS 参考(即将推出！如果你喜欢 CSS，它将震撼你的世界。当我在网上的阴暗角落寻找神秘 CSS 知识的踪迹时，我意识到网上很多关于 CSS 的信息急需更新。

从 2001 年到现在，我们对 CSS 的知识和理解有了爆炸式的增长，网络上充满了这个启蒙时代写的教程、文章和博客帖子。但是，随着时间的推移和浏览器的改进。现代浏览器对 CSS 的支持水平相当不错，就像对 CSS 黑客的深入了解很快变得多余一样，许多这类材料也是如此。事实上，其中一些完全是误导性的，你的搜索结果一定会充满善意但过时的信息。

在神秘的 CSS 知识中，你会发现一些叫做 CSS 层叠的东西；最终决定每个元素最终风格的东西。它以难以理解而闻名，当浏览器中发生的事情与您预期的完全不一样时，它通常是那些令人沮丧的、模糊的 CSS 问题的原因。网上的大量错误信息当然没有帮助，所以这是我的一点小小的努力来纠正这种情况:打破关于 CSS 级联的两个最大的神话。

## 误解:嵌入样式优先于外部样式，内联样式优先于嵌入样式。

就浏览器而言，CSS 链接到文档的方式没有什么不同；这三种方法被认为有着相同的起源:作者样式表。导致一个覆盖另一个的原因与它们如何链接到文档无关。

如果重要性和特异性是相等的，那么唯一重要的是源顺序；当样式表`link`元素出现在`style`元素之后*时(嵌入样式)，在文档的`head`中，外部样式会覆盖嵌入样式。我认为这个神话的发展是因为通常人们把他们的`link`元素放在他们的`style`元素之前。*

内联样式会覆盖其他样式表中相同的样式声明，只是因为它们具有更高的特异性(见下文)，但是重要的声明(也见下文)会覆盖内联样式，不管这些声明来自哪里——甚至是外部样式表。

## 误区:特异性可以用总分来表示。

你可能以前见过这个公式:

`specificity = number of IDs * 100 + number of classes * 10 + number of elements * 1`

所以像`p.introduction`这样的选择器的选择器得分是 11 (10 + 1)。虽然很容易理解，但可能会产生误导；你可能会认为如果你的选择器中有 10 个元素名，那么它就相当于 1 个类名，这是完全错误的。这个神话可能是旧的 CSS1 和 CSS1 规范中措辞不当的解释的遗产。

1 个 ID 选择器将总是比任何数量的类选择器具有更高的特异性，甚至一百万个类选择器！一旦 cascade 达到了必须按特殊性对两个或更多属性声明进行排序的程度，它就会这样做:

1.  一个是内嵌样式吗？它赢了！如果没有内嵌的，则进行到 b。
2.  计算选择器中 id 的数量。最高分获胜！同分？继续 c。
3.  统计属性、类名和伪类的数量。最高分获胜！同分？进行到 d。
4.  计算元素名或伪元素的数量。最高分获胜！

如果他们在最后一步中得分相同，那么他们具有相同的特异性，源顺序决定哪一个获胜(在源中最后出现的那个)。

[CSS2.1 规范](https://www.w3.org/TR/CSS21/cascade.html#specificity)会以`a,b,c,d`的形式表达上面的计数结果(如果为真，a = 1，否则为 0)。因此，内联样式具有特殊性`1,0,0,0`，而像`p.introduction`这样的选择器具有特殊性`0,0,1,1`(一个类和一个元素名)。你不能只去掉逗号。

这也消除了其他一些小的误解:

*   **错误**:类似`div>p`的子代选择器比后代选择器:`div p`的特异性更高。从上面的过程你可以看到，组合子甚至不包括在内；它们没什么区别。这两个选择器具有相同的特异性`0,0,0,2` (2 个元素名)。通用选择器:`*`，也被忽略。
*   **错误**:像`#someid`这样的选择器比`p#someid`有更高的特异性，因为 ID 选择器排在前面。顺序没什么区别，只要数一下选择器中组件的数量就行了。`#someid`特异性为`0,1,0,0`，`p#someid`特异性更高`0,1,0,1`。
*   **错误的**:一个`!important`声明比正常的声明具有更高的特异性。正如您将在下面看到的，特异性与此无关。
*   **错误**:继承的属性比声明的属性具有更低的特异性。同样，正如您将在下面看到的，特异性与此无关。事实上遗传和级联一点关系都没有！

## 在瀑布前享受舒适

CSS 级联比你想象的更容易理解，一旦你理解了它，你对 CSS 的理解就会有一个巨大的飞跃。

这是 4 个简单步骤的级联:这是针对每个网页元素的每个 CSS 属性发生的过程:

1.  从所有来源收集属性的所有声明。这包括默认浏览器样式和自定义用户样式，以及作者样式表。如果不止一个，请继续 2。
2.  Sort the declarations by importance and origin in the following order (from lowest to highest priority):
    1.  用户代理样式表(默认浏览器样式)
    2.  用户样式表(用户的自定义样式表)中的普通声明
    3.  作者样式表(网页样式表；外部、嵌入和内嵌样式)
    4.  作者样式表中的声明
    5.  用户样式表中的声明

    优先级最高的获胜。如果不止一个具有相同的优先级，则进行到 3。

3.  按选择器特异性排序(参见上面的过程)。拥有最具体选择器的人获胜。如果没有明显的赢家，进行到 4。
4.  在源代码中排在最后的获胜！

如果层叠没有在元素上设置 CSS 属性，那么浏览器将回退到使用从元素的父元素继承的属性(这仅发生在某些属性上)，否则属性被设置为 CSS 默认值。

就这样！不太难，嗯？现在你明白了一些曾经只有大师们知道的关于 CSS 的事情！现在，如果你在玩，起来跳支吉格舞庆祝一下。我当然有！

跑来跑去，头上套着 t 恤，手举在空中，尖叫着呜呜呜！*

好吧，试着不要在你的脑海中想象这些…

如果你想以一种不会让你的大脑融化的方式真正了解 CSS，试试 SitePoint 视频:[CSS 视频速成班](https://www.sitepoint.com/using-html5-video-and-audio-in-modern-browsers/)。

## 分享这篇文章