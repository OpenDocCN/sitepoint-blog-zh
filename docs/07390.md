# 吉姆·威里奇访谈

> 原文:[https://www.sitepoint.com/an-interview-with-jim-weirich/](https://www.sitepoint.com/an-interview-with-jim-weirich/)

| ![](../Images/549d447c8be7246d94530ffc06bf3c0e.png) |
| 吉姆·威里奇是近地天体 T2 T3 的首席科学家 |

我对吉姆·威里奇的名字已经很熟悉了。他还写了我们大多数人日常使用的“rake”工具。今年 6 月，我有幸看到 Jim 在 GoRuCo 做了一个演示，他解释了 rake 的一些更高级的特性。我立刻被吉姆如何能够以自然、简单的方式解释一个非常复杂的话题所打动。今年秋天晚些时候，在 RubyConf，我看到吉姆给[做了一个令人惊叹的主题演讲](http://www.confreaks.com/videos/1287-rubyconf2012-y-not-adventures-in-functional-programming)，他从基本原理中推导出 Y 组合子，并解释了 Lambda 演算背后的一些基本思想。这一次，他不仅清楚地解释了一个更加困难的话题，而且能够将通常枯燥的数学主题变得非常有趣。

这个月，我很高兴有机会为 RubySource 采访吉姆；对我来说，这是一个很好的机会去更多地了解他，以及他是如何进行公开演讲的。我们也有机会谈论他是如何开始成为一名计算机程序员的，他为什么学习 Ruby、函数式编程、Ruby 的线程模型以及他的新的 [RSpec-Given](https://github.com/jimweirich/rspec-given) 框架。我在这里输入了我们谈话中有趣的部分——花几分钟时间了解一下我们行业中最具创新性和魅力的思想领袖之一！

## 计算机程序员的工作描述

问:你是如何开始做电脑程序员的？你为什么选择这个职业？

![](../Images/197f21c3938692291aec43bb02053724.png)

我第一次接触计算机编程是在上世纪 70 年代初的高中。我从图书馆得到一本关于计算机编程的书，书中描述了一台 BCD 风格的计算机。你差不多是用汇编语言编程的。用汇编语言给一台 BCD 计算机编程有点奇怪，但我已经投入进去了。

问:BCD 是什么意思？

![](../Images/197f21c3938692291aec43bb02053724.png)

BCD，“二进制编码的十进制”，意味着所有的数字都以十进制数存储，而不是二进制数。

问:我以前听说过，现在你解释了。

![](../Images/197f21c3938692291aec43bb02053724.png)

这是一个非常不寻常的机器架构，但它适合初学者，适合用它来学习一点编程。我想:“这是一种乐趣！”所以当职业顾问来的时候，我想这可能是我感兴趣的职业。然后我看了一个电脑程序员的描述，听起来很恐怖！

问:描述是什么？

![](../Images/197f21c3938692291aec43bb02053724.png)

大概是这样的:“…你独自一人，坐在黑暗中！…在辛苦工作的时候，你从来不跟任何人说话！”我认为这种编程的东西可能很酷，但一个真正的工作-我永远不会这样做。所以我忘了这件事。

后来在大学里，我的导师说:“你为什么不报名参加这门 FORTRAN 入门课程；听起来很有趣，谁知道你会不会喜欢。”然后我去上课，教官走到黑板前开始写下代码，边走边解释。我记得他放在那里的第一个函数叫做“成员”他正在浏览它，解释它是如何工作的，等等。当我想到:“这一定是 FORTRAN 的某种奇怪的方言…它有太多的括号了！”是口齿不清！结果我进入了唯一一个由丹·弗里德曼教授的编程课程，他写了《T2》的《小口吃者》。

问:那程序员的工作描述呢？你害怕一直在黑暗中独自工作吗？

![](../Images/197f21c3938692291aec43bb02053724.png)

事实上，我发现编程是一种非常社会化的活动。程序员一个人坐在黑暗中，我觉得，不一定是真的。今天，如果你独自在地下室工作，你会通过 Twitter、IRC、各种各样的东西——github 问题列表、邮件列表——与人交流。这不是 1970 年代描绘的那种独狼式的事情。

## 令人高兴的发现

问:你是如何开始使用 Ruby 的？

![](../Images/197f21c3938692291aec43bb02053724.png)

我当时在做 C++和 Java，也做了很多 Perl 做工具。你知道，所有那些小脚本都是每个程序员为了让他的工作更容易而写的。我想这应该是在 2000 年。我真的对 Perl 感到失望。尽管 Perl 确实非常适合您的快速修改，但它的发展似乎并不优雅。你不能用 Perl 做很好的抽象，至少不容易。如果你需要一个列表，Perl 很棒——但是如果你需要一个列表的列表，那么 Perl 就有点笨拙。

我在找别的东西。我想要能表达抽象的东西，因为我是面向对象的程序员，我希望我的脚本语言能支持这种东西。我非常非常努力地研究 Python。这是我第三次尝试学习 Python。但这并不像“砰”的一声，换个位置，我就可以跑了。我不得不停下来，我不得不查找我在 Python 中所做的一切。我从来没有坚持足够长的时间让它成为我的第二天性。

在第三次尝试学习 Python 的过程中，我看到了一封来自[迪夫·托马斯](http://pragdave.pragprog.com)的电子邮件——我不记得具体在哪里了——他说:“我们发现了一种叫做 Ruby 的小语言，我们真的很喜欢它。你可能也会喜欢的。”我刚刚读完《实用程序员 T2》，心想:好吧，如果迪夫·托马斯说这是件好事，那么我一定要去看看。所以我下载了 Ruby，让它运行起来，试了几分钟，心想:“就是它了！这正是我想要的。”三天之内，我完全停止了编写 Perl 脚本，转而开始使用 Ruby。

问:这是什么版本的 Ruby？

![](../Images/197f21c3938692291aec43bb02053724.png)

是 Ruby 1.6。这应该是在 2000 年的夏天。

问:是 Ruby 的什么让你决定这正是你想要的？

![](../Images/197f21c3938692291aec43bb02053724.png)

它以与 Perl 相同的方式做事，但是是以面向对象的方式。所以我会坐下来想:“嗯，在 Perl 中我会这样做，但是如果我有对象，我希望它这样工作。”我会用 Ruby 写它，它就会工作！我很快就可以用它来做所有我用 Perl 做的那些又快又脏的事情，然后我发现 Ruby 有很好的抽象性，并且很好地成长为一门真正的语言。对我来说，这是一个令人高兴的发现。

## Ruby 是函数式编程语言吗？

问:所以 Ruby 是一种面向对象的语言。它也是函数式编程语言吗？那是什么意思？

![](../Images/197f21c3938692291aec43bb02053724.png)

这是一个很好的问题，因为现在函数式语言受到了很多关注。事实上，我们今晚有辛辛那提函数式程序员会议。我告诉我妻子我会为此加班，她说:“好吧，明天晚上你要留下来参加非功能性编程会议？”

有两个因素使语言成为函数式语言。第一件事是作为一等公民操纵功能的能力。你可以传递函数；您可以将它们作为变量绑定；通过使用闭包，你可以为它们创建新的函数，等等。这是成为函数式语言的基本要求。在这方面，Ruby 当然满足了这个要求:我们有 lambdas 和 closures 我们可以将它们绑定到变量上；我们可以动态地创造新的。从这个意义上说，它是一种函数式语言。

不过，还有第二个要求，我认为它让函数式编程变得非常有趣。这就是函数式编程倾向于不使用状态修改语义。而 Ruby 在这方面失败了，因为我们到处都在修改状态！

今天让我对函数式编程感兴趣的是并发的想法。让并发变得困难的是，如果你有两件事情同时发生，并且它们正在处理同一份数据，你就进入了所谓的竞争状态。你不知道哪个是成功的。例如，举一个简单的例子，递增一个整数——两个任务执行这个操作，一个任务获取值，在寄存器中递增，然后存储回来。与此同时，其他人也在接触这个值，在寄存器中递增并存储回来。如果它们以完全正确的方式交错，如果你从 10 开始，两个任务增加 1，那么你可以以 11 而不是 12 结束，只是按照事件的顺序。所以当你共享易变的数据时，你必须非常非常小心。

这个问题有两种解决方法。一是没有共享数据。另一个是不要改变共享数据。函数式编程采用第二种方法。你不会改变数据；本质上，你只会产生新的数据。因此，在这样的纯函数式语言中，并发是微不足道的。我认为在当今的技术环境中，随着笔记本电脑上的 CPU 越来越多，线程代码、并发代码将变得越来越重要。这就是函数式编程如此有趣的原因。像 Clojure 这样的语言有非常非常好的结构，可以轻松地管理多线程，并且不会让线程互相冲突，不会导致争用情况，因为您不需要修改数据。至少在 Clojure 中，当你修改数据时，你是在非常、非常受控的情况下，在安全的情况下这样做的。

我认为 Ruby 正在遭受这种情况，因为它的线程模型已经过时了。

## Ruby 的线程模型

问:对；尤其是核磁共振红宝石。我认为解释器本身不是线程安全的。对吗？

![](../Images/197f21c3938692291aec43bb02053724.png)

解释器是线程安全的，但是他们通过引入全局解释器锁(GIL)使之成为线程安全的。在 RubyConf，他们谈论了很多关于 GIL 的事情。本质上，这意味着当你进入解释器时，它会设置一个锁，这样其他线程就不能同时进入解释器。这使得它是线程安全的，但也使得在这种情况下很难获得有用的线程。

问:然而，其他 Ruby 解释器，比如 JRuby 和 Rubinius，是线程安全的，对吗？

![](../Images/197f21c3938692291aec43bb02053724.png)

是啊！他们在小得多的级别上进行锁定。事实是，如果你从头开始设计一个更小级别的线程安全，那么这并不难做到。真正困难的是事后添加线程安全，这也是 MRI 开发人员正在处理的问题。他们必须在事后添加线程安全，这就是为什么 GIL 是一个简单的解决方案。

我确实听到 Matz 说他们做了一个使用“微锁”的版本——也就是说，当你实际修改共享的表时就锁定。他说它比 GIL 版本运行得慢得多。那么，您是想要一个线程性能更好的较慢的 Ruby，还是拥有 GIL 的较快的 Ruby 呢？这是你必须做出的权衡。所以如果你真的在考虑线程环境，那么 JRuby 和 Rubinius 是值得考虑的。即便如此，在这两种情况下，你仍然会看到共享的可变状态，而 Ruby 目前还没有一个真正好的结构来处理这个问题。

## 每个程序员都应该阅读的 10 篇论文

问:有趣的是，有时看似新的、现代的想法实际上是基于很久以前的研究和思考。例如，我们刚刚讨论的函数式编程思想，或者你在 RubyConf 的主题演讲中谈到的 Lambda 微积分。

![](../Images/197f21c3938692291aec43bb02053724.png)

那是 80 年前的东西了！

问:你有其他类似的例子吗——旧的想法被引入到新的事物中？

![](../Images/197f21c3938692291aec43bb02053724.png)

Michael Feathers 在 2009 年写了一篇很棒的博客文章
，叫做[每个程序员都应该阅读(至少两遍)的 10 篇论文](http://michaelfeathers.tumblr.com/post/81489281/10-papers-every-programmer-should-read-at-least-twice)【作者注:这是 10 篇论文的链接；迈克尔的实际文章最初发表在 Object Mentor 网站上，现在已经不在网上了】。让我指出其中的几篇论文。

[![](../Images/aaef6e0fbf75514bc5520628767cc639.png)](http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf)

第一个是:[关于将系统分解成模块的标准](http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf)，作者 David Parnas。他用了一个非常简单的程序，叫做“上下文中的关键词”，你可以浏览一个文本文件，找到所有的单词，找出它们在哪里被使用，并记录它们被使用的上下文，这样你就可以在索引中显示它们，并在它们周围加上单词。这实际上是一个实验。他以两种不同的方式编写系统，并比较了当他引入需求变更时发生的事情。他发现将程序分解成模块的最好方法是让每个模块隐藏一个秘密。

问:这是面向对象编程背后的思想之一吗？

[![](../Images/197f21c3938692291aec43bb02053724.png)](http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf)

这是其中的一个想法——每个对象都包含信息、实现细节，这些对外界来说无关紧要。你可以在不影响外界的情况下改变这些细节。这项非常基础的研究突出了这是我们真正想做的。这是我非常推荐阅读的论文之一。令我感兴趣的是，他真的做了这个实验。他实际上用两种方式编写了代码，然后衡量了他需要修改多少代码才能达到这个效果。

[![](../Images/8d4e01e5707f46b77a2bb0e0da7ae421.png)](http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf)

另一篇好论文是:[编程能否从冯诺依曼风格中解放出来？](http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf)作者约翰·巴科斯。这是关于他所谓的“ML”的早期论文之一，ML 是一种函数式编程语言。ML 是 Haskell 和 OCaml 的基础。

还有一篇由肯·汤普森写的很棒的论文让我大吃一惊。它是在 1984 年完成的，叫做:[对信任的反思](http://cm.bell-labs.com/who/ken/trust.html)。他描述了如何破解一个编译器，这样他就可以在 Unix 系统中插入一个不在源代码中的 bug。

## 公开演讲

问:我认为你有一种自然的方式使非常困难的话题变得可以理解。你如何把复杂的话题浓缩成对普通观众有意义的东西？

![](../Images/197f21c3938692291aec43bb02053724.png)

我读过很多关于演示的书，关于如何做演示和如何准备演示。书上告诉你要画出轮廓之类的东西——那对我不起作用！

当我准备演讲时，我喜欢使用白板，或者像 Mac 上的 Omnigraffle 这样的东西。我会开始画一些有想法的小盒子。然后我会开始在所有的想法之间画线。所以如果我要做一个关于 Ruby 的演讲，我会列出所有我想谈论的关于 Ruby 的事情。我会在它们之间画一条线——有点像“思维导图”除了我的思维导图更像是一个有向图。

所以我会把所有的概念都写在一张纸上，然后我会试着找到一个故事，它会遍历这个图表，触及所有的主题。不一定是按照我画的箭头所指的顺序，但这涵盖了所有的想法，并由此产生了一个有趣的故事。

问:所以你是一个讲技术故事的人？这是描述它的正确方式吗？

![](../Images/197f21c3938692291aec43bb02053724.png)

实际上，我想要那个描述！

问:将 Lambda 微积分等有时非常枯燥的话题变成一个有趣的故事是一门艺术。我认为，如果我们试图阅读 80 年前关于 Lambda 微积分的原始学术论文，我们大多数人都会感到呆滞。

![](../Images/197f21c3938692291aec43bb02053724.png)

我认为做好演讲的关键是对主题感到兴奋。如果你对此感到兴奋，并让你的观众感受到这种兴奋，那么他们也会感到兴奋。我无法告诉你我大学里有多少教授会用单调的声音说话。这让我抓狂。我说如果我站起来说话，我不会那样做。我会很兴奋，我会让我的兴奋闪耀出来。我认为这是真正的关键。事先所有的准备都会有所帮助，但是如果那种兴奋已经存在，那么你就要表现出来。

## rspec-given

问:在不久的将来，你有什么新的演讲吗？

![](../Images/197f21c3938692291aec43bb02053724.png)

一月份我将谈论我所做的[给定/何时/然后](https://github.com/jimweirich/rspec-given)框架。对此我真的很兴奋。现在每次我去做测试，我都开始使用那个框架。它如此优雅地表达了测试。我会在 [CodeMash](http://codemash.org) 上谈论这个问题。

问:这与黄瓜和 BDD 哲学有关系吗？还是说只是巧合你用的是同三个关键词？

![](../Images/197f21c3938692291aec43bb02053724.png)

这是巧合；没有什么和黄瓜直接相关的。当我使用黄瓜时，我真的很喜欢他们做给定/何时/然后事情的方式。

用 RSpec-Given 你会说:这里是所有需要设置的东西。这是你正在测试的代码，这是你运行测试后的真实情况。在我看来，这是指定测试的一个很好的方式。甚至当我使用 Test::Unit 时，我也经常将我的测试方法分成三个部分:这里是我的给定，这里是我的测试代码，这里是我的断言。但是我真的想要一种非常清楚地表达这一点的方式，这样就可以非常清楚地知道给出了什么，非常清楚地知道代码的哪一部分正在被测试。我认为这在我们的一些非常程序化的测试框架中缺失了很多。Test::Unit 甚至 RSpec 在我看来都没有很清楚地说明这一点。

大约两三年前，我在思考这个问题，我开始在纸上记下想法，当时我在纳什维尔的 Ruby Hoedown，我们一群 EdgeCasers 坐在后面，我在桌子周围传递这份文件，征求意见，Joe O'Brien 转身对我说:“你不是真的在编写另一个测试框架吧？”

我为这些想法奋斗了大约一年或者两年，然后在 RSpec 中偶然发现了一个非常小的实现，它工作得非常非常好。我认为这充分说明了 RSpec 具有正确的抽象，并且非常非常紧密地支持我想要做的事情。我们最终得到的只是位于 RSpec 之上的一个非常非常薄的库。您可以使用您事先获得的所有 RSpec 知识，但随后可以添加这些内容，以便更好地阐明您的代码。

## 分享这篇文章